<!DOCTYPE html><html lang="en" mode="dark" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="day-prompt" content="days ago"><meta name="hour-prompt" content="hours ago"><meta name="minute-prompt" content="minutes ago"><meta name="justnow-prompt" content="just now"><meta name="generator" content="Jekyll v4.3.4" /><meta property="og:title" content="Process Listing e Token Dumping com WinAPI" /><meta name="author" content="H41stur" /><meta property="og:locale" content="en" /><meta name="description" content="“Strange is the night where black stars rise, and strange moons circle through the skies, but stranger still is lost Carcosa.”" /><meta property="og:description" content="“Strange is the night where black stars rise, and strange moons circle through the skies, but stranger still is lost Carcosa.”" /><link rel="canonical" href="https://h41stur.github.io/posts/process-listing/" /><meta property="og:url" content="https://h41stur.github.io/posts/process-listing/" /><meta property="og:site_name" content="H41stur" /><meta property="og:image" content="https://h41stur.github.io/img/posts/process-listing.jpg" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2024-08-19T01:00:00-03:00" /><meta name="twitter:card" content="summary_large_image" /><meta property="twitter:image" content="https://h41stur.github.io/img/posts/process-listing.jpg" /><meta property="twitter:title" content="Process Listing e Token Dumping com WinAPI" /><meta name="twitter:site" content="@twitter_username" /><meta name="twitter:creator" content="@H41stur" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"H41stur"},"dateModified":"2024-08-19T01:00:00-03:00","datePublished":"2024-08-19T01:00:00-03:00","description":"“Strange is the night where black stars rise, and strange moons circle through the skies, but stranger still is lost Carcosa.”","headline":"Process Listing e Token Dumping com WinAPI","image":"https://h41stur.github.io/img/posts/process-listing.jpg","mainEntityOfPage":{"@type":"WebPage","@id":"https://h41stur.github.io/posts/process-listing/"},"url":"https://h41stur.github.io/posts/process-listing/"}</script><title>Process Listing e Token Dumping com WinAPI | H41stur</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="H41stur"><meta name="application-name" content="H41stur"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end" lang="en"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="https://h41stur.github.io/img/h41stur.jpeg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">H41stur</a></div><div class="site-subtitle font-italic">Strange is the night where black stars rise, and strange moons circle through the skies, but stranger still is lost Carcosa.</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIAS</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARQUIVO</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>SOBRE</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/h41stur" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['leonardor.toledo','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="https://www.linkedin.com/in/leo-toledo/" aria-label="linkedin" target="_blank" rel="noopener"> <i class="fab fa-linkedin"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>Process Listing e Token Dumping com WinAPI</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Process Listing e Token Dumping com WinAPI</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> H41stur </span> on <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Mon, Aug 19, 2024, 1:00 AM -0300" >Aug 19, 2024<i class="unloaded">2024-08-19T01:00:00-03:00</i> </span></div><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="16077 words">89 min read</span></div></div><div class="post-content"><p><img data-proofer-ignore data-src="/img/posts/process-listing.jpg" alt="Process Listing e Token Dumping com WinAPI" /></p><h1 id="tldr">TL;DR</h1><p>Este artigo explora técnicas para listar processos e realizar <em>token dumping</em> em sistemas Windows utilizando diversas APIs. Abordamos métodos além da Tool Help Library, como <code class="language-plaintext highlighter-rouge">WTSEnumerateProcessesEx</code>, destacando como essas abordagens podem ser aplicadas em cenários de exploração e reconhecimento de ambientes restritivos. A compreensão e o uso estratégico dessas APIs permitem uma coleta mais profunda de informações críticas sobre o ambiente, essencial para qualquer atividade de análise ou pentesting em sistemas Windows. O artigo fornece exemplos práticos e incentiva a combinação dessas técnicas para maximizar a eficácia das operações.</p><h1 id="introdução">Introdução</h1><p>Em ambientes Windows, independentemente do objetivo de um artefato malicioso em execução, seja ele elevação de privilégios, persistência, movimentação lateral, evasão de defesas, entre outros, um dos primeiros passos críticos para o sucesso de qualquer operação é o reconhecimento completo de tudo que está em execução no sistema. Este reconhecimento vai além da simples descoberta dos nomes dos processos e serviços ativos; envolve a obtenção de informações detalhadas sobre o contexto de execução de cada processo, como seu PID, o usuário associado e o nível de privilégio em que opera. A capacidade de coletar o máximo de informações possíveis desde o início é fundamental para uma compreensão abrangente do ambiente, permitindo uma análise mais precisa e tomada de decisões informadas.</p><p>Embora listar processos seja uma tarefa trivial ao ter acesso direto a um terminal <code class="language-plaintext highlighter-rouge">PowerShell</code> ou <code class="language-plaintext highlighter-rouge">CMD</code>, o desafio se intensifica significativamente em cenários onde essas ferramentas não estão disponíveis ou onde o ambiente é restritivo. Nessas situações, o conhecimento das diversas APIs do Windows se torna inestimável. Em meus artigos anteriores, explorei técnicas como a <a href="https://learn.microsoft.com/en-us/windows/win32/toolhelp/tool-help-library">Tool Help Library</a> para a enumeração de processos, conforme discutido no <a href="https://h41stur.com/posts/get-process/">Enumerando Processos pelo Nome</a>. No entanto, a <em>Tool Help Library</em> representa apenas uma das muitas abordagens possíveis ao utilizar as APIs do Windows.</p><p>Neste artigo, exploraremos alternativas adicionais para a listagem de processos, utilizando técnicas variadas que podem ser particularmente úteis em contextos de exploração avançada. Ao entender e dominar essas diferentes técnicas, não só ampliamos nosso arsenal de ferramentas, mas também aumentamos nossa capacidade de adaptar nossas estratégias às condições específicas de cada ambiente. A fusão dessas técnicas pode levar a resultados mais eficazes, proporcionando <em>insights</em> valiosos que seriam inacessíveis através de métodos convencionais.</p><p>Boa leitura e boa sorte!</p><h1 id="wtsenumerateprocessesex">WTSEnumerateProcessesEx</h1><p>Tendo em vista o objetivo deste artigo, a função <a href="https://learn.microsoft.com/en-us/windows/win32/api/wtsapi32/nf-wtsapi32-wtsenumerateprocessesexa">WTSEnumerateProcessesEx</a> tem um nome bem sugestivo. Na verdade, é uma função criada justamente para listar processos, porém com uma característica muito interessante: <strong>ela pode enumerar processos de sessões <em>desktop</em> remotas</strong>.</p><p>No caso do nosso exemplo, usaremos para enumerar os processos locais, sua sintaxe é:</p><div lang="cpp" class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="n">BOOL</span> <span class="nf">WTSEnumerateProcessesExA</span><span class="p">(</span>
  <span class="p">[</span><span class="n">in</span><span class="p">]</span>      <span class="n">HANDLE</span> <span class="n">hServer</span><span class="p">,</span>
  <span class="p">[</span><span class="n">in</span><span class="p">,</span> <span class="n">out</span><span class="p">]</span> <span class="n">DWORD</span>  <span class="o">*</span><span class="n">pLevel</span><span class="p">,</span>
  <span class="p">[</span><span class="n">in</span><span class="p">]</span>      <span class="n">DWORD</span>  <span class="n">SessionId</span><span class="p">,</span>
  <span class="p">[</span><span class="n">out</span><span class="p">]</span>     <span class="n">LPSTR</span>  <span class="o">*</span><span class="n">ppProcessInfo</span><span class="p">,</span>
  <span class="p">[</span><span class="n">out</span><span class="p">]</span>     <span class="n">DWORD</span>  <span class="o">*</span><span class="n">pCount</span>
<span class="p">);</span>
</pre></table></code></div></div><p>Onde:</p><ul><li><code class="language-plaintext highlighter-rouge">[in] hServer</code> é um <em>handle</em> para um <em>Remote Desktop Session</em>. Este <em>handle</em> pode ser obtido com a função <a href="https://learn.microsoft.com/en-us/windows/win32/api/wtsapi32/nf-wtsapi32-wtsopenservera">WTSOpenServer</a>, porém, como vamos enumerar os processos locais, podemos preenchê-lo com <code class="language-plaintext highlighter-rouge">WTS_CURRENT_SERVER_HANDLE</code> indicando que o servidor é onde o programa está sendo executado;<li><code class="language-plaintext highlighter-rouge">[in, out] pLevel</code> é um ponteiro para uma variável do tipo <code class="language-plaintext highlighter-rouge">DWORD</code> que especifica o tipo de informação queremos enumerar. Quando setado para <code class="language-plaintext highlighter-rouge">0</code>, retorna uma estrutura do tipo <a href="https://learn.microsoft.com/en-us/windows/win32/api/wtsapi32/ns-wtsapi32-wts_process_infoa">WTS_PROCESS_INFO</a>, quando setado para <code class="language-plaintext highlighter-rouge">1</code> retorna uma estrutura do tipo <a href="https://learn.microsoft.com/en-us/windows/win32/api/wtsapi32/ns-wtsapi32-wts_process_info_exa">WTS_PROCESS_INFO_EX</a>, esta segunda, é muito mais completa e será a utilizada em nossa enumeração;<li><code class="language-plaintext highlighter-rouge">[in] SessionId</code> especifica a sessão da qual queremos enumerar. Para enumerar todas as sessões (que pode ser usado em nosso exemplo), podemos setá-la como <code class="language-plaintext highlighter-rouge">WTS_ANY_SESSION</code>;<li><code class="language-plaintext highlighter-rouge">[out] ppProcessInfo</code> um ponteiro para uma variável que recebe um ponteiro para a estrutura que receberá os dados (<code class="language-plaintext highlighter-rouge">WTS_PROCESS_INFO_EX</code>). Esta variável tem duas características importantes: quando não for mais usada, deve ser liberada com a função <a href="https://learn.microsoft.com/en-us/windows/win32/api/wtsapi32/nf-wtsapi32-wtsfreememoryexa">WTSFreeMemoryEx</a>, e, em seguida, esta variável deve ser setada como <code class="language-plaintext highlighter-rouge">NULL</code>;<li><code class="language-plaintext highlighter-rouge">[out] pCount</code> um ponteiro para uma variável que receberá o número de estruturas recebidas na enumeração.</ul><p>Sobre a função <code class="language-plaintext highlighter-rouge">WTSFreeMemoryEx</code> utilizada para liberar a estrutura <code class="language-plaintext highlighter-rouge">WTS_PROCESS_INFO_EX</code> após seu uso, tem a seguinte sintaxe:</p><div lang="cpp" class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="n">BOOL</span> <span class="nf">WTSFreeMemoryExA</span><span class="p">(</span>
  <span class="p">[</span><span class="n">in</span><span class="p">]</span> <span class="n">WTS_TYPE_CLASS</span> <span class="n">WTSTypeClass</span><span class="p">,</span>
  <span class="p">[</span><span class="n">in</span><span class="p">]</span> <span class="n">PVOID</span>          <span class="n">pMemory</span><span class="p">,</span>
  <span class="p">[</span><span class="n">in</span><span class="p">]</span> <span class="n">ULONG</span>          <span class="n">NumberOfEntries</span>
<span class="p">);</span>
</pre></table></code></div></div><p>Onde:</p><ul><li><code class="language-plaintext highlighter-rouge">[in] WTSTypeClass</code> é um valor do tipo <code class="language-plaintext highlighter-rouge">WTS_TYPE_CLASS</code> que especifica o tipo de estrutura a ser liberada, seus valores são:</ul><p><img data-proofer-ignore data-src="/img/posts/Pasted%20image%2020240813215002.png" alt="" /></p><ul><li><code class="language-plaintext highlighter-rouge">[in] pMemory</code> um ponteiro para o <em>buffer</em> que será liberado;<li><code class="language-plaintext highlighter-rouge">[in] NumberOfEntries</code> o número de estruturas que o <em>buffer</em> contém.</ul><h2 id="enumeração-básica">Enumeração básica</h2><p>Somente com estas duas funções é possível obter uma enumeração básica dos processos em execução em uma máquina. Basta invocar a função <code class="language-plaintext highlighter-rouge">WTSEnumerateProcessesEx</code> e imprimir as informações do objeto <code class="language-plaintext highlighter-rouge">PWTS_PROCESS_INFO_EX</code>.</p><div lang="cpp" class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;Windows.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;tchar.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;WtsApi32.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;sddl.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span>
<span class="cp">#pragma comment(lib, "wtsapi32")
#pragma comment(lib, "Advapi32")
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>

	<span class="n">DWORD</span> <span class="n">level</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// variável que indica o tipo da estrutura PWTS_PROCESS_INFO_EX</span>
	<span class="n">PWTS_PROCESS_INFO_EX</span> <span class="n">processes</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="c1">// variável que contém uma estrutura PWTS_PROCESS_INFO_EX vazia</span>
	<span class="n">DWORD</span> <span class="n">processCounter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// variável que conterá a quantidade de estruturas enumeradas</span>

	<span class="c1">// enumerando os processos</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">WTSEnumerateProcessesEx</span><span class="p">(</span>
		<span class="n">WTS_CURRENT_SERVER_HANDLE</span><span class="p">,</span>
		<span class="o">&amp;</span><span class="n">level</span><span class="p">,</span>
		<span class="n">WTS_ANY_SESSION</span><span class="p">,</span>
		<span class="p">(</span><span class="n">LPTSTR</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">processes</span><span class="p">,</span>
		<span class="o">&amp;</span><span class="n">processCounter</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="c1">// imprimindo dados das estruturas</span>
	<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"Processos encontrados: %d</span><span class="se">\n\n</span><span class="s">"</span><span class="p">),</span> <span class="n">processCounter</span><span class="p">);</span>
	<span class="n">PWTS_PROCESS_INFO_EX</span> <span class="n">processesPtr</span> <span class="o">=</span> <span class="n">processes</span><span class="p">;</span>

	<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"#</span><span class="se">\t</span><span class="s">PID</span><span class="se">\t</span><span class="s">Handles</span><span class="se">\t</span><span class="s">Threads</span><span class="se">\t</span><span class="s">Process Name</span><span class="se">\n\n</span><span class="s">"</span><span class="p">));</span>

	<span class="c1">// iterando sobre as estruturas</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">DWORD</span> <span class="n">counter</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">counter</span> <span class="o">&lt;=</span> <span class="n">processCounter</span><span class="p">;</span> <span class="n">counter</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"%d</span><span class="se">\t</span><span class="s">"</span><span class="p">),</span> <span class="n">counter</span><span class="p">);</span>
		<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"%d</span><span class="se">\t</span><span class="s">"</span><span class="p">),</span> <span class="n">processes</span><span class="o">-&gt;</span><span class="n">ProcessId</span><span class="p">);</span>
		<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"%d</span><span class="se">\t</span><span class="s">"</span><span class="p">),</span> <span class="n">processes</span><span class="o">-&gt;</span><span class="n">HandleCount</span><span class="p">);</span>
		<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"%d</span><span class="se">\t</span><span class="s">"</span><span class="p">),</span> <span class="n">processes</span><span class="o">-&gt;</span><span class="n">NumberOfThreads</span><span class="p">);</span>
		<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"%s</span><span class="se">\n</span><span class="s">"</span><span class="p">),</span> <span class="n">processes</span><span class="o">-&gt;</span><span class="n">pProcessName</span><span class="p">);</span>

		<span class="n">processes</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="c1">// liberando a memória da estrutura após o uso</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">WTSFreeMemoryEx</span><span class="p">(</span><span class="n">WTSTypeProcessInfoLevel1</span><span class="p">,</span> <span class="n">processesPtr</span><span class="p">,</span> <span class="n">processCounter</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">processes</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"</span><span class="se">\n\n</span><span class="s">Pressione qualquer tecla para finalizar()</span><span class="se">\n</span><span class="s">"</span><span class="p">));</span>

	<span class="n">getchar</span><span class="p">();</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Ao executarmos o programa, temos todos os processos enumerados em sua saída:</p><p><img data-proofer-ignore data-src="/img/posts/Pasted%20image%2020240813220357.png" alt="" /></p><p>Se compararmos a saída do programa com o <strong><em>Process Explorer</em></strong> do <a href="https://learn.microsoft.com/en-us/sysinternals/">Sysinternals</a>, veremos algo basicamente igual.</p><p><img data-proofer-ignore data-src="/img/posts/Pasted%20image%2020240813221338.png" alt="" /></p><h2 id="implementando-usuário-e-domínio">Implementando usuário e domínio</h2><p>É possível deixar esta listagem de processos ainda mais completa, trazendo o domínio e o usuário que o executa. Estas informações são importantes, pois dizem sobre o contexto no qual um processo está em execução.</p><p>As funções utilizadas até o momento não trazem estas informações, mas tem a base necessária para buscá-las com outras funções. A estrutura <code class="language-plaintext highlighter-rouge">WTS_PROCESS_INFO_EX</code> tem o seguinte formato:</p><div lang="cpp" class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="nc">_WTS_PROCESS_INFO_EXA</span> <span class="p">{</span>
  <span class="n">DWORD</span>         <span class="n">SessionId</span><span class="p">;</span>
  <span class="n">DWORD</span>         <span class="n">ProcessId</span><span class="p">;</span>
  <span class="n">LPSTR</span>         <span class="n">pProcessName</span><span class="p">;</span>
  <span class="n">PSID</span>          <span class="n">pUserSid</span><span class="p">;</span>
  <span class="n">DWORD</span>         <span class="n">NumberOfThreads</span><span class="p">;</span>
  <span class="n">DWORD</span>         <span class="n">HandleCount</span><span class="p">;</span>
  <span class="n">DWORD</span>         <span class="n">PagefileUsage</span><span class="p">;</span>
  <span class="n">DWORD</span>         <span class="n">PeakPagefileUsage</span><span class="p">;</span>
  <span class="n">DWORD</span>         <span class="n">WorkingSetSize</span><span class="p">;</span>
  <span class="n">DWORD</span>         <span class="n">PeakWorkingSetSize</span><span class="p">;</span>
  <span class="n">LARGE_INTEGER</span> <span class="n">UserTime</span><span class="p">;</span>
  <span class="n">LARGE_INTEGER</span> <span class="n">KernelTime</span><span class="p">;</span>
<span class="p">}</span> <span class="n">WTS_PROCESS_INFO_EXA</span><span class="p">,</span> <span class="o">*</span><span class="n">PWTS_PROCESS_INFO_EXA</span><span class="p">;</span>
</pre></table></code></div></div><p>Entre os membros da estrutura, temos o <code class="language-plaintext highlighter-rouge">pUserSid</code> que armazena o <code class="language-plaintext highlighter-rouge">SID</code> do usuário executando o processo.</p><h3 id="sid">SID</h3><p>O SID (<em>Security Identifier</em>) é um identificador exclusivo que o Windows usa para identificar objetos de segurança, como contas de usuário, grupos, contas de computadores, e até mesmo entidades como sessões e serviços. O SID é uma peça fundamental da infraestrutura de segurança do Windows, permitindo ao sistema operacional realizar controle de acesso e gerenciar permissões de maneira eficiente.</p><h4 id="estrutura-do-sid">Estrutura do SID</h4><p>Um SID é uma estrutura binária composta por várias partes que, juntas, garantem a unicidade e a hierarquia do identificador. A estrutura geral de um SID é a seguinte:</p><ul><li><strong><em>Revision</em></strong>: Um <em>byte</em> que indica a versão do SID. Atualmente, o valor é 1.<li><strong><em>SubAuthority Count</em></strong>: Um <em>byte</em> que especifica o número de subautoridades (<em>sub authorities</em>) presentes no SID.<li><strong><em>Identifier Authority</em></strong>: Um valor de 48 bits que identifica a autoridade emissora do SID. Ele define o escopo no qual o SID é único.<li><strong><em>SubAuthorities</em></strong>: Uma série de valores de 32 bits que representam identificadores únicos adicionais, que tornam o SID único dentro do domínio da autoridade.</ul><h4 id="formato-do-sid-texto">Formato do SID (Texto)</h4><p>Quando representado em formato de texto, um SID é exibido de forma legível da seguinte maneira:</p><div lang="plaintext" class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>S-1-5-21-3623811015-3361044348-30300820-1013
</pre></table></code></div></div><p>Esse exemplo pode ser quebrado da seguinte maneira:</p><ul><li><strong>S</strong>: Indica que a sequência representa um SID.<li><strong>1</strong>: Indica a versão do SID (no caso, versão 1).<li><strong>5</strong>: Representa a autoridade emissora. No caso, “5” refere-se à autoridade de segurança NT (<em>Security Authority</em>).<li><strong>21</strong>: Indica que o SID foi emitido por um controlador de domínio ou por uma autoridade emissora local.<li><strong>3623811015-3361044348-30300820</strong>: Esses números são as sub autoridades, e indicam geralmente o domínio ou a máquina onde a conta foi criada.<li><strong>1013</strong>: O identificador relativo (RID - <em>Relative Identifier</em>), que especifica o objeto de segurança específico (como um usuário ou grupo) no domínio ou máquina.</ul><h4 id="tipos-comuns-de-sids">Tipos Comuns de SIDs</h4><p>Alguns SIDs são bem conhecidos porque são usados para identificar grupos e usuários padrão do Windows. Aqui estão alguns exemplos:</p><ul><li><strong>S-1-5-18</strong>: Representa a conta <strong><em>Local System</em></strong>.<li><strong>S-1-5-19</strong>: Representa a conta <strong><em>Local Service</em></strong>.<li><strong>S-1-5-20</strong>: Representa a conta <strong><em>Network Service</em></strong>.<li><strong>S-1-5-32-544</strong>: Representa o grupo <strong><em>Administrators</em></strong>.<li><strong>S-1-5-32-545</strong>: Representa o grupo <strong><em>Users</em></strong>.<li><strong>S-1-5-32-546</strong>: Representa o grupo <strong><em>Guests</em></strong>.</ul><h4 id="função-do-sid-no-controle-de-acesso">Função do SID no Controle de Acesso</h4><p>No Windows, o SID é usado em diversas partes do sistema para controle de acesso. Algumas de suas funções mais importantes incluem:</p><ol><li><p><strong>ACLs (<em>Access Control Lists</em>)</strong>:</p><ul><li><strong>DACL (<em>Discretionary Access Control List</em>)</strong>: A lista que especifica quais SIDs têm permissões de acesso a um objeto, como um arquivo ou pasta. Cada entrada na DACL, chamada de ACE (<em>Access Control Entry</em>), contém um SID e as permissões associadas a esse SID.<li><strong>SACL (<em>System Access Control List</em>)</strong>: Usada para auditoria, especificando quais SIDs devem ser auditados para acesso a um objeto.</ul><li><p><strong>Sessões de Login</strong>:</p><ul><li>Quando um usuário faz login, o Windows usa o SID associado à conta de usuário para identificar o usuário em todo o sistema. Esse SID é associado a um <em>token</em> de segurança que contém todos os SIDs relevantes (como os grupos dos quais o usuário faz parte) e é usado para verificar permissões sempre que o usuário tenta acessar recursos.</ul><li><p><strong>Identificação de Contas e Grupos</strong>:</p><ul><li>Cada conta de usuário ou grupo no Windows tem um SID único. Isso significa que, mesmo se o nome de uma conta de usuário for alterado, o SID permanece o mesmo, garantindo que o sistema possa rastrear consistentemente as permissões e associações de conta.</ul><li><p><strong>Migração de Contas</strong>:</p><ul><li>Quando contas de usuário são migradas entre domínios ou sistemas, os SIDs antigos são preservados usando um conceito chamado <strong><em>SID History</em></strong>. Isso garante que o usuário ainda tenha acesso aos recursos que ele podia acessar anteriormente, mesmo que o SID do novo domínio seja diferente.</ul></ol><p>Uma vez com o <code class="language-plaintext highlighter-rouge">SID</code> do usuário, podemos tomar algumas ações, primeiramente podemos usar a função <a href="https://learn.microsoft.com/en-us/windows/win32/api/sddl/nf-sddl-convertsidtostringsida">ConvertSidToStringSid</a> para convertê-lo em <em>string</em>, assim podendo imprimir seu valor em tela. Esta função tem somente 2 parâmetros:</p><div lang="cpp" class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="n">BOOL</span> <span class="nf">ConvertSidToStringSidA</span><span class="p">(</span>
  <span class="p">[</span><span class="n">in</span><span class="p">]</span>  <span class="n">PSID</span>  <span class="n">Sid</span><span class="p">,</span>
  <span class="p">[</span><span class="n">out</span><span class="p">]</span> <span class="n">LPSTR</span> <span class="o">*</span><span class="n">StringSid</span>
<span class="p">);</span>
</pre></table></code></div></div><ul><li><code class="language-plaintext highlighter-rouge">[in] Sid</code> o próprio SID;<li><code class="language-plaintext highlighter-rouge">[out] StringSid</code> o ponteiro para uma variável que recebe um ponteiro para uma <em>string</em> terminada em <code class="language-plaintext highlighter-rouge">NULL</code>. Este <em>buffer</em> deve ser liberado após seu uso com a função <a href="https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-localfree">LocalFree</a>.</ul><p>Além do <code class="language-plaintext highlighter-rouge">SID</code> em <em>string</em> para impressão, podemos usar a função <a href="https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-lookupaccountsida">LookupAccountSid</a> para obtermos o nome associado a conta que está executando o processo e o primeiro domínio associado ao SID. Esta função tem a seguinte sintaxe:</p><div lang="cpp" class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="n">BOOL</span> <span class="nf">LookupAccountSidA</span><span class="p">(</span>
  <span class="p">[</span><span class="n">in</span><span class="p">,</span> <span class="n">optional</span><span class="p">]</span>  <span class="n">LPCSTR</span>        <span class="n">lpSystemName</span><span class="p">,</span>
  <span class="p">[</span><span class="n">in</span><span class="p">]</span>            <span class="n">PSID</span>          <span class="n">Sid</span><span class="p">,</span>
  <span class="p">[</span><span class="n">out</span><span class="p">,</span> <span class="n">optional</span><span class="p">]</span> <span class="n">LPSTR</span>         <span class="n">Name</span><span class="p">,</span>
  <span class="p">[</span><span class="n">in</span><span class="p">,</span> <span class="n">out</span><span class="p">]</span>       <span class="n">LPDWORD</span>       <span class="n">cchName</span><span class="p">,</span>
  <span class="p">[</span><span class="n">out</span><span class="p">,</span> <span class="n">optional</span><span class="p">]</span> <span class="n">LPSTR</span>         <span class="n">ReferencedDomainName</span><span class="p">,</span>
  <span class="p">[</span><span class="n">in</span><span class="p">,</span> <span class="n">out</span><span class="p">]</span>       <span class="n">LPDWORD</span>       <span class="n">cchReferencedDomainName</span><span class="p">,</span>
  <span class="p">[</span><span class="n">out</span><span class="p">]</span>           <span class="n">PSID_NAME_USE</span> <span class="n">peUse</span>
<span class="p">);</span>
</pre></table></code></div></div><p>Onde:</p><ul><li><code class="language-plaintext highlighter-rouge">[in, optional] lpSystemName</code> é um ponteiro para uma <em>string</em> que contém o computador alvo. Se for setado como <code class="language-plaintext highlighter-rouge">NULL</code> tem um comportamento interessante: primeiro tentará traduzir o nome na máquina local, caso não consiga, tentará resolver nos <em>domain controllers</em> de confiança do sistema local;<li><code class="language-plaintext highlighter-rouge">[in] Sid</code> um ponteiro para o SID a ser pesquisado;<li><code class="language-plaintext highlighter-rouge">[out, optional] Name</code> um ponteiro para um <em>buffer</em> que receberá o <em>account name</em>;<li><code class="language-plaintext highlighter-rouge">[in, out] cchName</code> especifica o tamanho em <code class="language-plaintext highlighter-rouge">TCHARs</code> do <em>buffer</em> que receberá o <em>account name</em>;<li><code class="language-plaintext highlighter-rouge">[out, optional] ReferencedDomainName</code> um ponteiro para um <em>buffer</em> que receberá o <em>domain name</em>;<li><code class="language-plaintext highlighter-rouge">[in, out] cchReferencedDomainName</code> especifica o tamanho em <code class="language-plaintext highlighter-rouge">TCHARs</code> do <em>buffer</em> que receberá o <em>domain name</em>;<li><code class="language-plaintext highlighter-rouge">[out] peUse</code> um ponteiro para uma estrutura <a href="https://learn.microsoft.com/en-us/windows/win32/api/winnt/ne-winnt-sid_name_use">SID_NAME_USE</a> que receberá todos os SIDs vinculados ao SID pesquisado.</ul><p>Estas duas novas funções podem ser implementadas no <em>loop for</em> que itera sobre a lista <code class="language-plaintext highlighter-rouge">PWTS_PROCESS_INFO_EX</code> que geramos.</p><p>A implementação final do programa fica:</p><div lang="cpp" class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;Windows.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;tchar.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;WtsApi32.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;sddl.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span>
<span class="cp">#pragma comment(lib, "wtsapi32")
#pragma comment(lib, "Advapi32")
</span>
<span class="cp">#define MAX_ACCOUNTNAME_LEN 1024
#define MAX_DOMAINNAME_LEN 1024
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>

	<span class="n">DWORD</span> <span class="n">level</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// variável que indica o tipo da estrutura PWTS_PROCESS_INFO_EX</span>
	<span class="n">PWTS_PROCESS_INFO_EX</span> <span class="n">processes</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="c1">// variável que contém uma estrutura PWTS_PROCESS_INFO_EX vazia</span>
	<span class="n">DWORD</span> <span class="n">processCounter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// variável que conterá a quantidade de estruturas enumeradas</span>

	<span class="c1">// enumerando os processos</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">WTSEnumerateProcessesEx</span><span class="p">(</span>
		<span class="n">WTS_CURRENT_SERVER_HANDLE</span><span class="p">,</span>
		<span class="o">&amp;</span><span class="n">level</span><span class="p">,</span>
		<span class="n">WTS_ANY_SESSION</span><span class="p">,</span>
		<span class="p">(</span><span class="n">LPTSTR</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">processes</span><span class="p">,</span>
		<span class="o">&amp;</span><span class="n">processCounter</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="c1">// imprimindo dados das estruturas</span>
	<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"Processos encontrados: %d</span><span class="se">\n\n</span><span class="s">"</span><span class="p">),</span> <span class="n">processCounter</span><span class="p">);</span>
	<span class="n">LPTSTR</span> <span class="n">stringSID</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="c1">// ponteiro do tipo string que receberá o SID do usuário que executa o processo</span>
	<span class="n">PWTS_PROCESS_INFO_EX</span> <span class="n">processesPtr</span> <span class="o">=</span> <span class="n">processes</span><span class="p">;</span>

	<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"#</span><span class="se">\t</span><span class="s">PID</span><span class="se">\t</span><span class="s">Handles</span><span class="se">\t</span><span class="s">Threads</span><span class="se">\t</span><span class="s">Process Name</span><span class="se">\t</span><span class="s">SID</span><span class="se">\t</span><span class="s">Account</span><span class="se">\n\n</span><span class="s">"</span><span class="p">));</span>

	<span class="c1">// iterando sobre as estruturas</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">DWORD</span> <span class="n">counter</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">counter</span> <span class="o">&lt;=</span> <span class="n">processCounter</span><span class="p">;</span> <span class="n">counter</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"%d</span><span class="se">\t</span><span class="s">"</span><span class="p">),</span> <span class="n">counter</span><span class="p">);</span>
		<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"%d</span><span class="se">\t</span><span class="s">"</span><span class="p">),</span> <span class="n">processes</span><span class="o">-&gt;</span><span class="n">ProcessId</span><span class="p">);</span>
		<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"%d</span><span class="se">\t</span><span class="s">"</span><span class="p">),</span> <span class="n">processes</span><span class="o">-&gt;</span><span class="n">HandleCount</span><span class="p">);</span>
		<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"%d</span><span class="se">\t</span><span class="s">"</span><span class="p">),</span> <span class="n">processes</span><span class="o">-&gt;</span><span class="n">NumberOfThreads</span><span class="p">);</span>
		<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"%s</span><span class="se">\t</span><span class="s">"</span><span class="p">),</span> <span class="n">processes</span><span class="o">-&gt;</span><span class="n">pProcessName</span><span class="p">);</span>

		<span class="c1">// convertendo o SID para string</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ConvertSidToStringSid</span><span class="p">(</span><span class="n">processes</span><span class="o">-&gt;</span><span class="n">pUserSid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">stringSID</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"-</span><span class="se">\t</span><span class="s">"</span><span class="p">));</span> <span class="c1">// imprime um traço, caso não consiga converter ou obter o SID</span>
		<span class="p">}</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"%s</span><span class="se">\t</span><span class="s">"</span><span class="p">),</span> <span class="n">stringSID</span><span class="p">);</span>
			<span class="n">LocalFree</span><span class="p">((</span><span class="n">HLOCAL</span><span class="p">)</span><span class="n">stringSID</span><span class="p">);</span> <span class="c1">// libera a memória do ponteiro após seu uso</span>
		<span class="p">}</span>

		<span class="n">TCHAR</span> <span class="n">accountName</span><span class="p">[</span><span class="n">MAX_ACCOUNTNAME_LEN</span><span class="p">];</span>
		<span class="n">DWORD</span> <span class="n">accountNameBuffer</span> <span class="o">=</span> <span class="n">MAX_ACCOUNTNAME_LEN</span><span class="p">;</span>
		<span class="n">TCHAR</span> <span class="n">domainName</span><span class="p">[</span><span class="n">MAX_DOMAINNAME_LEN</span><span class="p">];</span>
		<span class="n">DWORD</span> <span class="n">domainNameBuffer</span> <span class="o">=</span> <span class="n">MAX_DOMAINNAME_LEN</span><span class="p">;</span>
		<span class="n">SID_NAME_USE</span> <span class="n">peUse</span><span class="p">;</span>

		<span class="c1">// procura dados da conta através do SID</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">LookupAccountSid</span><span class="p">(</span>
			<span class="nb">NULL</span><span class="p">,</span>
			<span class="n">processes</span><span class="o">-&gt;</span><span class="n">pUserSid</span><span class="p">,</span>
			<span class="n">accountName</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">accountNameBuffer</span><span class="p">,</span>
			<span class="n">domainName</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">domainNameBuffer</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">peUse</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">));</span>
		<span class="p">}</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"%s</span><span class="se">\\</span><span class="s">%s</span><span class="se">\n</span><span class="s">"</span><span class="p">),</span> <span class="n">domainName</span><span class="p">,</span> <span class="n">accountName</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">processes</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="c1">// liberando a memória da estrutura após o uso</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">WTSFreeMemoryEx</span><span class="p">(</span><span class="n">WTSTypeProcessInfoLevel1</span><span class="p">,</span> <span class="n">processesPtr</span><span class="p">,</span> <span class="n">processCounter</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">processes</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"</span><span class="se">\n\n</span><span class="s">Pressione qualquer tecla para finalizar()</span><span class="se">\n</span><span class="s">"</span><span class="p">));</span>

	<span class="n">getchar</span><span class="p">();</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Ao executarmos o programa, temos impresso em tela todos os SIDs e usuários que foram possíveis de identificar.</p><p><img data-proofer-ignore data-src="/img/posts/Pasted%20image%2020240814072641.png" alt="" /></p><p>Porém, temos uma situação: vários processos não tiveram seus usuários e domínio enumerados. Isso ocorre por uma situação de <strong>extrema importância</strong> em um cenário de exploração: <strong>o programa lista os processos no contexto de quem os está executando</strong>. Ou seja, se o usuário a executar o programa, não tem privilégios administrativos, logo, não terá permissão para idtentificar processos executados pelo <code class="language-plaintext highlighter-rouge">NT AUTHORITY</code>.</p><p>Podemos confirmar isso executando o <code class="language-plaintext highlighter-rouge">Process Explorer</code> do <em>Sysinternals</em> como usuário normal, veremos que <strong>não temos esta permissão</strong>.</p><p><img data-proofer-ignore data-src="/img/posts/Pasted%20image%2020240814073029.png" alt="" /></p><p>Se executarmos nosso programa como <strong>administrador</strong> teremos uma visão mais ampla dos processos em execução:</p><p><img data-proofer-ignore data-src="/img/posts/Pasted%20image%2020240814073935.png" alt="" /></p><p>Assim como ao executar o <code class="language-plaintext highlighter-rouge">Process Explorer</code> como administrador, também nos retornará algo similar:</p><p><img data-proofer-ignore data-src="/img/posts/Pasted%20image%2020240814074032.png" alt="" /></p><p>Entretanto, ainda existe uma questão incompleta neste processo, se analisarmos o <em>output</em> do programa comparado ao <em>output</em> do <code class="language-plaintext highlighter-rouge">Process Explorer</code>, veremos que alguns processos ainda não tiveram seu contexto enumerado mesmo executando como administrador:</p><p><img data-proofer-ignore data-src="/img/posts/Pasted%20image%2020240814074234.png" alt="" /></p><p>Isso ocorre pelo fado de que, mesmo executando nosso programa com privilégios de administrador, existem privilégios mais elevados que por padrão o Windows não implementa por motivos de segurança. Privilégios esses implementados no <code class="language-plaintext highlighter-rouge">Process Explorer</code>, porém não em nosso programa.</p><p>O principal envolvido neste processo é o <code class="language-plaintext highlighter-rouge">SeDebugPrivilege</code>, se analisarmos nosso programa em execução com o <code class="language-plaintext highlighter-rouge">Process Explorer</code> e formos na aba <code class="language-plaintext highlighter-rouge">Security</code>, veremos que o <code class="language-plaintext highlighter-rouge">SeDebugPrivilege</code> está desabilitado mesmo o executando como <strong>administrador</strong>:</p><p><img data-proofer-ignore data-src="/img/posts/Pasted%20image%2020240814080259.png" alt="" /></p><p>Isto pode ser implementado em nosso programa para termos uma visão <strong>total</strong> dos processos.</p><h2 id="habilitando-o-sedebugprivilege">Habilitando o SeDebugPrivilege</h2><p>Habilitar o <code class="language-plaintext highlighter-rouge">SeDebugPrivilege</code> em um programa é uma tarefa relativamente simples, porém, para entendimento de como tudo funciona, é preciso montar um <em>background</em> sólido do processo.</p><h3 id="tokens-de-acesso">Tokens de acesso</h3><p>Um <strong>token de acesso</strong> no Windows é uma estrutura de dados essencial para a segurança do sistema, representando a identidade de um processo ou <em>thread</em>. Ele contém informações sobre os direitos e privilégios de segurança de um usuário, grupo ou dispositivo que está executando o processo ou <em>thread</em>, sendo usado pelo sistema operacional para controlar o acesso a recursos do sistema, como arquivos, pastas, serviços, e outros objetos de segurança.</p><h4 id="o-que-é-um-token-de-acesso">O Que é um Token de Acesso?</h4><p>O token de acesso é fundamental para a segurança do Windows, funcionando como um “passe” que carrega todas as informações de segurança relevantes de um usuário ou processo. Quando um usuário faz login no Windows, o sistema autentica o usuário e gera um token de acesso. Esse token é associado a qualquer processo que o usuário inicie, como um aplicativo ou um serviço.</p><h4 id="conteúdo-de-um-token-de-acesso">Conteúdo de um Token de Acesso</h4><p>Um token de acesso contém várias informações cruciais para o controle de acesso:</p><ol><li><p><strong>SID (<em>Security Identifier</em>)</strong>:</p><ul><li>Cada token contém o SID do usuário ou grupo que possui o processo. O SID identifica exclusivamente o usuário no sistema.</ul><li><p><strong>SIDs de Grupos</strong>:</p><ul><li>O token também contém os SIDs de todos os grupos aos quais o usuário pertence. Isso inclui grupos de segurança como <code class="language-plaintext highlighter-rouge">Administradores</code>, <code class="language-plaintext highlighter-rouge">Usuários</code>, ou grupos específicos da organização.</ul><li><p><strong>Privilégios</strong>:</p><ul><li>Os privilégios são permissões adicionais que um processo pode ter. Eles podem incluir direitos especiais como <code class="language-plaintext highlighter-rouge">SeDebugPrivilege</code>, que permite depurar qualquer processo no sistema.</ul><li><p><strong>Lista de Controle de Acesso (ACLs)</strong>:</p><ul><li>Embora as ACLs sejam usadas para definir permissões em objetos, o token de acesso carrega as permissões que um processo tem com base nas ACLs aplicadas ao usuário.</ul><li><p><strong>Tipo de Token</strong>:</p><ul><li>Os tokens podem ser de dois tipos principais: <code class="language-plaintext highlighter-rouge">Primary</code> e <code class="language-plaintext highlighter-rouge">Impersonation</code>. Tokens primários são usados para criar novos processos, enquanto tokens de impersonação são usados para representar o contexto de segurança de outro usuário, permitindo que um processo “faça-se passar” por outro usuário.</ul><li><p><strong>Nível de Impersonação</strong>:</p><ul><li>Define o grau de acesso que um processo tem ao usar o token de outro usuário. Os níveis incluem <code class="language-plaintext highlighter-rouge">Anonymous</code>, <code class="language-plaintext highlighter-rouge">Identification</code>, <code class="language-plaintext highlighter-rouge">Impersonation</code>, e <code class="language-plaintext highlighter-rouge">Delegation</code>.</ul><li><p><strong>Nível de Integridade</strong>:</p><ul><li>O Windows usa um sistema de níveis de integridade para proteger objetos sensíveis de processos menos confiáveis. O token de acesso contém um SID de nível de integridade que determina as permissões que o processo tem sobre objetos protegidos. Níveis comuns incluem <code class="language-plaintext highlighter-rouge">Low</code>, <code class="language-plaintext highlighter-rouge">Medium</code>, <code class="language-plaintext highlighter-rouge">High</code>, e <code class="language-plaintext highlighter-rouge">System</code>.</ul><li><p><strong>Tempo de Criação e Expiração</strong>:</p><ul><li>Registra quando o token foi criado e, em alguns casos, quando ele expira.</ul></ol><h4 id="como-um-token-de-acesso-é-criado-e-usado">Como um Token de Acesso é Criado e Usado?</h4><ol><li><p><strong>Autenticação do Usuário</strong>:</p><ul><li>Quando um usuário faz login no sistema, seja localmente ou através de uma rede, o Windows autentica o usuário usando credenciais como senha ou certificado. Após a autenticação bem-sucedida, o sistema gera um token de acesso primário.</ul><li><p><strong>Atribuição do Token a Processos</strong>:</p><ul><li>Esse token de acesso é então associado a todos os processos que o usuário inicia. Por exemplo, quando o usuário abre um aplicativo, o Windows copia o token de acesso do usuário para o novo processo, garantindo que o processo herde todas as permissões e restrições do usuário.</ul><li><p><strong>Verificação de Acesso</strong>:</p><ul><li>Quando um processo tenta acessar um recurso (como abrir um arquivo ou modificar uma chave de registro), o Windows verifica o token de acesso associado ao processo contra as ACLs do recurso. Se o SID do usuário ou de qualquer grupo ao qual ele pertence tiver permissão nas ACLs do recurso, o acesso é concedido; caso contrário, é negado.</ul><li><p><strong>Impersonação</strong>:</p><ul><li>Em alguns casos, um processo pode querer agir em nome de outro usuário. Isso é feito usando tokens de impersonação. Por exemplo, um serviço do Windows pode usar um token de impersonação para executar ações em nome de um usuário que está interagindo com o serviço.</ul></ol><h4 id="manipulação-de-tokens-no-windows">Manipulação de Tokens no Windows</h4><p>No desenvolvimento e administração de sistema Windows, é comum precisar manipular tokens de acesso. Algumas funções da API do Windows que permitem a manipulação de tokens de acesso são:</p><ul><li><p><a href="https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-openprocesstoken">OpenProcessToken()</a>:</p><ul><li>Abre o token de acesso associado a um processo existente.</ul><li><p><a href="https://learn.microsoft.com/en-us/windows/win32/api/securitybaseapi/nf-securitybaseapi-gettokeninformation">GetTokenInformation()</a>:</p><ul><li>Obtém informações específicas de um token, como privilégios, SIDs ou o tipo de token.</ul><li><p><a href="https://learn.microsoft.com/en-us/windows/win32/api/securitybaseapi/nf-securitybaseapi-settokeninformation">SetTokenInformation()</a>:</p><ul><li>Modifica informações em um token de acesso, como definir um nível de integridade.</ul><li><p><a href="https://learn.microsoft.com/en-us/windows/win32/api/securitybaseapi/nf-securitybaseapi-adjusttokenprivileges">AdjustTokenPrivileges()</a>:</p><ul><li>Habilita ou desabilita privilégios no token de acesso.</ul><li><p><a href="https://learn.microsoft.com/en-us/windows/win32/api/securitybaseapi/nf-securitybaseapi-duplicatetokenex">DuplicateTokenEx()</a>:</p><ul><li>Cria uma cópia de um token, permitindo a criação de tokens de impersonação ou novos tokens primários com modificações.</ul><li><p><a href="https://learn.microsoft.com/en-us/windows/win32/api/securitybaseapi/nf-securitybaseapi-impersonateloggedonuser">ImpersonateLoggedOnUser()</a>:</p><ul><li>Permite que um processo use um token de um usuário logado para realizar operações em nome desse usuário.</ul></ul><p>Como os tokens de acesso são uma parte central da arquitetura de segurança do Windows. Se um atacante conseguir manipular ou criar tokens de acesso com permissões elevadas, ele pode efetuar um <strong>Privilege Escalation</strong>, ganhando controle sobre partes significativas ou até mesmo todo o sistema.</p><p>Em outras palavras: quem controla os tokens, controla o SO.</p><h3 id="luid">LUID</h3><p>Um <strong>LUID (<em>Locally Unique Identifier</em>)</strong>, é um identificador de 64 bits usado no sistema operacional para identificar de maneira única um objeto ou evento em um contexto local, como dentro de um computador ou uma sessão de sistema operacional. Isso significa que, enquanto o computador estiver em execução, qualquer LUID gerado por ele será único. Após um reinício, no entanto, o mesmo LUID pode ser gerado novamente, o que não é um problema já que ele é único somente na instância atual do sistema. O LUID é utilizado principalmente em questões relacionadas à segurança, especialmente no contexto de privilégios e tokens de acesso.</p><h4 id="estrutura">Estrutura</h4><p>O LUID é um valor de 64 bits (<code class="language-plaintext highlighter-rouge">unsigned long long</code> ou <code class="language-plaintext highlighter-rouge">DWORDLONG</code>) e, por isso, pode representar uma vasta quantidade de identificadores únicos. No Windows, ele é representado pela estrutura <code class="language-plaintext highlighter-rouge">LUID</code>, que é composta por dois valores de 32 bits (<code class="language-plaintext highlighter-rouge">LowPart</code> e <code class="language-plaintext highlighter-rouge">HighPart</code>).</p><h4 id="onde-o-luid-é-usado">Onde o LUID é Usado?</h4><p>Os LUIDs são usados em várias partes do sistema operacional Windows, mas são particularmente relevantes em questões de segurança e gestão de privilégios. Eles aparecem em contextos como:</p><ol><li><p><strong>Privilégios de Segurança</strong>:</p><ul><li><p>No Windows, privilégios são operações ou capacidades especiais que podem ser concedidas a processos ou usuários. Cada privilégio tem um LUID associado a ele. Quando um processo ou <em>thread</em> precisa habilitar ou verificar um privilégio, o Windows usa o LUID para identificar o privilégio específico.</p><li><p>Por exemplo, o privilégio <code class="language-plaintext highlighter-rouge">SeDebugPrivilege</code> tem um LUID específico que pode ser consultado e usado em operações que manipulam privilégios, como <code class="language-plaintext highlighter-rouge">AdjustTokenPrivileges()</code>.</p></ul><li><p><strong>Auditoria e Segurança</strong>:</p><ul><li>O LUID é usado em auditoria de segurança e eventos para garantir que eventos ou privilégios possam ser identificados de maneira única durante a execução do sistema.</ul><li><p><strong>Tokens de Acesso</strong>:</p><ul><li>Dentro de tokens de acesso, que representam a identidade e privilégios de um processo, os LUIDs são usados para definir privilégios específicos que o token possui ou que podem ser ajustados.</ul></ol><h4 id="funcionamento-e-geração-do-luid">Funcionamento e Geração do LUID</h4><h5 id="geração-do-luid">Geração do LUID</h5><p>No Windows, LUIDs são gerados utilizando uma função do sistema chamada <code class="language-plaintext highlighter-rouge">AllocateLocallyUniqueId()</code>. Esta função garante que cada LUID gerado seja único no contexto do sistema operacional atual. A geração do LUID é eficiente, o que é importante para manter o desempenho do sistema, mesmo quando LUIDs são necessários com frequência.</p><h5 id="estrutura-do-luid-em-c">Estrutura do LUID (em C++)</h5><div lang="cpp" class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="nc">_LUID</span> <span class="p">{</span>
  <span class="n">DWORD</span> <span class="n">LowPart</span><span class="p">;</span>
  <span class="n">LONG</span>  <span class="n">HighPart</span><span class="p">;</span>
<span class="p">}</span> <span class="n">LUID</span><span class="p">,</span> <span class="o">*</span><span class="n">PLUID</span><span class="p">;</span>
</pre></table></code></div></div><p>Onde:</p><ul><li><strong><code class="language-plaintext highlighter-rouge">LowPart</code></strong>: Contém os 32 bits menos significativos do LUID;<li><strong><code class="language-plaintext highlighter-rouge">HighPart</code></strong>: Contém os 32 bits mais significativos do LUID.</ul><h3 id="sedebugprivilege">SeDebugPrivilege</h3><p>O <strong>SeDebugPrivilege</strong> é um privilégio de segurança no Windows que concede a um usuário ou processo a capacidade de depurar e interagir com processos pertencentes a outros usuários, incluindo aqueles que pertencem ao sistema. Este privilégio é extremamente poderoso e, por isso, é geralmente restrito a contas administrativas ou a processos específicos que necessitam realizar tarefas de diagnóstico ou depuração ao nível de sistema.</p><p>Privilégios como este são particularmente críticos porque concedem capacidades que, se mal utilizadas, podem comprometer completamente a segurança e a integridade de um sistema. Devido à natureza sensível desse privilégio, ele é geralmente concedido apenas a contas administrativas e, em muitos casos, apenas é habilitado temporariamente e de maneira controlada.</p><h4 id="principais-funções-do-sedebugprivilege">Principais Funções do SeDebugPrivilege</h4><ol><li><p><strong><em>Debugging</em> de Processos</strong>:</p><ul><li>O <code class="language-plaintext highlighter-rouge">SeDebugPrivilege</code> permite que um usuário ou processo anexe um <em>debugger</em> a qualquer processo em execução no sistema, independentemente do usuário proprietário do processo. Isso inclui processos executados com privilégios elevados, como serviços do sistema ou processos do núcleo do sistema operacional.</ul><li><p><strong><em>Bypass</em> de Controle de Acesso</strong>:</p><ul><li>Um dos aspectos mais poderosos desse privilégio é que ele permite ao titular ignorar as restrições de segurança que normalmente impedem um processo de acessar ou manipular processos de outros usuários. Por exemplo, um administrador com <code class="language-plaintext highlighter-rouge">SeDebugPrivilege</code> pode terminar, modificar ou injetar código em processos protegidos.</ul><li><p><strong>Análise e Diagnóstico de Sistemas</strong>:</p><ul><li>Esse privilégio é frequentemente utilizado em ferramentas de diagnóstico e análise de segurança, como <em>debuggers</em> e analisadores de memória, que precisam acessar profundamente o sistema para monitorar ou manipular processos.</ul><li><p><strong>Caminho de Exploração em Ataques</strong>:</p><ul><li>Devido ao poder que ele concede, o <code class="language-plaintext highlighter-rouge">SeDebugPrivilege</code> é frequentemente alvo de explorações. Um atacante que consegue obter <code class="language-plaintext highlighter-rouge">SeDebugPrivilege</code> em um sistema pode essencialmente ganhar controle total sobre o sistema, podendo terminar processos de segurança, injetar <em>malware</em> em processos confiáveis ou extrair informações sensíveis de processos em execução.</ul></ol><h4 id="funcionamento">Funcionamento</h4><p>Quando um processo é iniciado, ele recebe um token de acesso que especifica os privilégios que o processo possui. Privilégios como <code class="language-plaintext highlighter-rouge">SeDebugPrivilege</code> não estão habilitados por padrão, mesmo para processos que têm direito a eles. Isso é uma medida de segurança para minimizar o risco de abuso.</p><h4 id="habilitação-de-sedebugprivilege">Habilitação de SeDebugPrivilege:</h4><p>Um processo que precisa usar <code class="language-plaintext highlighter-rouge">SeDebugPrivilege</code> deve primeiro habilitá-lo explicitamente, o que pode ser feito por meio de chamadas à API do Windows, como <code class="language-plaintext highlighter-rouge">AdjustTokenPrivileges</code>.</p><ol><li><p><strong>Obtenção do Token do Processo</strong>:</p><ul><li>O processo chama <code class="language-plaintext highlighter-rouge">OpenProcessToken()</code> para obter o token de acesso associado ao seu próprio processo.</ul><li><p><strong>Ajuste de Privilégios</strong>:</p><ul><li>Em seguida, o processo usa <code class="language-plaintext highlighter-rouge">LookupPrivilegeValue()</code> para obter o identificador do <code class="language-plaintext highlighter-rouge">SeDebugPrivilege</code> e <code class="language-plaintext highlighter-rouge">AdjustTokenPrivileges()</code> para habilitar esse privilégio no token.</ul><li><p><strong>Uso do Privilégio</strong>:</p><ul><li>Após a habilitação, o processo pode usar APIs como <code class="language-plaintext highlighter-rouge">OpenProcess()</code>, <code class="language-plaintext highlighter-rouge">TerminateProcess()</code>, ou <code class="language-plaintext highlighter-rouge">WriteProcessMemory()</code> para interagir com processos que normalmente estariam fora do alcance devido a restrições de segurança.</ul></ol><h4 id="uso-legítimo-vs-abuso">Uso Legítimo vs. Abuso</h4><p>Sendo um privilégio muito delicado, pode-se considerá-lo uma faca de dois gumes.</p><ul><li><p><strong>Uso Legítimo</strong>:</p><ul><li>Ferramentas de desenvolvimento e <em>debugging</em>, como o Visual Studio, frequentemente precisam habilitar <code class="language-plaintext highlighter-rouge">SeDebugPrivilege</code> para depurar processos do sistema ou serviços.<li>Em ambientes de TI, administradores podem habilitar esse privilégio para investigar problemas de desempenho, travamentos de processos, ou comportamento anômalo em sistemas.</ul><li><p><strong>Abuso e Exploração</strong>:</p><ul><li><strong>Escalação de Privilégios</strong>: Se um atacante obtiver acesso a uma conta de usuário com baixos privilégios, mas conseguir ativar <code class="language-plaintext highlighter-rouge">SeDebugPrivilege</code>, ele pode escalar seus privilégios para acessar processos de sistema críticos.<li><strong>Injeção de Código</strong>: Um invasor com <code class="language-plaintext highlighter-rouge">SeDebugPrivilege</code> pode injetar código malicioso em processos de alta integridade, como antivírus ou serviços de sistema, comprometendo essencialmente a segurança do sistema de forma invisível.<li><strong>Desativação de Segurança</strong>: Ferramentas de segurança, como antivírus, executadas com privilégios elevados, podem ser terminadas ou manipuladas por um atacante com <code class="language-plaintext highlighter-rouge">SeDebugPrivilege</code>.</ul></ul><h3 id="implementando-o-código">Implementando o código</h3><p>Uma vez que a base para a implementação está construída, podemos criar uma função que irá alterar a propriedade <code class="language-plaintext highlighter-rouge">SeDebugPrivilege</code> no token pertencente ao nosso programa.</p><p>O primeiro passo é usar a função <a href="https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-lookupprivilegevaluea">LookupPrivilegeValue</a> para obter o LUID do <code class="language-plaintext highlighter-rouge">SeDebugPrivilege</code>. Esta função tem a seguinte sintaxe:</p><div lang="cpp" class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="n">BOOL</span> <span class="nf">LookupPrivilegeValueA</span><span class="p">(</span>
  <span class="p">[</span><span class="n">in</span><span class="p">,</span> <span class="n">optional</span><span class="p">]</span> <span class="n">LPCSTR</span> <span class="n">lpSystemName</span><span class="p">,</span>
  <span class="p">[</span><span class="n">in</span><span class="p">]</span>           <span class="n">LPCSTR</span> <span class="n">lpName</span><span class="p">,</span>
  <span class="p">[</span><span class="n">out</span><span class="p">]</span>          <span class="n">PLUID</span>  <span class="n">lpLuid</span>
<span class="p">);</span>
</pre></table></code></div></div><p>Onde:</p><ul><li><code class="language-plaintext highlighter-rouge">[in, optional] lpSystemName</code> é um ponteiro para uma <em>string</em> que contém o nome do sistema onde o privilégio será recuperado. Se for passado o valor <code class="language-plaintext highlighter-rouge">NULL</code>, a função tenta recuperar o privilégio no sistema local;<li><code class="language-plaintext highlighter-rouge">[in] lpName</code> um ponteiro para a <em>string</em> que contém qual privilégio queremos recuperar;<li><code class="language-plaintext highlighter-rouge">[out] lpLuid</code> o ponteiro para uma variável que receberá o LUID após a pesquisa.</ul><p>No código, teremos algo como:</p><div lang="cpp" class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="n">LUID</span> <span class="n">privilegeLuid</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">LookupPrivilegeValue</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">_T</span><span class="p">(</span><span class="s">"SeDebugPrivilege"</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">privilegeLuid</span><span class="p">))</span> <span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Uma vez com o LUID do <code class="language-plaintext highlighter-rouge">SeDebugPrivilege</code>, podemos criar uma estrutura do tipo <a href="https://learn.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-token_privileges">TOKEN_PRIVILEGES</a> para manipular o token original do programa. Esta estrutura tem o seguinte formato:</p><div lang="cpp" class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="nc">_TOKEN_PRIVILEGES</span> <span class="p">{</span>
  <span class="n">DWORD</span>               <span class="n">PrivilegeCount</span><span class="p">;</span>
  <span class="n">LUID_AND_ATTRIBUTES</span> <span class="n">Privileges</span><span class="p">[</span><span class="n">ANYSIZE_ARRAY</span><span class="p">];</span>
<span class="p">}</span> <span class="n">TOKEN_PRIVILEGES</span><span class="p">,</span> <span class="o">*</span><span class="n">PTOKEN_PRIVILEGES</span><span class="p">;</span>
</pre></table></code></div></div><p>Onde:</p><ul><li><code class="language-plaintext highlighter-rouge">PrivilegeCount</code> especifica a quantidade de privilégios que a <em>array</em> da estrutura conterá, em nosso caso <strong>1</strong>;<li><code class="language-plaintext highlighter-rouge">Privileges[ANYSIZE_ARRAY]</code> especifica um <em>array</em> de estruturas <a href="https://learn.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-luid_and_attributes">LUID_AND_ATTRIBUTES</a>, este <em>array</em> conterá o LUID do privilégio e o atributo que ele receberá, de acordo com estes <a href="https://learn.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-privilege_set">atributos</a>, utilizaremos o <code class="language-plaintext highlighter-rouge">SE_PRIVILEGE_ENABLED</code>:</ul><p><img data-proofer-ignore data-src="/img/posts/Pasted%20image%2020240814140324.png" alt="" /></p><p>No código, teremos algo como:</p><div lang="cpp" class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="c1">// criando a estrutura do token</span>
<span class="n">TOKEN_PRIVILEGES</span> <span class="n">tkPrivs</span><span class="p">;</span>

<span class="n">tkPrivs</span><span class="p">.</span><span class="n">PrivilegeCount</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// quantidade de privilégios a serem configurados</span>
<span class="n">tkPrivs</span><span class="p">.</span><span class="n">Privileges</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">Luid</span> <span class="o">=</span> <span class="n">privilegeLuid</span><span class="p">;</span> <span class="c1">// LUID do primeiro e único privilégio (SeDebugPrivilege)</span>
<span class="n">tkPrivs</span><span class="p">.</span><span class="n">Privileges</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">Attributes</span> <span class="o">=</span> <span class="n">SE_PRIVILEGE_ENABLED</span><span class="p">;</span> <span class="c1">// atributo que o privilégio receberá</span>
</pre></table></code></div></div><p>Com esta base configurada, temos que criar um <em>handle</em> para o token do processo atual, no caso nosso programa, com os direitos de alteração de privilégios. Faremos isso com a função <a href="https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-openprocesstoken">OpenProcessToken</a>.</p><p>Esta função exige um <em>handle</em> para o processo atual, uma máscara de acesso que informará os direitos de acesso que queremos nesse token e um ponteiro para um <em>handle</em> que receberá o token aberto. Os <a href="https://learn.microsoft.com/en-us/windows/win32/secauthz/access-rights-for-access-token-objects">direitos de acesso</a> seguem a seguinte tabela:</p><p><img data-proofer-ignore data-src="/img/posts/Pasted%20image%2020240814141148.png" alt="" /></p><p>Logo, em nosso caso, utilizaremos <code class="language-plaintext highlighter-rouge">TOKEN_ADJUST_PRIVILEGES</code>, uma vez que queremos habilitar um privilégio.</p><p>No código, teremos algo como:</p><div lang="cpp" class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="n">HANDLE</span> <span class="n">currentProcessHandle</span> <span class="o">=</span> <span class="n">GetCurrentProcess</span><span class="p">();</span>
<span class="n">HANDLE</span> <span class="n">processToken</span><span class="p">;</span>

<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">OpenProcessToken</span><span class="p">(</span><span class="n">currentProcessHandle</span><span class="p">,</span> <span class="n">TOKEN_ADJUST_PRIVILEGES</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">processToken</span><span class="p">))</span> <span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Por fim, utilizaremos a função <a href="https://learn.microsoft.com/en-us/windows/win32/api/securitybaseapi/nf-securitybaseapi-adjusttokenprivileges">AdjustTokenPrivileges</a> que serve para habilitar ou desabilitar privilégios em tokens. Esta função receberá o <em>handle</em> para o token que geramos anteriormente, e um ponteiro para a estrutura <code class="language-plaintext highlighter-rouge">TOKEN_PRIVILEGES</code> que montamos. No código teremos algo como:</p><div lang="cpp" class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">AdjustTokenPrivileges</span><span class="p">(</span><span class="n">processToken</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tkPrivs</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Todos estes passos podem ser enfileirados em uma função dentro do nosso código, que será invocada logo no início da <code class="language-plaintext highlighter-rouge">main</code>. O código completo fica:</p><div lang="cpp" class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;Windows.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;tchar.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;WtsApi32.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;sddl.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span>
<span class="cp">#pragma comment(lib, "wtsapi32")
#pragma comment(lib, "Advapi32")
</span>
<span class="cp">#define MAX_ACCOUNTNAME_LEN 1024
#define MAX_DOMAINNAME_LEN 1024
</span>
<span class="c1">// função para habilitar SeDebugPrivilege</span>
<span class="n">BOOL</span> <span class="nf">EnableSeDebug</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>

	<span class="n">LUID</span> <span class="n">privilegeLuid</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">LookupPrivilegeValue</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">_T</span><span class="p">(</span><span class="s">"SeDebugPrivilege"</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">privilegeLuid</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="c1">// criando a estrutura do token</span>
	<span class="n">TOKEN_PRIVILEGES</span> <span class="n">tkPrivs</span><span class="p">;</span>

	<span class="n">tkPrivs</span><span class="p">.</span><span class="n">PrivilegeCount</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// quantidade de privilégios a serem configurados</span>
	<span class="n">tkPrivs</span><span class="p">.</span><span class="n">Privileges</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">Luid</span> <span class="o">=</span> <span class="n">privilegeLuid</span><span class="p">;</span> <span class="c1">// LUID do primeiro e único privilégio (SeDebugPrivilege)</span>
	<span class="n">tkPrivs</span><span class="p">.</span><span class="n">Privileges</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">Attributes</span> <span class="o">=</span> <span class="n">SE_PRIVILEGE_ENABLED</span><span class="p">;</span> <span class="c1">// atributo que o privilégio receberá</span>

	<span class="n">HANDLE</span> <span class="n">currentProcessHandle</span> <span class="o">=</span> <span class="n">GetCurrentProcess</span><span class="p">();</span>
	<span class="n">HANDLE</span> <span class="n">processToken</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">OpenProcessToken</span><span class="p">(</span><span class="n">currentProcessHandle</span><span class="p">,</span> <span class="n">TOKEN_ADJUST_PRIVILEGES</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">processToken</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">AdjustTokenPrivileges</span><span class="p">(</span><span class="n">processToken</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tkPrivs</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">TRUE</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>

	<span class="n">EnableSeDebug</span><span class="p">();</span>

	<span class="n">DWORD</span> <span class="n">level</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// variável que indica o tipo da estrutura PWTS_PROCESS_INFO_EX</span>
	<span class="n">PWTS_PROCESS_INFO_EX</span> <span class="n">processes</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="c1">// variável que contém uma estrutura PWTS_PROCESS_INFO_EX vazia</span>
	<span class="n">DWORD</span> <span class="n">processCounter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// variável que conterá a quantidade de estruturas enumeradas</span>

	<span class="c1">// enumerando os processos</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">WTSEnumerateProcessesEx</span><span class="p">(</span>
		<span class="n">WTS_CURRENT_SERVER_HANDLE</span><span class="p">,</span>
		<span class="o">&amp;</span><span class="n">level</span><span class="p">,</span>
		<span class="n">WTS_ANY_SESSION</span><span class="p">,</span>
		<span class="p">(</span><span class="n">LPTSTR</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">processes</span><span class="p">,</span>
		<span class="o">&amp;</span><span class="n">processCounter</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="c1">// imprimindo dados das estruturas</span>
	<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"Processos encontrados: %d</span><span class="se">\n\n</span><span class="s">"</span><span class="p">),</span> <span class="n">processCounter</span><span class="p">);</span>
	<span class="n">LPTSTR</span> <span class="n">stringSID</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="c1">// ponteiro do tipo string que receberá o SID do usuário que executa o processo</span>
	<span class="n">PWTS_PROCESS_INFO_EX</span> <span class="n">processesPtr</span> <span class="o">=</span> <span class="n">processes</span><span class="p">;</span>

	<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"#</span><span class="se">\t</span><span class="s">PID</span><span class="se">\t</span><span class="s">Handles</span><span class="se">\t</span><span class="s">Threads</span><span class="se">\t</span><span class="s">Process Name</span><span class="se">\t</span><span class="s">SID</span><span class="se">\t</span><span class="s">Account</span><span class="se">\n\n</span><span class="s">"</span><span class="p">));</span>

	<span class="c1">// iterando sobre as estruturas</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">DWORD</span> <span class="n">counter</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">counter</span> <span class="o">&lt;=</span> <span class="n">processCounter</span><span class="p">;</span> <span class="n">counter</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"%d</span><span class="se">\t</span><span class="s">"</span><span class="p">),</span> <span class="n">counter</span><span class="p">);</span>
		<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"%d</span><span class="se">\t</span><span class="s">"</span><span class="p">),</span> <span class="n">processes</span><span class="o">-&gt;</span><span class="n">ProcessId</span><span class="p">);</span>
		<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"%d</span><span class="se">\t</span><span class="s">"</span><span class="p">),</span> <span class="n">processes</span><span class="o">-&gt;</span><span class="n">HandleCount</span><span class="p">);</span>
		<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"%d</span><span class="se">\t</span><span class="s">"</span><span class="p">),</span> <span class="n">processes</span><span class="o">-&gt;</span><span class="n">NumberOfThreads</span><span class="p">);</span>
		<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"%s</span><span class="se">\t</span><span class="s">"</span><span class="p">),</span> <span class="n">processes</span><span class="o">-&gt;</span><span class="n">pProcessName</span><span class="p">);</span>

		<span class="c1">// convertendo o SID para string</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ConvertSidToStringSid</span><span class="p">(</span><span class="n">processes</span><span class="o">-&gt;</span><span class="n">pUserSid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">stringSID</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"-</span><span class="se">\t</span><span class="s">"</span><span class="p">));</span> <span class="c1">// imprime um traço, caso não consiga converter ou obter o SID</span>
		<span class="p">}</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"%s</span><span class="se">\t</span><span class="s">"</span><span class="p">),</span> <span class="n">stringSID</span><span class="p">);</span>
			<span class="n">LocalFree</span><span class="p">((</span><span class="n">HLOCAL</span><span class="p">)</span><span class="n">stringSID</span><span class="p">);</span> <span class="c1">// libera a memória do ponteiro após seu uso</span>
		<span class="p">}</span>

		<span class="n">TCHAR</span> <span class="n">accountName</span><span class="p">[</span><span class="n">MAX_ACCOUNTNAME_LEN</span><span class="p">];</span>
		<span class="n">DWORD</span> <span class="n">accountNameBuffer</span> <span class="o">=</span> <span class="n">MAX_ACCOUNTNAME_LEN</span><span class="p">;</span>
		<span class="n">TCHAR</span> <span class="n">domainName</span><span class="p">[</span><span class="n">MAX_DOMAINNAME_LEN</span><span class="p">];</span>
		<span class="n">DWORD</span> <span class="n">domainNameBuffer</span> <span class="o">=</span> <span class="n">MAX_DOMAINNAME_LEN</span><span class="p">;</span>
		<span class="n">SID_NAME_USE</span> <span class="n">peUse</span><span class="p">;</span>

		<span class="c1">// procura dados da conta através do SID</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">LookupAccountSid</span><span class="p">(</span>
			<span class="nb">NULL</span><span class="p">,</span>
			<span class="n">processes</span><span class="o">-&gt;</span><span class="n">pUserSid</span><span class="p">,</span>
			<span class="n">accountName</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">accountNameBuffer</span><span class="p">,</span>
			<span class="n">domainName</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">domainNameBuffer</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">peUse</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">));</span>
		<span class="p">}</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"%s</span><span class="se">\\</span><span class="s">%s</span><span class="se">\n</span><span class="s">"</span><span class="p">),</span> <span class="n">domainName</span><span class="p">,</span> <span class="n">accountName</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">processes</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="c1">// liberando a memória da estrutura após o uso</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">WTSFreeMemoryEx</span><span class="p">(</span><span class="n">WTSTypeProcessInfoLevel1</span><span class="p">,</span> <span class="n">processesPtr</span><span class="p">,</span> <span class="n">processCounter</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">processes</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"</span><span class="se">\n\n</span><span class="s">Pressione qualquer tecla para finalizar()</span><span class="se">\n</span><span class="s">"</span><span class="p">));</span>

	<span class="n">getchar</span><span class="p">();</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Agora, quando executamos o programa com privilégios de administrador, podemos ver no <code class="language-plaintext highlighter-rouge">Process Explorer</code> que o privilégio <code class="language-plaintext highlighter-rouge">SeDebugPrivilege</code> está habilitado, e os processos antes não enumerados agora trazem seu contexto.</p><p><img data-proofer-ignore data-src="/img/posts/Pasted%20image%2020240814142341.png" alt="" /></p><h2 id="melhorando-o-código">Melhorando o Código</h2><p>O programa criado para listar os processos está funcionando normalmente, porém ele não está preparado para alguns cenários específicos. Uma vez que nem sempre o executaremos com privilégios administrativos, é preciso saber se é possível habilitar o <code class="language-plaintext highlighter-rouge">SeDebugPrivilege</code>.</p><p>Quando executamos o programa com privilégios de usuário, ele não retorna erro, mesmo quando invocamos a função que habilita os privilégios, o único comportamento é o de não trazer as informações que não tem acesso.</p><p>Isso corre, pois a função <code class="language-plaintext highlighter-rouge">AdjustTokenPrivileges</code> não adiciona novos privilégios a um token, e sim habilita ou desabilita um privilégio já existente. Se executarmos o programa com privilégios de usuário e checarmos com o <code class="language-plaintext highlighter-rouge">Process Explorer</code>, veremos que neste contexto o <code class="language-plaintext highlighter-rouge">SeDebugPrivilege</code> nem está presente.</p><p><img data-proofer-ignore data-src="/img/posts/Pasted%20image%2020240814163148.png" alt="" /></p><p>Isso significa que a função não consegue habilitar ou desabilitar o privilégio, porém, ela não falha. Ao invés de falhar, a função simplesmente ignora os privilégios que não existem e continua sua execução.</p><p>Para termos um vislumbre do que está, acontecendo, podemos invocar a função <a href="https://learn.microsoft.com/en-us/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> para identificar o que está havendo. Existe um <a href="https://learn.microsoft.com/en-us/windows/win32/Debug/retrieving-the-last-error-code">código de exemplo</a> fornecido pela própria Microsoft de como usar esta função. Abaixo o código:</p><div lang="cpp" class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;windows.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;strsafe.h&gt;</span><span class="cp">
</span>
<span class="kt">void</span> <span class="nf">ErrorExit</span><span class="p">(</span><span class="n">LPCTSTR</span> <span class="n">lpszFunction</span><span class="p">)</span> 
<span class="p">{</span> 
    <span class="c1">// Retrieve the system error message for the last-error code</span>

    <span class="n">LPVOID</span> <span class="n">lpMsgBuf</span><span class="p">;</span>
    <span class="n">LPVOID</span> <span class="n">lpDisplayBuf</span><span class="p">;</span>
    <span class="n">DWORD</span> <span class="n">dw</span> <span class="o">=</span> <span class="n">GetLastError</span><span class="p">();</span> 

    <span class="n">FormatMessage</span><span class="p">(</span>
        <span class="n">FORMAT_MESSAGE_ALLOCATE_BUFFER</span> <span class="o">|</span> 
        <span class="n">FORMAT_MESSAGE_FROM_SYSTEM</span> <span class="o">|</span>
        <span class="n">FORMAT_MESSAGE_IGNORE_INSERTS</span><span class="p">,</span>
        <span class="nb">NULL</span><span class="p">,</span>
        <span class="n">dw</span><span class="p">,</span>
        <span class="n">MAKELANGID</span><span class="p">(</span><span class="n">LANG_NEUTRAL</span><span class="p">,</span> <span class="n">SUBLANG_DEFAULT</span><span class="p">),</span>
        <span class="p">(</span><span class="n">LPTSTR</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">lpMsgBuf</span><span class="p">,</span>
        <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span> <span class="p">);</span>

    <span class="c1">// Display the error message and exit the process</span>

    <span class="n">lpDisplayBuf</span> <span class="o">=</span> <span class="p">(</span><span class="n">LPVOID</span><span class="p">)</span><span class="n">LocalAlloc</span><span class="p">(</span><span class="n">LMEM_ZEROINIT</span><span class="p">,</span> 
        <span class="p">(</span><span class="n">lstrlen</span><span class="p">((</span><span class="n">LPCTSTR</span><span class="p">)</span><span class="n">lpMsgBuf</span><span class="p">)</span> <span class="o">+</span> <span class="n">lstrlen</span><span class="p">((</span><span class="n">LPCTSTR</span><span class="p">)</span><span class="n">lpszFunction</span><span class="p">)</span> <span class="o">+</span> <span class="mi">40</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">TCHAR</span><span class="p">));</span> 
    <span class="n">StringCchPrintf</span><span class="p">((</span><span class="n">LPTSTR</span><span class="p">)</span><span class="n">lpDisplayBuf</span><span class="p">,</span> 
        <span class="n">LocalSize</span><span class="p">(</span><span class="n">lpDisplayBuf</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">TCHAR</span><span class="p">),</span>
        <span class="n">TEXT</span><span class="p">(</span><span class="s">"%s failed with error %d: %s"</span><span class="p">),</span> 
        <span class="n">lpszFunction</span><span class="p">,</span> <span class="n">dw</span><span class="p">,</span> <span class="n">lpMsgBuf</span><span class="p">);</span> 
    <span class="n">MessageBox</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="p">(</span><span class="n">LPCTSTR</span><span class="p">)</span><span class="n">lpDisplayBuf</span><span class="p">,</span> <span class="n">TEXT</span><span class="p">(</span><span class="s">"Error"</span><span class="p">),</span> <span class="n">MB_OK</span><span class="p">);</span> 

    <span class="n">LocalFree</span><span class="p">(</span><span class="n">lpMsgBuf</span><span class="p">);</span>
    <span class="n">LocalFree</span><span class="p">(</span><span class="n">lpDisplayBuf</span><span class="p">);</span>
    <span class="n">ExitProcess</span><span class="p">(</span><span class="n">dw</span><span class="p">);</span> 
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// Generate an error</span>

    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">GetProcessId</span><span class="p">(</span><span class="nb">NULL</span><span class="p">))</span>
        <span class="n">ErrorExit</span><span class="p">(</span><span class="n">TEXT</span><span class="p">(</span><span class="s">"GetProcessId"</span><span class="p">));</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Podemos fazer algumas alterações e implementá-lo em nosso código, substituiremos primeiramente o <code class="language-plaintext highlighter-rouge">MessaageBox</code> com o erro por um <code class="language-plaintext highlighter-rouge">_printf()</code> e colocaremos uma condição para encerrar o programa no qual escolheremos seu comportamento. A função fica da seguinte forma:</p><div lang="cpp" class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">PrintError</span><span class="p">(</span><span class="n">LPCTSTR</span> <span class="n">lpszFunction</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">exitProcess</span><span class="p">)</span>
<span class="p">{</span>
	<span class="c1">// Retrieve the system error message for the last-error code</span>

	<span class="n">LPVOID</span> <span class="n">lpMsgBuf</span><span class="p">;</span>
	<span class="n">LPVOID</span> <span class="n">lpDisplayBuf</span><span class="p">;</span>
	<span class="n">DWORD</span> <span class="n">dw</span> <span class="o">=</span> <span class="n">GetLastError</span><span class="p">();</span>

	<span class="n">FormatMessage</span><span class="p">(</span>
		<span class="n">FORMAT_MESSAGE_ALLOCATE_BUFFER</span> <span class="o">|</span>
		<span class="n">FORMAT_MESSAGE_FROM_SYSTEM</span> <span class="o">|</span>
		<span class="n">FORMAT_MESSAGE_IGNORE_INSERTS</span><span class="p">,</span>
		<span class="nb">NULL</span><span class="p">,</span>
		<span class="n">dw</span><span class="p">,</span>
		<span class="n">MAKELANGID</span><span class="p">(</span><span class="n">LANG_NEUTRAL</span><span class="p">,</span> <span class="n">SUBLANG_DEFAULT</span><span class="p">),</span>
		<span class="p">(</span><span class="n">LPTSTR</span><span class="p">)</span><span class="o">&amp;</span><span class="n">lpMsgBuf</span><span class="p">,</span>
		<span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="c1">// Display the error message and exit the process</span>

	<span class="n">lpDisplayBuf</span> <span class="o">=</span> <span class="p">(</span><span class="n">LPVOID</span><span class="p">)</span><span class="n">LocalAlloc</span><span class="p">(</span><span class="n">LMEM_ZEROINIT</span><span class="p">,</span>
		<span class="p">(</span><span class="n">lstrlen</span><span class="p">((</span><span class="n">LPCTSTR</span><span class="p">)</span><span class="n">lpMsgBuf</span><span class="p">)</span> <span class="o">+</span> <span class="n">lstrlen</span><span class="p">((</span><span class="n">LPCTSTR</span><span class="p">)</span><span class="n">lpszFunction</span><span class="p">)</span> <span class="o">+</span> <span class="mi">40</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">TCHAR</span><span class="p">));</span>
	<span class="n">StringCchPrintf</span><span class="p">((</span><span class="n">LPTSTR</span><span class="p">)</span><span class="n">lpDisplayBuf</span><span class="p">,</span>
		<span class="n">LocalSize</span><span class="p">(</span><span class="n">lpDisplayBuf</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">TCHAR</span><span class="p">),</span>
		<span class="n">TEXT</span><span class="p">(</span><span class="s">"%s failed with error %d: %s"</span><span class="p">),</span>
		<span class="n">lpszFunction</span><span class="p">,</span> <span class="n">dw</span><span class="p">,</span> <span class="n">lpMsgBuf</span><span class="p">);</span>
	<span class="c1">//MessageBox(NULL, (LPCTSTR)lpDisplayBuf, TEXT("Error"), MB_OK);</span>
	<span class="n">_tprintf</span><span class="p">(</span><span class="n">TEXT</span><span class="p">(</span><span class="s">"Error: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">),</span> <span class="p">(</span><span class="n">LPTSTR</span><span class="p">)</span><span class="n">lpDisplayBuf</span><span class="p">);</span>

	<span class="n">LocalFree</span><span class="p">(</span><span class="n">lpMsgBuf</span><span class="p">);</span>
	<span class="n">LocalFree</span><span class="p">(</span><span class="n">lpDisplayBuf</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">exitProcess</span><span class="p">)</span> <span class="n">ExitProcess</span><span class="p">(</span><span class="n">dw</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Agora podemos invocá-la logo após chamarmos a função <code class="language-plaintext highlighter-rouge">EnableSeDebug()</code>.</p><div lang="cpp" class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">EnableSeDebug</span><span class="p">();</span>
<span class="n">PrintError</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"EnableSeDebug()"</span><span class="p">),</span> <span class="nb">true</span><span class="p">);</span>
</pre></table></code></div></div><p>Quando executamos o programa, podemos ver o motivo da não enumeração dos processos.</p><p><img data-proofer-ignore data-src="/img/posts/Pasted%20image%2020240814164605.png" alt="" /></p><p>Como podemos ver, os privilégios necessários não estão presentes no processo.</p><p>O problema disso, é que, muitas vezes perdemos falhas de <em>misconfiguration</em>, pois, como um processo herda os privilégios de quem o executa, existe a possibilidade de cairmos em um contexto onde nosso acesso tem os privilégios necessários, mesmo não sendo administrador.</p><p>Uma implementação que podemos fazer na função <code class="language-plaintext highlighter-rouge">EnableSeDebug</code>, é a checagem se o <code class="language-plaintext highlighter-rouge">SeDebugPrivilege</code> realmente existe no contexto de execução, antes de tentar habilitá-lo.</p><p>Para extrairmos esta informação de um token, usaremos a função <a href="https://learn.microsoft.com/en-us/windows/win32/api/securitybaseapi/nf-securitybaseapi-gettokeninformation">GetTokenInformation</a> que tem a seguinte sintaxe:</p><div lang="cpp" class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="n">BOOL</span> <span class="nf">GetTokenInformation</span><span class="p">(</span>
  <span class="p">[</span><span class="n">in</span><span class="p">]</span>            <span class="n">HANDLE</span>                  <span class="n">TokenHandle</span><span class="p">,</span>
  <span class="p">[</span><span class="n">in</span><span class="p">]</span>            <span class="n">TOKEN_INFORMATION_CLASS</span> <span class="n">TokenInformationClass</span><span class="p">,</span>
  <span class="p">[</span><span class="n">out</span><span class="p">,</span> <span class="n">optional</span><span class="p">]</span> <span class="n">LPVOID</span>                  <span class="n">TokenInformation</span><span class="p">,</span>
  <span class="p">[</span><span class="n">in</span><span class="p">]</span>            <span class="n">DWORD</span>                   <span class="n">TokenInformationLength</span><span class="p">,</span>
  <span class="p">[</span><span class="n">out</span><span class="p">]</span>           <span class="n">PDWORD</span>                  <span class="n">ReturnLength</span>
<span class="p">);</span>
</pre></table></code></div></div><p>Onde:</p><ul><li><code class="language-plaintext highlighter-rouge">[in] TokenHandle</code> é um <em>handle</em> de um token de acesso para onde as informações serão enviadas, este <em>nadle</em> é criado na função <code class="language-plaintext highlighter-rouge">OpenProcesssToken</code> e deve ter o tipo de acesso <code class="language-plaintext highlighter-rouge">TOKEN_QUERY</code>;<li><code class="language-plaintext highlighter-rouge">[in] TokenInformationClass</code> especifica qual valor queremos extrair da estrutura <a href="https://learn.microsoft.com/en-us/windows/win32/api/winnt/ne-winnt-token_information_class">TOKEN_INFORMATION_CLASS</a>, no nosso caso é o <code class="language-plaintext highlighter-rouge">TokenPrivileges</code> que contém uma estrutura <code class="language-plaintext highlighter-rouge">TOKEN_PRIVILEGES</code> que já conhecemos.</ul><p><img data-proofer-ignore data-src="/img/posts/Pasted%20image%2020240814170415.png" alt="" /></p><ul><li><code class="language-plaintext highlighter-rouge">[out, optional] TokenInformation</code> o ponteiro para um <em>buffer</em> que receberá as informações coletadas, pode ser <code class="language-plaintext highlighter-rouge">NULL</code>, nesse caso, nenhuma informação é retornada (isso é importante para os próximos passos);<li><code class="language-plaintext highlighter-rouge">[in] TokenInformationLength</code> o tamanho em <em>bytes</em> do <em>buffer</em> que receberá as informações, se o <em>buffer</em> for configurado como <code class="language-plaintext highlighter-rouge">NULL</code> este parâmetro precisa ser zero;<li><code class="language-plaintext highlighter-rouge">[out] ReturnLength</code> um ponteiro para uma variável que receberá o tamanho em <em>bytes</em> das informações coletadas;</ul><p>O uso desta função tem uma particularidade, para que ela salve as informações em um <em>buffer</em>, é necessário especificar o tamanho em <em>bytes</em> desse <em>buffer</em>, porém, não sabemos o tamanho da resposta na primeira execução.</p><p>No entanto, como esta função também retorna o tamanho da resposta em <em>bytes</em>, a forma mais simples de resolver este problema, é invocá-la uma vez passando o <em>buffer</em> como <code class="language-plaintext highlighter-rouge">NULL</code> somente para armazenar o tamanho da resposta em uma variável. E, logo após, invocá-la novamente, passando esta variável como tamanho do <em>buffer</em> criado.</p><p>No código teremos:</p><div lang="cpp" class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="n">HANDLE</span> <span class="n">currentProcessHandle</span> <span class="o">=</span> <span class="n">GetCurrentProcess</span><span class="p">();</span>
<span class="n">HANDLE</span> <span class="n">processToken</span><span class="p">;</span>

<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">OpenProcessToken</span><span class="p">(</span><span class="n">currentProcessHandle</span><span class="p">,</span> <span class="n">TOKEN_ADJUST_PRIVILEGES</span> <span class="o">|</span> <span class="n">TOKEN_QUERY</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">processToken</span><span class="p">))</span> <span class="p">{</span>
	<span class="n">PrintError</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"OpenProcessToken()"</span><span class="p">),</span> <span class="nb">true</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// coletando o tamanho da estrutura</span>
<span class="n">DWORD</span> <span class="n">firstStructSize</span><span class="p">;</span>
<span class="n">GetTokenInformation</span><span class="p">(</span><span class="n">processToken</span><span class="p">,</span> <span class="n">TokenPrivileges</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">firstStructSize</span><span class="p">);</span>

<span class="c1">// invocando GetTokenInformation() com todos os parâmetros</span>
<span class="n">DWORD</span> <span class="n">secondStructSize</span><span class="p">;</span> <span class="c1">// variável que receberá o tamanho da resposta na segunda execução</span>
<span class="n">PTOKEN_PRIVILEGES</span> <span class="n">processTokenPriv</span><span class="p">;</span> <span class="c1">// ponteiro para estrutura TOKEN_PRIVILEGES que receberá a resposta</span>

<span class="n">processTokenPriv</span> <span class="o">=</span> <span class="p">(</span><span class="n">PTOKEN_PRIVILEGES</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">firstStructSize</span><span class="p">);</span> <span class="c1">// alocando o buffer</span>

<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">GetTokenInformation</span><span class="p">(</span><span class="n">processToken</span><span class="p">,</span> <span class="n">TokenPrivileges</span><span class="p">,</span> <span class="n">processTokenPriv</span><span class="p">,</span> <span class="n">firstStructSize</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">secondStructSize</span><span class="p">))</span> <span class="p">{</span>
	<span class="n">PrintError</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"GetTokenInformation()"</span><span class="p">),</span> <span class="nb">true</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Com a estrutura <code class="language-plaintext highlighter-rouge">TOKEN_PRIVILEGES</code> completa do token, que contém um <em>array</em> de LUIDs e Atributos, podemos iterar sobre ela, comparando cada LUID com o LUID que extraímos com a função <code class="language-plaintext highlighter-rouge">LookupPrivilegeValue</code>.</p><p>O que temos que ter em mente na comparação feita durante a iteração, é que a <a href="https://learn.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-luid">estrutura LUID</a> separa seu valor em duas partes:</p><div lang="cpp" class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="nc">_LUID</span> <span class="p">{</span>
  <span class="n">DWORD</span> <span class="n">LowPart</span><span class="p">;</span>
  <span class="n">LONG</span>  <span class="n">HighPart</span><span class="p">;</span>
<span class="p">}</span> <span class="n">LUID</span><span class="p">,</span> <span class="o">*</span><span class="n">PLUID</span><span class="p">;</span>
</pre></table></code></div></div><p>Logo, nossa comparação deve ser dividida em duas condições.</p><div lang="cpp" class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="c1">// iterando sobre a estrutura TOKEN_PRIVILEGES</span>
<span class="n">PLUID_AND_ATTRIBUTES</span> <span class="n">luidStruct</span><span class="p">;</span> <span class="c1">// ponteiro para estrutura que receberá cada membro do array na iteração</span>
<span class="kt">bool</span> <span class="n">seDebug</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span> <span class="c1">// variável de controle caso o privilégio exista</span>

<span class="k">for</span> <span class="p">(</span><span class="n">DWORD</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">processTokenPriv</span><span class="o">-&gt;</span><span class="n">PrivilegeCount</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

	<span class="n">luidStruct</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">processTokenPriv</span><span class="o">-&gt;</span><span class="n">Privileges</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">luidStruct</span><span class="o">-&gt;</span><span class="n">Luid</span><span class="p">.</span><span class="n">LowPart</span> <span class="o">==</span> <span class="n">privilegeLuid</span><span class="p">.</span><span class="n">LowPart</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">luidStruct</span><span class="o">-&gt;</span><span class="n">Luid</span><span class="p">.</span><span class="n">HighPart</span> <span class="o">==</span> <span class="n">privilegeLuid</span><span class="p">.</span><span class="n">HighPart</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"[+] SeDebugPrivilege encontrada para habilitar!</span><span class="se">\n\n</span><span class="s">"</span><span class="p">));</span>
		<span class="n">seDebug</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c1">// caso não encontre o SeDebugPrivilege</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">seDebug</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"[-] SeDebugPrivilege nao encontrado</span><span class="se">\n</span><span class="s">Execute com privilegios administrativos para enumerar todos os processos!</span><span class="se">\n\n</span><span class="s">"</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>O código completo fica da seguinte forma:</p><div lang="cpp" class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;Windows.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;tchar.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;WtsApi32.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;sddl.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;strsafe.h&gt;</span><span class="cp">
</span>
<span class="cp">#pragma comment(lib, "wtsapi32")
#pragma comment(lib, "Advapi32")
</span>
<span class="cp">#define MAX_ACCOUNTNAME_LEN 1024
#define MAX_DOMAINNAME_LEN 1024
</span>
<span class="kt">void</span> <span class="nf">PrintError</span><span class="p">(</span><span class="n">LPCTSTR</span> <span class="n">lpszFunction</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">exitProcess</span><span class="p">)</span>
<span class="p">{</span>
	<span class="c1">// Retrieve the system error message for the last-error code</span>

	<span class="n">LPVOID</span> <span class="n">lpMsgBuf</span><span class="p">;</span>
	<span class="n">LPVOID</span> <span class="n">lpDisplayBuf</span><span class="p">;</span>
	<span class="n">DWORD</span> <span class="n">dw</span> <span class="o">=</span> <span class="n">GetLastError</span><span class="p">();</span>

	<span class="n">FormatMessage</span><span class="p">(</span>
		<span class="n">FORMAT_MESSAGE_ALLOCATE_BUFFER</span> <span class="o">|</span>
		<span class="n">FORMAT_MESSAGE_FROM_SYSTEM</span> <span class="o">|</span>
		<span class="n">FORMAT_MESSAGE_IGNORE_INSERTS</span><span class="p">,</span>
		<span class="nb">NULL</span><span class="p">,</span>
		<span class="n">dw</span><span class="p">,</span>
		<span class="n">MAKELANGID</span><span class="p">(</span><span class="n">LANG_NEUTRAL</span><span class="p">,</span> <span class="n">SUBLANG_DEFAULT</span><span class="p">),</span>
		<span class="p">(</span><span class="n">LPTSTR</span><span class="p">)</span><span class="o">&amp;</span><span class="n">lpMsgBuf</span><span class="p">,</span>
		<span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="c1">// Display the error message and exit the process</span>

	<span class="n">lpDisplayBuf</span> <span class="o">=</span> <span class="p">(</span><span class="n">LPVOID</span><span class="p">)</span><span class="n">LocalAlloc</span><span class="p">(</span><span class="n">LMEM_ZEROINIT</span><span class="p">,</span>
		<span class="p">(</span><span class="n">lstrlen</span><span class="p">((</span><span class="n">LPCTSTR</span><span class="p">)</span><span class="n">lpMsgBuf</span><span class="p">)</span> <span class="o">+</span> <span class="n">lstrlen</span><span class="p">((</span><span class="n">LPCTSTR</span><span class="p">)</span><span class="n">lpszFunction</span><span class="p">)</span> <span class="o">+</span> <span class="mi">40</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">TCHAR</span><span class="p">));</span>
	<span class="n">StringCchPrintf</span><span class="p">((</span><span class="n">LPTSTR</span><span class="p">)</span><span class="n">lpDisplayBuf</span><span class="p">,</span>
		<span class="n">LocalSize</span><span class="p">(</span><span class="n">lpDisplayBuf</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">TCHAR</span><span class="p">),</span>
		<span class="n">TEXT</span><span class="p">(</span><span class="s">"%s failed with error %d: %s"</span><span class="p">),</span>
		<span class="n">lpszFunction</span><span class="p">,</span> <span class="n">dw</span><span class="p">,</span> <span class="n">lpMsgBuf</span><span class="p">);</span>
	<span class="c1">//MessageBox(NULL, (LPCTSTR)lpDisplayBuf, TEXT("Error"), MB_OK);</span>
	<span class="n">_tprintf</span><span class="p">(</span><span class="n">TEXT</span><span class="p">(</span><span class="s">"Erro: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">),</span> <span class="p">(</span><span class="n">LPTSTR</span><span class="p">)</span><span class="n">lpDisplayBuf</span><span class="p">);</span>

	<span class="n">LocalFree</span><span class="p">(</span><span class="n">lpMsgBuf</span><span class="p">);</span>
	<span class="n">LocalFree</span><span class="p">(</span><span class="n">lpDisplayBuf</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">exitProcess</span><span class="p">)</span> <span class="n">ExitProcess</span><span class="p">(</span><span class="n">dw</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// função para habilitar SeDebugPrivilege</span>
<span class="n">BOOL</span> <span class="nf">EnableSeDebug</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>

	<span class="n">LUID</span> <span class="n">privilegeLuid</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">LookupPrivilegeValue</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">_T</span><span class="p">(</span><span class="s">"SeDebugPrivilege"</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">privilegeLuid</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">PrintError</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"LookupPrivilegeValue()"</span><span class="p">),</span> <span class="nb">true</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="c1">// criando a estrutura do token</span>
	<span class="n">TOKEN_PRIVILEGES</span> <span class="n">tkPrivs</span><span class="p">;</span>

	<span class="n">tkPrivs</span><span class="p">.</span><span class="n">PrivilegeCount</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// quantidade de privilégios a serem configurados</span>
	<span class="n">tkPrivs</span><span class="p">.</span><span class="n">Privileges</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">Luid</span> <span class="o">=</span> <span class="n">privilegeLuid</span><span class="p">;</span> <span class="c1">// LUID do primeiro e único privilégio (SeDebugPrivilege)</span>
	<span class="n">tkPrivs</span><span class="p">.</span><span class="n">Privileges</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">Attributes</span> <span class="o">=</span> <span class="n">SE_PRIVILEGE_ENABLED</span><span class="p">;</span> <span class="c1">// atributo que o privilégio receberá</span>

	<span class="n">HANDLE</span> <span class="n">currentProcessHandle</span> <span class="o">=</span> <span class="n">GetCurrentProcess</span><span class="p">();</span>
	<span class="n">HANDLE</span> <span class="n">processToken</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">OpenProcessToken</span><span class="p">(</span><span class="n">currentProcessHandle</span><span class="p">,</span> <span class="n">TOKEN_ADJUST_PRIVILEGES</span> <span class="o">|</span> <span class="n">TOKEN_QUERY</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">processToken</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">PrintError</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"OpenProcessToken()"</span><span class="p">),</span> <span class="nb">true</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="c1">// coletando o tamanho da estrutura</span>
	<span class="n">DWORD</span> <span class="n">firstStructSize</span><span class="p">;</span>
	<span class="n">GetTokenInformation</span><span class="p">(</span><span class="n">processToken</span><span class="p">,</span> <span class="n">TokenPrivileges</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">firstStructSize</span><span class="p">);</span>

	<span class="c1">// invocando GetTokenInformation() com todos os parâmetros</span>
	<span class="n">DWORD</span> <span class="n">secondStructSize</span><span class="p">;</span> <span class="c1">// variável que receberá o tamanho da resposta na segunda execução</span>
	<span class="n">PTOKEN_PRIVILEGES</span> <span class="n">processTokenPriv</span><span class="p">;</span> <span class="c1">// ponteiro para estrutura TOKEN_PRIVILEGES que receberá a resposta</span>

	<span class="n">processTokenPriv</span> <span class="o">=</span> <span class="p">(</span><span class="n">PTOKEN_PRIVILEGES</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">firstStructSize</span><span class="p">);</span> <span class="c1">// alocando o buffer</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">GetTokenInformation</span><span class="p">(</span><span class="n">processToken</span><span class="p">,</span> <span class="n">TokenPrivileges</span><span class="p">,</span> <span class="n">processTokenPriv</span><span class="p">,</span> <span class="n">firstStructSize</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">secondStructSize</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">PrintError</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"GetTokenInformation()"</span><span class="p">),</span> <span class="nb">true</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="c1">// iterando sobre a estrutura TOKEN_PRIVILEGES</span>
	<span class="n">PLUID_AND_ATTRIBUTES</span> <span class="n">luidStruct</span><span class="p">;</span> <span class="c1">// ponteiro para estrutura que receberá cada membro do array na iteração</span>
	<span class="kt">bool</span> <span class="n">seDebug</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span> <span class="c1">// variável de controle caso o privilégio exista</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">DWORD</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">processTokenPriv</span><span class="o">-&gt;</span><span class="n">PrivilegeCount</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">luidStruct</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">processTokenPriv</span><span class="o">-&gt;</span><span class="n">Privileges</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">luidStruct</span><span class="o">-&gt;</span><span class="n">Luid</span><span class="p">.</span><span class="n">LowPart</span> <span class="o">==</span> <span class="n">privilegeLuid</span><span class="p">.</span><span class="n">LowPart</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">luidStruct</span><span class="o">-&gt;</span><span class="n">Luid</span><span class="p">.</span><span class="n">HighPart</span> <span class="o">==</span> <span class="n">privilegeLuid</span><span class="p">.</span><span class="n">HighPart</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"[+] SeDebugPrivilege encontrada para habilitar!</span><span class="se">\n\n</span><span class="s">"</span><span class="p">));</span>
			<span class="n">seDebug</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// caso não encontre o SeDebugPrivilege</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">seDebug</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"[-] SeDebugPrivilege nao encontrado</span><span class="se">\n</span><span class="s">Execute com privilegios administrativos para enumerar todos os processos!</span><span class="se">\n\n</span><span class="s">"</span><span class="p">));</span>
		<span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">AdjustTokenPrivileges</span><span class="p">(</span><span class="n">processToken</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tkPrivs</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">PrintError</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"AdjustTokenPrivileges()"</span><span class="p">),</span> <span class="nb">true</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">TRUE</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>

	<span class="n">EnableSeDebug</span><span class="p">();</span>

	<span class="n">DWORD</span> <span class="n">level</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// variável que indica o tipo da estrutura PWTS_PROCESS_INFO_EX</span>
	<span class="n">PWTS_PROCESS_INFO_EX</span> <span class="n">processes</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="c1">// variável que contém uma estrutura PWTS_PROCESS_INFO_EX vazia</span>
	<span class="n">DWORD</span> <span class="n">processCounter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// variável que conterá a quantidade de estruturas enumeradas</span>

	<span class="c1">// enumerando os processos</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">WTSEnumerateProcessesEx</span><span class="p">(</span>
		<span class="n">WTS_CURRENT_SERVER_HANDLE</span><span class="p">,</span>
		<span class="o">&amp;</span><span class="n">level</span><span class="p">,</span>
		<span class="n">WTS_ANY_SESSION</span><span class="p">,</span>
		<span class="p">(</span><span class="n">LPTSTR</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">processes</span><span class="p">,</span>
		<span class="o">&amp;</span><span class="n">processCounter</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="c1">// imprimindo dados das estruturas</span>
	<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"Processos encontrados: %d</span><span class="se">\n\n</span><span class="s">"</span><span class="p">),</span> <span class="n">processCounter</span><span class="p">);</span>
	<span class="n">LPTSTR</span> <span class="n">stringSID</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="c1">// ponteiro do tipo string que receberá o SID do usuário que executa o processo</span>
	<span class="n">PWTS_PROCESS_INFO_EX</span> <span class="n">processesPtr</span> <span class="o">=</span> <span class="n">processes</span><span class="p">;</span>

	<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"#</span><span class="se">\t</span><span class="s">PID</span><span class="se">\t</span><span class="s">Handles</span><span class="se">\t</span><span class="s">Threads</span><span class="se">\t</span><span class="s">Process Name</span><span class="se">\t</span><span class="s">SID</span><span class="se">\t</span><span class="s">Account</span><span class="se">\n\n</span><span class="s">"</span><span class="p">));</span>

	<span class="c1">// iterando sobre as estruturas</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">DWORD</span> <span class="n">counter</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">counter</span> <span class="o">&lt;=</span> <span class="n">processCounter</span><span class="p">;</span> <span class="n">counter</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"%d</span><span class="se">\t</span><span class="s">"</span><span class="p">),</span> <span class="n">counter</span><span class="p">);</span>
		<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"%d</span><span class="se">\t</span><span class="s">"</span><span class="p">),</span> <span class="n">processes</span><span class="o">-&gt;</span><span class="n">ProcessId</span><span class="p">);</span>
		<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"%d</span><span class="se">\t</span><span class="s">"</span><span class="p">),</span> <span class="n">processes</span><span class="o">-&gt;</span><span class="n">HandleCount</span><span class="p">);</span>
		<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"%d</span><span class="se">\t</span><span class="s">"</span><span class="p">),</span> <span class="n">processes</span><span class="o">-&gt;</span><span class="n">NumberOfThreads</span><span class="p">);</span>
		<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"%s</span><span class="se">\t</span><span class="s">"</span><span class="p">),</span> <span class="n">processes</span><span class="o">-&gt;</span><span class="n">pProcessName</span><span class="p">);</span>

		<span class="c1">// convertendo o SID para string</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ConvertSidToStringSid</span><span class="p">(</span><span class="n">processes</span><span class="o">-&gt;</span><span class="n">pUserSid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">stringSID</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"-</span><span class="se">\t</span><span class="s">"</span><span class="p">));</span> <span class="c1">// imprime um traço, caso não consiga converter ou obter o SID</span>
		<span class="p">}</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"%s</span><span class="se">\t</span><span class="s">"</span><span class="p">),</span> <span class="n">stringSID</span><span class="p">);</span>
			<span class="n">LocalFree</span><span class="p">((</span><span class="n">HLOCAL</span><span class="p">)</span><span class="n">stringSID</span><span class="p">);</span> <span class="c1">// libera a memória do ponteiro após seu uso</span>
		<span class="p">}</span>

		<span class="n">TCHAR</span> <span class="n">accountName</span><span class="p">[</span><span class="n">MAX_ACCOUNTNAME_LEN</span><span class="p">];</span>
		<span class="n">DWORD</span> <span class="n">accountNameBuffer</span> <span class="o">=</span> <span class="n">MAX_ACCOUNTNAME_LEN</span><span class="p">;</span>
		<span class="n">TCHAR</span> <span class="n">domainName</span><span class="p">[</span><span class="n">MAX_DOMAINNAME_LEN</span><span class="p">];</span>
		<span class="n">DWORD</span> <span class="n">domainNameBuffer</span> <span class="o">=</span> <span class="n">MAX_DOMAINNAME_LEN</span><span class="p">;</span>
		<span class="n">SID_NAME_USE</span> <span class="n">peUse</span><span class="p">;</span>

		<span class="c1">// procura dados da conta através do SID</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">LookupAccountSid</span><span class="p">(</span>
			<span class="nb">NULL</span><span class="p">,</span>
			<span class="n">processes</span><span class="o">-&gt;</span><span class="n">pUserSid</span><span class="p">,</span>
			<span class="n">accountName</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">accountNameBuffer</span><span class="p">,</span>
			<span class="n">domainName</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">domainNameBuffer</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">peUse</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">));</span>
		<span class="p">}</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"%s</span><span class="se">\\</span><span class="s">%s</span><span class="se">\n</span><span class="s">"</span><span class="p">),</span> <span class="n">domainName</span><span class="p">,</span> <span class="n">accountName</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">processes</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="c1">// liberando a memória da estrutura após o uso</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">WTSFreeMemoryEx</span><span class="p">(</span><span class="n">WTSTypeProcessInfoLevel1</span><span class="p">,</span> <span class="n">processesPtr</span><span class="p">,</span> <span class="n">processCounter</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">processes</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"</span><span class="se">\n\n</span><span class="s">Pressione qualquer tecla para finalizar()</span><span class="se">\n</span><span class="s">"</span><span class="p">));</span>

	<span class="n">getchar</span><span class="p">();</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Quando executamos o programa com privilégios de usuário, temos a mensagem do <code class="language-plaintext highlighter-rouge">SeDebugPrivilege</code> não encontrado e os processos enumerados conforme possível.</p><p><img data-proofer-ignore data-src="/img/posts/Pasted%20image%2020240814190142.png" alt="" /></p><p>Já quando executamos com privilégios administrativos (ou em um caso real onde o usuário tem tais permissões), temos a mensagem positiva e os processos enumerados.</p><p><img data-proofer-ignore data-src="/img/posts/Pasted%20image%2020240814190250.png" alt="" /></p><h2 id="requisitando-elevação">Requisitando Elevação</h2><p>Uma vez que conseguimos descobrir se o usuário que executa o programa tem privilégios necessários, e, caso não tenha sabemos que precisamos executá-lo com privilégios, é possível fazer com que o próprio programa solicite execução como Administrador.</p><p>Obviamente, esta requisição irá ativar o UAC (<em>User Account Control</em>) que por sua vez solicitará ao usuário a permissão para executar como administrador, porém existem infinitas formas de se aproveitar disso, uma vez que o <em>malware</em> pode ser executado por uma vítima que acredita na integridade do programa.</p><p>O processo é basicamente simples, seguindo o fluxo do que foi feito até o momento, o programa é lançado, checa se os privilégios existem no token, caso não, ele simplesmente vai se “relançar” solicitando privilégios de administrador.</p><p>Para isso, usaremos a função <a href="https://learn.microsoft.com/en-us/windows/win32/api/shellapi/nf-shellapi-shellexecuteexa">ShellExecuteEx</a> que tem como objetivo efetuar uma operação em determinado arquivo. Sua sintaxe é simples, e contém um único parâmetro.</p><div lang="cpp" class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">BOOL</span> <span class="nf">ShellExecuteExA</span><span class="p">(</span>
  <span class="p">[</span><span class="n">in</span><span class="p">,</span> <span class="n">out</span><span class="p">]</span> <span class="n">SHELLEXECUTEINFOA</span> <span class="o">*</span><span class="n">pExecInfo</span>
<span class="p">);</span>
</pre></table></code></div></div><p>Este parâmetro é um ponteiro para uma estrutura <a href="https://learn.microsoft.com/en-us/windows/win32/api/shellapi/ns-shellapi-shellexecuteinfoa">SHELLEXECUTEINFO</a> que contém e também irá receber informações sobre a aplicação executada.</p><p>Esta estrutura contém várias informações:</p><div lang="cpp" class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="nc">_SHELLEXECUTEINFOA</span> <span class="p">{</span>
  <span class="n">DWORD</span>     <span class="n">cbSize</span><span class="p">;</span>
  <span class="n">ULONG</span>     <span class="n">fMask</span><span class="p">;</span>
  <span class="n">HWND</span>      <span class="n">hwnd</span><span class="p">;</span>
  <span class="n">LPCSTR</span>    <span class="n">lpVerb</span><span class="p">;</span>
  <span class="n">LPCSTR</span>    <span class="n">lpFile</span><span class="p">;</span>
  <span class="n">LPCSTR</span>    <span class="n">lpParameters</span><span class="p">;</span>
  <span class="n">LPCSTR</span>    <span class="n">lpDirectory</span><span class="p">;</span>
  <span class="kt">int</span>       <span class="n">nShow</span><span class="p">;</span>
  <span class="n">HINSTANCE</span> <span class="n">hInstApp</span><span class="p">;</span>
  <span class="kt">void</span>      <span class="o">*</span><span class="n">lpIDList</span><span class="p">;</span>
  <span class="n">LPCSTR</span>    <span class="n">lpClass</span><span class="p">;</span>
  <span class="n">HKEY</span>      <span class="n">hkeyClass</span><span class="p">;</span>
  <span class="n">DWORD</span>     <span class="n">dwHotKey</span><span class="p">;</span>
  <span class="k">union</span> <span class="p">{</span>
    <span class="n">HANDLE</span> <span class="n">hIcon</span><span class="p">;</span>
    <span class="n">HANDLE</span> <span class="n">hMonitor</span><span class="p">;</span>
  <span class="p">}</span> <span class="n">DUMMYUNIONNAME</span><span class="p">;</span>
  <span class="n">HANDLE</span>    <span class="n">hProcess</span><span class="p">;</span>
<span class="p">}</span> <span class="n">SHELLEXECUTEINFOA</span><span class="p">,</span> <span class="o">*</span><span class="n">LPSHELLEXECUTEINFOA</span><span class="p">;</span>
</pre></table></code></div></div><p>Não serão todos os parâmetros a ser usados no processo, porém alguns são obrigatórios e outros necessários:</p><ul><li><code class="language-plaintext highlighter-rouge">cbSize</code> deve conter o tamanho em <em>bytes</em> da própria estrutura, necessário para sua inicialização;<li><code class="language-plaintext highlighter-rouge">fMask</code> contém um parâmetro que valida outras estruturas caso sejam utilizadas, em nosso caso não será necessário e pode ser setado para <code class="language-plaintext highlighter-rouge">SEE_MASK_DEFAULT</code>;<li><code class="language-plaintext highlighter-rouge">lpVerb</code> uma <em>string</em> que especifica a ação a ser tomada, e é essa a variável mais importante neste processo, pois, entre a lista de ações que ela aceita, temos a <code class="language-plaintext highlighter-rouge">runas</code> que executa uma aplicação como Administrador;</ul><p><img data-proofer-ignore data-src="/img/posts/Pasted%20image%2020240814203034.png" alt="" /></p><ul><li><code class="language-plaintext highlighter-rouge">lpFile</code> uma <em>string</em> que contém o <em>path</em> do programa a ser executado, como podemos não ter o controle de onde o programa será armazenado, podemos usar a função <a href="https://learn.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-getmodulefilenamea">GetModuleFileName</a> para obter o <em>path</em> do processo atual; esta função exige um ponteiro para um <em>buffer</em> onde o <em>path</em> será armazenado e o tamanho deste <em>buffer</em> em <em>bytes</em>;<li><code class="language-plaintext highlighter-rouge">lpParameters</code> um ponteiro para uma variável que contenha parâmetros de execução da aplicação; se não houver parâmetros, deve ser setado como <code class="language-plaintext highlighter-rouge">NULL</code>;<li><code class="language-plaintext highlighter-rouge">lpDirectory</code> o ponteiro para uma variável que contenha o diretório de trabalho da aplicação; se for setado como <code class="language-plaintext highlighter-rouge">NULL</code> a função considera o diretório de execução;<li><code class="language-plaintext highlighter-rouge">nShow</code> a <em>flag</em> que especifica como a aplicação será exibida, segue a mesma tabela da função <a href="https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-showwindow">ShowWindow</a>, em nosso caso usaremos <code class="language-plaintext highlighter-rouge">SW_SHOWNORMAL</code>.</ul><p>Podemos então criar uma função que conterá este fluxo:</p><div lang="cpp" class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">Relaunch</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>

	<span class="n">SHELLEXECUTEINFO</span> <span class="n">execInfo</span><span class="p">;</span>
	<span class="n">WCHAR</span> <span class="n">filePath</span><span class="p">[</span><span class="n">MAXFILEPATHLEN</span><span class="p">];</span>
	<span class="n">DWORD</span> <span class="n">filePathLen</span> <span class="o">=</span> <span class="n">MAXFILEPATHLEN</span><span class="p">;</span>

	<span class="c1">// coletando o path do programa</span>
	<span class="n">GetModuleFileName</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">filePath</span><span class="p">,</span> <span class="n">filePathLen</span><span class="p">);</span>

	<span class="c1">// preenchendo a estrutura SHELLEXECUTEINFO</span>
	<span class="n">execInfo</span><span class="p">.</span><span class="n">cbSize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">SHELLEXECUTEINFO</span><span class="p">);</span>
	<span class="n">execInfo</span><span class="p">.</span><span class="n">fMask</span> <span class="o">=</span> <span class="n">SEE_MASK_DEFAULT</span><span class="p">;</span>
	<span class="n">execInfo</span><span class="p">.</span><span class="n">lpVerb</span> <span class="o">=</span> <span class="n">_T</span><span class="p">(</span><span class="s">"runas"</span><span class="p">);</span>
	<span class="n">execInfo</span><span class="p">.</span><span class="n">lpFile</span> <span class="o">=</span> <span class="n">filePath</span><span class="p">;</span>
	<span class="n">execInfo</span><span class="p">.</span><span class="n">lpParameters</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">execInfo</span><span class="p">.</span><span class="n">lpDirectory</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">execInfo</span><span class="p">.</span><span class="n">nShow</span> <span class="o">=</span> <span class="n">SW_SHOWNORMAL</span><span class="p">;</span>

	<span class="n">ShellExecuteEx</span><span class="p">(</span><span class="o">&amp;</span><span class="n">execInfo</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>E em nossa função <code class="language-plaintext highlighter-rouge">main</code> quando invocamos a <code class="language-plaintext highlighter-rouge">EnableSeDebug</code>, podemos criar uma condição onde, caso o privilégio não seja encontrado no reconhecimento inicial, ele invoca a função <code class="language-plaintext highlighter-rouge">Relaunch</code>. A implementação fica da seguinte forma:</p><div lang="cpp" class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;Windows.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;tchar.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;WtsApi32.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;sddl.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;strsafe.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;shellapi.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;winnt.h&gt;</span><span class="cp">
</span>
<span class="cp">#pragma comment(lib, "wtsapi32")
#pragma comment(lib, "Advapi32")
</span>
<span class="cp">#define MAX_ACCOUNTNAME_LEN 1024
#define MAX_DOMAINNAME_LEN 1024
#define	MAXFILEPATHLEN	5000
</span>
<span class="kt">void</span> <span class="nf">Relaunch</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>

	<span class="n">SHELLEXECUTEINFO</span> <span class="n">execInfo</span><span class="p">;</span>
	<span class="n">WCHAR</span> <span class="n">filePath</span><span class="p">[</span><span class="n">MAXFILEPATHLEN</span><span class="p">];</span>
	<span class="n">DWORD</span> <span class="n">filePathLen</span> <span class="o">=</span> <span class="n">MAXFILEPATHLEN</span><span class="p">;</span>

	<span class="c1">// coletando o path do programa</span>
	<span class="n">GetModuleFileName</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">filePath</span><span class="p">,</span> <span class="n">filePathLen</span><span class="p">);</span>

	<span class="c1">// preenchendo a estrutura SHELLEXECUTEINFO</span>
	<span class="n">execInfo</span><span class="p">.</span><span class="n">cbSize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">SHELLEXECUTEINFO</span><span class="p">);</span>
	<span class="n">execInfo</span><span class="p">.</span><span class="n">fMask</span> <span class="o">=</span> <span class="n">SEE_MASK_DEFAULT</span><span class="p">;</span>
	<span class="n">execInfo</span><span class="p">.</span><span class="n">lpVerb</span> <span class="o">=</span> <span class="n">_T</span><span class="p">(</span><span class="s">"runas"</span><span class="p">);</span>
	<span class="n">execInfo</span><span class="p">.</span><span class="n">lpFile</span> <span class="o">=</span> <span class="n">filePath</span><span class="p">;</span>
	<span class="n">execInfo</span><span class="p">.</span><span class="n">lpParameters</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">execInfo</span><span class="p">.</span><span class="n">lpDirectory</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">execInfo</span><span class="p">.</span><span class="n">nShow</span> <span class="o">=</span> <span class="n">SW_SHOWNORMAL</span><span class="p">;</span>

	<span class="n">ShellExecuteEx</span><span class="p">(</span><span class="o">&amp;</span><span class="n">execInfo</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">PrintError</span><span class="p">(</span><span class="n">LPCTSTR</span> <span class="n">lpszFunction</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">exitProcess</span><span class="p">)</span>
<span class="p">{</span>
	<span class="c1">// Retrieve the system error message for the last-error code</span>

	<span class="n">LPVOID</span> <span class="n">lpMsgBuf</span><span class="p">;</span>
	<span class="n">LPVOID</span> <span class="n">lpDisplayBuf</span><span class="p">;</span>
	<span class="n">DWORD</span> <span class="n">dw</span> <span class="o">=</span> <span class="n">GetLastError</span><span class="p">();</span>

	<span class="n">FormatMessage</span><span class="p">(</span>
		<span class="n">FORMAT_MESSAGE_ALLOCATE_BUFFER</span> <span class="o">|</span>
		<span class="n">FORMAT_MESSAGE_FROM_SYSTEM</span> <span class="o">|</span>
		<span class="n">FORMAT_MESSAGE_IGNORE_INSERTS</span><span class="p">,</span>
		<span class="nb">NULL</span><span class="p">,</span>
		<span class="n">dw</span><span class="p">,</span>
		<span class="n">MAKELANGID</span><span class="p">(</span><span class="n">LANG_NEUTRAL</span><span class="p">,</span> <span class="n">SUBLANG_DEFAULT</span><span class="p">),</span>
		<span class="p">(</span><span class="n">LPTSTR</span><span class="p">)</span><span class="o">&amp;</span><span class="n">lpMsgBuf</span><span class="p">,</span>
		<span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="c1">// Display the error message and exit the process</span>

	<span class="n">lpDisplayBuf</span> <span class="o">=</span> <span class="p">(</span><span class="n">LPVOID</span><span class="p">)</span><span class="n">LocalAlloc</span><span class="p">(</span><span class="n">LMEM_ZEROINIT</span><span class="p">,</span>
		<span class="p">(</span><span class="n">lstrlen</span><span class="p">((</span><span class="n">LPCTSTR</span><span class="p">)</span><span class="n">lpMsgBuf</span><span class="p">)</span> <span class="o">+</span> <span class="n">lstrlen</span><span class="p">((</span><span class="n">LPCTSTR</span><span class="p">)</span><span class="n">lpszFunction</span><span class="p">)</span> <span class="o">+</span> <span class="mi">40</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">TCHAR</span><span class="p">));</span>
	<span class="n">StringCchPrintf</span><span class="p">((</span><span class="n">LPTSTR</span><span class="p">)</span><span class="n">lpDisplayBuf</span><span class="p">,</span>
		<span class="n">LocalSize</span><span class="p">(</span><span class="n">lpDisplayBuf</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">TCHAR</span><span class="p">),</span>
		<span class="n">TEXT</span><span class="p">(</span><span class="s">"%s failed with error %d: %s"</span><span class="p">),</span>
		<span class="n">lpszFunction</span><span class="p">,</span> <span class="n">dw</span><span class="p">,</span> <span class="n">lpMsgBuf</span><span class="p">);</span>
	<span class="c1">//MessageBox(NULL, (LPCTSTR)lpDisplayBuf, TEXT("Error"), MB_OK);</span>
	<span class="n">_tprintf</span><span class="p">(</span><span class="n">TEXT</span><span class="p">(</span><span class="s">"Erro: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">),</span> <span class="p">(</span><span class="n">LPTSTR</span><span class="p">)</span><span class="n">lpDisplayBuf</span><span class="p">);</span>

	<span class="n">LocalFree</span><span class="p">(</span><span class="n">lpMsgBuf</span><span class="p">);</span>
	<span class="n">LocalFree</span><span class="p">(</span><span class="n">lpDisplayBuf</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">exitProcess</span><span class="p">)</span> <span class="n">ExitProcess</span><span class="p">(</span><span class="n">dw</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// função para habilitar SeDebugPrivilege</span>
<span class="n">BOOL</span> <span class="nf">EnableSeDebug</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>

	<span class="n">LUID</span> <span class="n">privilegeLuid</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">LookupPrivilegeValue</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">_T</span><span class="p">(</span><span class="s">"SeDebugPrivilege"</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">privilegeLuid</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">PrintError</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"LookupPrivilegeValue()"</span><span class="p">),</span> <span class="nb">true</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="c1">// criando a estrutura do token</span>
	<span class="n">TOKEN_PRIVILEGES</span> <span class="n">tkPrivs</span><span class="p">;</span>

	<span class="n">tkPrivs</span><span class="p">.</span><span class="n">PrivilegeCount</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// quantidade de privilégios a serem configurados</span>
	<span class="n">tkPrivs</span><span class="p">.</span><span class="n">Privileges</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">Luid</span> <span class="o">=</span> <span class="n">privilegeLuid</span><span class="p">;</span> <span class="c1">// LUID do primeiro e único privilégio (SeDebugPrivilege)</span>
	<span class="n">tkPrivs</span><span class="p">.</span><span class="n">Privileges</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">Attributes</span> <span class="o">=</span> <span class="n">SE_PRIVILEGE_ENABLED</span><span class="p">;</span> <span class="c1">// atributo que o privilégio receberá</span>

	<span class="n">HANDLE</span> <span class="n">currentProcessHandle</span> <span class="o">=</span> <span class="n">GetCurrentProcess</span><span class="p">();</span>
	<span class="n">HANDLE</span> <span class="n">processToken</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">OpenProcessToken</span><span class="p">(</span><span class="n">currentProcessHandle</span><span class="p">,</span> <span class="n">TOKEN_ADJUST_PRIVILEGES</span> <span class="o">|</span> <span class="n">TOKEN_QUERY</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">processToken</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">PrintError</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"OpenProcessToken()"</span><span class="p">),</span> <span class="nb">true</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="c1">// coletando o tamanho da estrutura</span>
	<span class="n">DWORD</span> <span class="n">firstStructSize</span><span class="p">;</span>
	<span class="n">GetTokenInformation</span><span class="p">(</span><span class="n">processToken</span><span class="p">,</span> <span class="n">TokenPrivileges</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">firstStructSize</span><span class="p">);</span>

	<span class="c1">// invocando GetTokenInformation() com todos os parâmetros</span>
	<span class="n">DWORD</span> <span class="n">secondStructSize</span><span class="p">;</span> <span class="c1">// variável que receberá o tamanho da resposta na segunda execução</span>
	<span class="n">PTOKEN_PRIVILEGES</span> <span class="n">processTokenPriv</span><span class="p">;</span> <span class="c1">// ponteiro para estrutura TOKEN_PRIVILEGES que receberá a resposta</span>

	<span class="n">processTokenPriv</span> <span class="o">=</span> <span class="p">(</span><span class="n">PTOKEN_PRIVILEGES</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">firstStructSize</span><span class="p">);</span> <span class="c1">// alocando o buffer</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">GetTokenInformation</span><span class="p">(</span><span class="n">processToken</span><span class="p">,</span> <span class="n">TokenPrivileges</span><span class="p">,</span> <span class="n">processTokenPriv</span><span class="p">,</span> <span class="n">firstStructSize</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">secondStructSize</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">PrintError</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"GetTokenInformation()"</span><span class="p">),</span> <span class="nb">true</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="c1">// iterando sobre a estrutura TOKEN_PRIVILEGES</span>
	<span class="n">PLUID_AND_ATTRIBUTES</span> <span class="n">luidStruct</span><span class="p">;</span> <span class="c1">// ponteiro para estrutura que receberá cada membro do array na iteração</span>
	<span class="kt">bool</span> <span class="n">seDebug</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span> <span class="c1">// variável de controle caso o privilégio exista</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">DWORD</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">processTokenPriv</span><span class="o">-&gt;</span><span class="n">PrivilegeCount</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">luidStruct</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">processTokenPriv</span><span class="o">-&gt;</span><span class="n">Privileges</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">luidStruct</span><span class="o">-&gt;</span><span class="n">Luid</span><span class="p">.</span><span class="n">LowPart</span> <span class="o">==</span> <span class="n">privilegeLuid</span><span class="p">.</span><span class="n">LowPart</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">luidStruct</span><span class="o">-&gt;</span><span class="n">Luid</span><span class="p">.</span><span class="n">HighPart</span> <span class="o">==</span> <span class="n">privilegeLuid</span><span class="p">.</span><span class="n">HighPart</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"[+] SeDebugPrivilege encontrada para habilitar!</span><span class="se">\n\n</span><span class="s">"</span><span class="p">));</span>
			<span class="n">seDebug</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// caso não encontre o SeDebugPrivilege</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">seDebug</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"[-] SeDebugPrivilege nao encontrado</span><span class="se">\n</span><span class="s">Executando com privilegios administrativos!</span><span class="se">\n\n</span><span class="s">"</span><span class="p">));</span>
		<span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">AdjustTokenPrivileges</span><span class="p">(</span><span class="n">processToken</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tkPrivs</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">PrintError</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"AdjustTokenPrivileges()"</span><span class="p">),</span> <span class="nb">true</span><span class="p">);</span>
	<span class="p">}</span>



	<span class="k">return</span> <span class="n">TRUE</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">EnableSeDebug</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">Relaunch</span><span class="p">();</span>
		<span class="n">ExitProcess</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"Adicionando privilegio de debug!</span><span class="se">\n\n</span><span class="s">"</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="n">DWORD</span> <span class="n">level</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// variável que indica o tipo da estrutura PWTS_PROCESS_INFO_EX</span>
	<span class="n">PWTS_PROCESS_INFO_EX</span> <span class="n">processes</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="c1">// variável que contém uma estrutura PWTS_PROCESS_INFO_EX vazia</span>
	<span class="n">DWORD</span> <span class="n">processCounter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// variável que conterá a quantidade de estruturas enumeradas</span>

	<span class="c1">// enumerando os processos</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">WTSEnumerateProcessesEx</span><span class="p">(</span>
		<span class="n">WTS_CURRENT_SERVER_HANDLE</span><span class="p">,</span>
		<span class="o">&amp;</span><span class="n">level</span><span class="p">,</span>
		<span class="n">WTS_ANY_SESSION</span><span class="p">,</span>
		<span class="p">(</span><span class="n">LPTSTR</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">processes</span><span class="p">,</span>
		<span class="o">&amp;</span><span class="n">processCounter</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="c1">// imprimindo dados das estruturas</span>
	<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"Processos encontrados: %d</span><span class="se">\n\n</span><span class="s">"</span><span class="p">),</span> <span class="n">processCounter</span><span class="p">);</span>
	<span class="n">LPTSTR</span> <span class="n">stringSID</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="c1">// ponteiro do tipo string que receberá o SID do usuário que executa o processo</span>
	<span class="n">PWTS_PROCESS_INFO_EX</span> <span class="n">processesPtr</span> <span class="o">=</span> <span class="n">processes</span><span class="p">;</span>

	<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"#</span><span class="se">\t</span><span class="s">PID</span><span class="se">\t</span><span class="s">Handles</span><span class="se">\t</span><span class="s">Threads</span><span class="se">\t</span><span class="s">Process Name</span><span class="se">\t</span><span class="s">SID</span><span class="se">\t</span><span class="s">Account</span><span class="se">\n\n</span><span class="s">"</span><span class="p">));</span>

	<span class="c1">// iterando sobre as estruturas</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">DWORD</span> <span class="n">counter</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">counter</span> <span class="o">&lt;=</span> <span class="n">processCounter</span><span class="p">;</span> <span class="n">counter</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"%d</span><span class="se">\t</span><span class="s">"</span><span class="p">),</span> <span class="n">counter</span><span class="p">);</span>
		<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"%d</span><span class="se">\t</span><span class="s">"</span><span class="p">),</span> <span class="n">processes</span><span class="o">-&gt;</span><span class="n">ProcessId</span><span class="p">);</span>
		<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"%d</span><span class="se">\t</span><span class="s">"</span><span class="p">),</span> <span class="n">processes</span><span class="o">-&gt;</span><span class="n">HandleCount</span><span class="p">);</span>
		<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"%d</span><span class="se">\t</span><span class="s">"</span><span class="p">),</span> <span class="n">processes</span><span class="o">-&gt;</span><span class="n">NumberOfThreads</span><span class="p">);</span>
		<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"%s</span><span class="se">\t</span><span class="s">"</span><span class="p">),</span> <span class="n">processes</span><span class="o">-&gt;</span><span class="n">pProcessName</span><span class="p">);</span>

		<span class="c1">// convertendo o SID para string</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ConvertSidToStringSid</span><span class="p">(</span><span class="n">processes</span><span class="o">-&gt;</span><span class="n">pUserSid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">stringSID</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"-</span><span class="se">\t</span><span class="s">"</span><span class="p">));</span> <span class="c1">// imprime um traço, caso não consiga converter ou obter o SID</span>
		<span class="p">}</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"%s</span><span class="se">\t</span><span class="s">"</span><span class="p">),</span> <span class="n">stringSID</span><span class="p">);</span>
			<span class="n">LocalFree</span><span class="p">((</span><span class="n">HLOCAL</span><span class="p">)</span><span class="n">stringSID</span><span class="p">);</span> <span class="c1">// libera a memória do ponteiro após seu uso</span>
		<span class="p">}</span>

		<span class="n">TCHAR</span> <span class="n">accountName</span><span class="p">[</span><span class="n">MAX_ACCOUNTNAME_LEN</span><span class="p">];</span>
		<span class="n">DWORD</span> <span class="n">accountNameBuffer</span> <span class="o">=</span> <span class="n">MAX_ACCOUNTNAME_LEN</span><span class="p">;</span>
		<span class="n">TCHAR</span> <span class="n">domainName</span><span class="p">[</span><span class="n">MAX_DOMAINNAME_LEN</span><span class="p">];</span>
		<span class="n">DWORD</span> <span class="n">domainNameBuffer</span> <span class="o">=</span> <span class="n">MAX_DOMAINNAME_LEN</span><span class="p">;</span>
		<span class="n">SID_NAME_USE</span> <span class="n">peUse</span><span class="p">;</span>

		<span class="c1">// procura dados da conta através do SID</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">LookupAccountSid</span><span class="p">(</span>
			<span class="nb">NULL</span><span class="p">,</span>
			<span class="n">processes</span><span class="o">-&gt;</span><span class="n">pUserSid</span><span class="p">,</span>
			<span class="n">accountName</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">accountNameBuffer</span><span class="p">,</span>
			<span class="n">domainName</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">domainNameBuffer</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">peUse</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">));</span>
		<span class="p">}</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"%s</span><span class="se">\\</span><span class="s">%s</span><span class="se">\n</span><span class="s">"</span><span class="p">),</span> <span class="n">domainName</span><span class="p">,</span> <span class="n">accountName</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">processes</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="c1">// liberando a memória da estrutura após o uso</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">WTSFreeMemoryEx</span><span class="p">(</span><span class="n">WTSTypeProcessInfoLevel1</span><span class="p">,</span> <span class="n">processesPtr</span><span class="p">,</span> <span class="n">processCounter</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">processes</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"</span><span class="se">\n\n</span><span class="s">Pressione qualquer tecla para finalizar()</span><span class="se">\n</span><span class="s">"</span><span class="p">));</span>

	<span class="n">getchar</span><span class="p">();</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Quando executamos o programa com usuário comum, temos a mensagem de aviso:</p><p><img data-proofer-ignore data-src="/img/posts/Pasted%20image%2020240814211408.png" alt="" /></p><p>Logo em seguida, o UAC é acionado:</p><p><img data-proofer-ignore data-src="/img/posts/Pasted%20image%2020240814211434.png" alt="" /></p><p>Quando a execução é aceita, temos a enumeração completa dos processos.</p><p><img data-proofer-ignore data-src="/img/posts/Pasted%20image%2020240814211518.png" alt="" /></p><h2 id="token-dumper"><em>Token Dumper</em></h2><p>Com tudo apresentado até o momento, já é níitido que as informações que podemos obter dos tokens de acesso são tão, se não mais, valiosas quanto as informações dos processos.</p><p>Quando implementamos a função <code class="language-plaintext highlighter-rouge">EnableSeDebug</code> para habilitar o privilégio <code class="language-plaintext highlighter-rouge">SeDebugPrivilege</code>, vimos que, ao usar a função <code class="language-plaintext highlighter-rouge">GetTokenInformation</code> precisamos informar o valor que queremos obter da classe <code class="language-plaintext highlighter-rouge">TOKEN_INFORMATION_CLASS</code>.</p><p>Uma simples observada nesta classe nos mostra a quantidade de informações que podemos extrair a partir dela:</p><div lang="cpp" class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
</pre><td class="rouge-code"><pre><span class="k">typedef</span> <span class="k">enum</span> <span class="n">_TOKEN_INFORMATION_CLASS</span> <span class="p">{</span>
  <span class="n">TokenUser</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
  <span class="n">TokenGroups</span><span class="p">,</span>
  <span class="n">TokenPrivileges</span><span class="p">,</span>
  <span class="n">TokenOwner</span><span class="p">,</span>
  <span class="n">TokenPrimaryGroup</span><span class="p">,</span>
  <span class="n">TokenDefaultDacl</span><span class="p">,</span>
  <span class="n">TokenSource</span><span class="p">,</span>
  <span class="n">TokenType</span><span class="p">,</span>
  <span class="n">TokenImpersonationLevel</span><span class="p">,</span>
  <span class="n">TokenStatistics</span><span class="p">,</span>
  <span class="n">TokenRestrictedSids</span><span class="p">,</span>
  <span class="n">TokenSessionId</span><span class="p">,</span>
  <span class="n">TokenGroupsAndPrivileges</span><span class="p">,</span>
  <span class="n">TokenSessionReference</span><span class="p">,</span>
  <span class="n">TokenSandBoxInert</span><span class="p">,</span>
  <span class="n">TokenAuditPolicy</span><span class="p">,</span>
  <span class="n">TokenOrigin</span><span class="p">,</span>
  <span class="n">TokenElevationType</span><span class="p">,</span>
  <span class="n">TokenLinkedToken</span><span class="p">,</span>
  <span class="n">TokenElevation</span><span class="p">,</span>
  <span class="n">TokenHasRestrictions</span><span class="p">,</span>
  <span class="n">TokenAccessInformation</span><span class="p">,</span>
  <span class="n">TokenVirtualizationAllowed</span><span class="p">,</span>
  <span class="n">TokenVirtualizationEnabled</span><span class="p">,</span>
  <span class="n">TokenIntegrityLevel</span><span class="p">,</span>
  <span class="n">TokenUIAccess</span><span class="p">,</span>
  <span class="n">TokenMandatoryPolicy</span><span class="p">,</span>
  <span class="n">TokenLogonSid</span><span class="p">,</span>
  <span class="n">TokenIsAppContainer</span><span class="p">,</span>
  <span class="n">TokenCapabilities</span><span class="p">,</span>
  <span class="n">TokenAppContainerSid</span><span class="p">,</span>
  <span class="n">TokenAppContainerNumber</span><span class="p">,</span>
  <span class="n">TokenUserClaimAttributes</span><span class="p">,</span>
  <span class="n">TokenDeviceClaimAttributes</span><span class="p">,</span>
  <span class="n">TokenRestrictedUserClaimAttributes</span><span class="p">,</span>
  <span class="n">TokenRestrictedDeviceClaimAttributes</span><span class="p">,</span>
  <span class="n">TokenDeviceGroups</span><span class="p">,</span>
  <span class="n">TokenRestrictedDeviceGroups</span><span class="p">,</span>
  <span class="n">TokenSecurityAttributes</span><span class="p">,</span>
  <span class="n">TokenIsRestricted</span><span class="p">,</span>
  <span class="n">TokenProcessTrustLevel</span><span class="p">,</span>
  <span class="n">TokenPrivateNameSpace</span><span class="p">,</span>
  <span class="n">TokenSingletonAttributes</span><span class="p">,</span>
  <span class="n">TokenBnoIsolation</span><span class="p">,</span>
  <span class="n">TokenChildProcessFlags</span><span class="p">,</span>
  <span class="n">TokenIsLessPrivilegedAppContainer</span><span class="p">,</span>
  <span class="n">TokenIsSandboxed</span><span class="p">,</span>
  <span class="n">TokenIsAppSilo</span><span class="p">,</span>
  <span class="n">TokenLoggingInformation</span><span class="p">,</span>
  <span class="n">MaxTokenInfoClass</span>
<span class="p">}</span> <span class="n">TOKEN_INFORMATION_CLASS</span><span class="p">,</span> <span class="o">*</span><span class="n">PTOKEN_INFORMATION_CLASS</span><span class="p">;</span>
</pre></table></code></div></div><p>Cada membro desta classe tem um formato, alguns são inteiros, outros <em>strings</em>, <em>arrays</em>, estruturas, etc. Para cada um que queremos obter, um tratamento específico deve ser feito.</p><p>Para deixar nosso programa de <em>process listing</em> mais completo possível, após a enumeração dos processos em execução, podemos solicitar o PID de um processo específico e enumerar várias informações relevantes do seu token.</p><p>Como vimos anteriormente, temos que criar um <em>handle</em> para o token passando o tipo de permissão que queremos, que no caso foi <code class="language-plaintext highlighter-rouge">MAXIMUM_ALLOWED</code>. Também vimos que precisamos de um <em>handle</em> para o processo do qual queremos extrair o token, no caso feito até o momento, utilizamos a função <code class="language-plaintext highlighter-rouge">GetCurrentProcess</code>, pois estávamos extraindo o token do pŕoprio programa.</p><p>Para criar um <em>handle</em> de outro processo em execução, podemos usar a função <code class="language-plaintext highlighter-rouge">OpenProcess</code> bastante utilizada nos artigos anteriores dessa série.</p><p>Basicamente, a implementação no código para solicitar o PID, criar um <em>handle</em> para um processo baseado no PID e em seguida criar um <em>handle</em> para o token do processo é:</p><div lang="cpp" class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="c1">// ********************************** inicio do dump do token</span>
<span class="kt">int</span> <span class="n">pid</span><span class="p">;</span>

<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"</span><span class="se">\n\n</span><span class="s">Fazer o dump do token para qual PID?: "</span><span class="p">));</span>
<span class="n">scanf_s</span><span class="p">(</span><span class="s">"%d[^</span><span class="se">\n</span><span class="s">]"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pid</span><span class="p">);</span>
<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">[+] Fazendo dump do token para o PID: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">),</span> <span class="n">pid</span><span class="p">);</span>

<span class="c1">// criando um handle para o processo do qual extrairemos o token</span>
<span class="n">HANDLE</span> <span class="n">processHandle</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="p">(</span><span class="n">processHandle</span> <span class="o">=</span> <span class="n">OpenProcess</span><span class="p">(</span><span class="n">MAXIMUM_ALLOWED</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="n">pid</span><span class="p">)))</span> <span class="p">{</span>

	<span class="n">PrintError</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"OpenProcess()"</span><span class="p">),</span> <span class="nb">false</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// criando um handle para o token</span>
<span class="n">HANDLE</span> <span class="n">processToken</span><span class="p">;</span>

<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">OpenProcessToken</span><span class="p">(</span><span class="n">processHandle</span><span class="p">,</span> <span class="n">MAXIMUM_ALLOWED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">processToken</span><span class="p">))</span> <span class="p">{</span>

	<span class="n">PrintError</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"OpenProcessToken()"</span><span class="p">),</span> <span class="nb">false</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Com o <em>handle</em> dp token em mãos, podemos utilizar a função <code class="language-plaintext highlighter-rouge">GetTokenInformation</code> para coletar qualquer informação listada na classe <code class="language-plaintext highlighter-rouge">TOKEN_INFORMATION_CLASS</code>.</p><p>Neste ponto existe algo a se considerar: existem muitas informações nessa classe, algumas mais relevantes que outras, a depender do contexto de enumeração e exploração. Para fins deste artigo, decidi enumerar as seguintes informações:</p><ul><li><code class="language-plaintext highlighter-rouge">TokenOwner</code><li><code class="language-plaintext highlighter-rouge">TokenUser</code><li><code class="language-plaintext highlighter-rouge">TokenPrimaryGroup</code><li><code class="language-plaintext highlighter-rouge">TokenGroups</code><li><code class="language-plaintext highlighter-rouge">TokenPrivileges</code><li><code class="language-plaintext highlighter-rouge">TokenSource</code><li><code class="language-plaintext highlighter-rouge">TokenType</code><li><code class="language-plaintext highlighter-rouge">TokenElevation</code></ul><p>Para cada um destes membros da classe, temos um tipo, portanto foi criada uma função para o <em>parsing</em> de cada uma, as funções ficaram da seguinte forma:</p><div lang="cpp" class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">GetTokenOwner</span><span class="p">(</span><span class="n">HANDLE</span> <span class="n">processToken</span><span class="p">)</span> <span class="p">{</span>

	<span class="n">DWORD</span> <span class="n">infoLen</span> <span class="o">=</span> <span class="n">GetTokenInfoLen</span><span class="p">(</span><span class="n">processToken</span><span class="p">,</span> <span class="n">TokenOwner</span><span class="p">);</span>
	<span class="n">DWORD</span> <span class="n">structLen</span><span class="p">;</span>

	<span class="n">PTOKEN_OWNER</span> <span class="n">tokenInfo</span> <span class="o">=</span> <span class="p">(</span><span class="n">PTOKEN_OWNER</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">infoLen</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">GetTokenInformation</span><span class="p">(</span><span class="n">processToken</span><span class="p">,</span> <span class="n">TokenOwner</span><span class="p">,</span> <span class="p">(</span><span class="n">LPVOID</span><span class="p">)</span><span class="n">tokenInfo</span><span class="p">,</span> <span class="n">infoLen</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">structLen</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">PrintError</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"GetTokenInformation()"</span><span class="p">),</span> <span class="nb">false</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"************************ TOKEN OWNER: </span><span class="se">\n</span><span class="s">"</span><span class="p">));</span>
	<span class="n">PrintSidInfo</span><span class="p">(</span><span class="n">tokenInfo</span><span class="o">-&gt;</span><span class="n">Owner</span><span class="p">);</span>

	<span class="n">free</span><span class="p">(</span><span class="n">tokenInfo</span><span class="p">);</span>


<span class="p">}</span>

<span class="kt">void</span> <span class="nf">GetTokenUser</span><span class="p">(</span><span class="n">HANDLE</span> <span class="n">processToken</span><span class="p">)</span> <span class="p">{</span>

	<span class="n">DWORD</span> <span class="n">infoLen</span> <span class="o">=</span> <span class="n">GetTokenInfoLen</span><span class="p">(</span><span class="n">processToken</span><span class="p">,</span> <span class="n">TokenUser</span><span class="p">);</span>
	<span class="n">DWORD</span> <span class="n">structLen</span><span class="p">;</span>

	<span class="n">PTOKEN_USER</span> <span class="n">tokenInfo</span> <span class="o">=</span> <span class="p">(</span><span class="n">PTOKEN_USER</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">infoLen</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">GetTokenInformation</span><span class="p">(</span><span class="n">processToken</span><span class="p">,</span> <span class="n">TokenUser</span><span class="p">,</span> <span class="p">(</span><span class="n">LPVOID</span><span class="p">)</span><span class="n">tokenInfo</span><span class="p">,</span> <span class="n">infoLen</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">structLen</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">PrintError</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"GetTokenInformation()"</span><span class="p">),</span> <span class="nb">false</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"************************ TOKEN USER: </span><span class="se">\n</span><span class="s">"</span><span class="p">));</span>
	<span class="n">PrintSidInfo</span><span class="p">(</span><span class="n">tokenInfo</span><span class="o">-&gt;</span><span class="n">User</span><span class="p">.</span><span class="n">Sid</span><span class="p">);</span>

	<span class="n">free</span><span class="p">(</span><span class="n">tokenInfo</span><span class="p">);</span>


<span class="p">}</span>

<span class="kt">void</span> <span class="nf">GetTokenPrimaryGroup</span><span class="p">(</span><span class="n">HANDLE</span> <span class="n">processToken</span><span class="p">)</span> <span class="p">{</span>

	<span class="n">DWORD</span> <span class="n">infoLen</span> <span class="o">=</span> <span class="n">GetTokenInfoLen</span><span class="p">(</span><span class="n">processToken</span><span class="p">,</span> <span class="n">TokenPrimaryGroup</span><span class="p">);</span>
	<span class="n">DWORD</span> <span class="n">structLen</span><span class="p">;</span>

	<span class="n">PTOKEN_PRIMARY_GROUP</span> <span class="n">tokenInfo</span> <span class="o">=</span> <span class="p">(</span><span class="n">PTOKEN_PRIMARY_GROUP</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">infoLen</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">GetTokenInformation</span><span class="p">(</span><span class="n">processToken</span><span class="p">,</span> <span class="n">TokenPrimaryGroup</span><span class="p">,</span> <span class="p">(</span><span class="n">LPVOID</span><span class="p">)</span><span class="n">tokenInfo</span><span class="p">,</span> <span class="n">infoLen</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">structLen</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">PrintError</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"GetTokenInformation()"</span><span class="p">),</span> <span class="nb">false</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"************************ TOKEN PRIMARY GROUP: </span><span class="se">\n</span><span class="s">"</span><span class="p">));</span>
	<span class="n">PrintSidInfo</span><span class="p">(</span><span class="n">tokenInfo</span><span class="o">-&gt;</span><span class="n">PrimaryGroup</span><span class="p">);</span>

	<span class="n">free</span><span class="p">(</span><span class="n">tokenInfo</span><span class="p">);</span>


<span class="p">}</span>

<span class="kt">void</span> <span class="nf">GetTokenGroups</span><span class="p">(</span><span class="n">HANDLE</span> <span class="n">processToken</span><span class="p">)</span> <span class="p">{</span>

	<span class="n">DWORD</span> <span class="n">infoLen</span> <span class="o">=</span> <span class="n">GetTokenInfoLen</span><span class="p">(</span><span class="n">processToken</span><span class="p">,</span> <span class="n">TokenGroups</span><span class="p">);</span>
	<span class="n">DWORD</span> <span class="n">structLen</span><span class="p">;</span>

	<span class="n">PTOKEN_GROUPS</span> <span class="n">tokenInfo</span> <span class="o">=</span> <span class="p">(</span><span class="n">PTOKEN_GROUPS</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">infoLen</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">GetTokenInformation</span><span class="p">(</span><span class="n">processToken</span><span class="p">,</span> <span class="n">TokenGroups</span><span class="p">,</span> <span class="p">(</span><span class="n">LPVOID</span><span class="p">)</span><span class="n">tokenInfo</span><span class="p">,</span> <span class="n">infoLen</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">structLen</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">PrintError</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"GetTokenInformation()"</span><span class="p">),</span> <span class="nb">false</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"************************ TOKEN GROUPS: </span><span class="se">\n</span><span class="s">"</span><span class="p">));</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">DWORD</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">tokenInfo</span><span class="o">-&gt;</span><span class="n">GroupCount</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">PrintSidInfo</span><span class="p">(</span><span class="n">tokenInfo</span><span class="o">-&gt;</span><span class="n">Groups</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">Sid</span><span class="p">);</span>
	<span class="p">}</span>
	

	<span class="n">free</span><span class="p">(</span><span class="n">tokenInfo</span><span class="p">);</span>


<span class="p">}</span>

<span class="kt">void</span> <span class="nf">GetTokenPrivileges</span><span class="p">(</span><span class="n">HANDLE</span> <span class="n">processToken</span><span class="p">)</span> <span class="p">{</span>

	<span class="n">DWORD</span> <span class="n">infoLen</span> <span class="o">=</span> <span class="n">GetTokenInfoLen</span><span class="p">(</span><span class="n">processToken</span><span class="p">,</span> <span class="n">TokenPrivileges</span><span class="p">);</span>
	<span class="n">DWORD</span> <span class="n">structLen</span><span class="p">;</span>

	<span class="n">PTOKEN_PRIVILEGES</span> <span class="n">tokenInfo</span> <span class="o">=</span> <span class="p">(</span><span class="n">PTOKEN_PRIVILEGES</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">infoLen</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">GetTokenInformation</span><span class="p">(</span><span class="n">processToken</span><span class="p">,</span> <span class="n">TokenPrivileges</span><span class="p">,</span> <span class="p">(</span><span class="n">LPVOID</span><span class="p">)</span><span class="n">tokenInfo</span><span class="p">,</span> <span class="n">infoLen</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">structLen</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">PrintError</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"GetTokenInformation()"</span><span class="p">),</span> <span class="nb">false</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">TCHAR</span> <span class="n">privName</span><span class="p">[</span><span class="n">MAX_PRIV_LEN</span><span class="p">];</span>
	<span class="n">DWORD</span> <span class="n">privNameSize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">privName</span><span class="p">);</span>

	<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"************************ TOKEN PRIVILEGES: </span><span class="se">\n</span><span class="s">"</span><span class="p">));</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">DWORD</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">tokenInfo</span><span class="o">-&gt;</span><span class="n">PrivilegeCount</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">privNameSize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">privName</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">LookupPrivilegeName</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tokenInfo</span><span class="o">-&gt;</span><span class="n">Privileges</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">Luid</span><span class="p">,</span> <span class="n">privName</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">privNameSize</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">PrintError</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"LookupPrivilegeName()"</span><span class="p">),</span> <span class="nb">false</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">tokenInfo</span><span class="o">-&gt;</span><span class="n">Privileges</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">Attributes</span> <span class="o">&amp;</span> <span class="n">SE_PRIVILEGE_ENABLED</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"%3d. Enabled        %s</span><span class="se">\n</span><span class="s">"</span><span class="p">),</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">privName</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">else</span> <span class="p">{</span>
				<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"%3d. Disabled       %s</span><span class="se">\n</span><span class="s">"</span><span class="p">),</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">privName</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">));</span>

	<span class="n">free</span><span class="p">(</span><span class="n">tokenInfo</span><span class="p">);</span>


<span class="p">}</span>

<span class="kt">void</span> <span class="nf">GetTokenSource</span><span class="p">(</span><span class="n">HANDLE</span> <span class="n">processToken</span><span class="p">)</span> <span class="p">{</span>

	<span class="n">DWORD</span> <span class="n">structLen</span><span class="p">;</span>

	<span class="n">PTOKEN_SOURCE</span> <span class="n">tokenInfo</span> <span class="o">=</span> <span class="p">(</span><span class="n">PTOKEN_SOURCE</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">TOKEN_SOURCE</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">GetTokenInformation</span><span class="p">(</span><span class="n">processToken</span><span class="p">,</span> <span class="n">TokenSource</span><span class="p">,</span> <span class="p">(</span><span class="n">LPVOID</span><span class="p">)</span><span class="n">tokenInfo</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">TOKEN_SOURCE</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">structLen</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">PrintError</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"GetTokenInformation()"</span><span class="p">),</span> <span class="nb">false</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"************************ TOKEN SOURCE: </span><span class="se">\n</span><span class="s">"</span><span class="p">));</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">DWORD</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">tokenInfo</span><span class="o">-&gt;</span><span class="n">SourceName</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"%c"</span><span class="p">),</span> <span class="n">tokenInfo</span><span class="o">-&gt;</span><span class="n">SourceName</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"</span><span class="se">\n\n</span><span class="s">"</span><span class="p">));</span>

	<span class="n">free</span><span class="p">(</span><span class="n">tokenInfo</span><span class="p">);</span>


<span class="p">}</span>

<span class="kt">void</span> <span class="nf">GetTokenType</span><span class="p">(</span><span class="n">HANDLE</span> <span class="n">processToken</span><span class="p">)</span> <span class="p">{</span>

	<span class="n">DWORD</span> <span class="n">structLen</span><span class="p">;</span>

	<span class="n">PTOKEN_TYPE</span> <span class="n">tokenInfo</span> <span class="o">=</span> <span class="p">(</span><span class="n">PTOKEN_TYPE</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">PTOKEN_TYPE</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">GetTokenInformation</span><span class="p">(</span><span class="n">processToken</span><span class="p">,</span> <span class="n">TokenType</span><span class="p">,</span> <span class="p">(</span><span class="n">LPVOID</span><span class="p">)</span><span class="n">tokenInfo</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">PTOKEN_TYPE</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">structLen</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">PrintError</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"GetTokenInformation()"</span><span class="p">),</span> <span class="nb">false</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"************************ TOKEN TYPE: </span><span class="se">\n</span><span class="s">"</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">tokenInfo</span> <span class="o">==</span> <span class="n">TokenPrimary</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"TokenPrimary"</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"TokenImpersonation"</span><span class="p">));</span>

		<span class="c1">// procurando o tipo de impersonation</span>
		<span class="n">PSECURITY_IMPERSONATION_LEVEL</span> <span class="n">tokenImpLevel</span> <span class="o">=</span> <span class="p">(</span><span class="n">PSECURITY_IMPERSONATION_LEVEL</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">SECURITY_IMPERSONATION_LEVEL</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">GetTokenInformation</span><span class="p">(</span><span class="n">processToken</span><span class="p">,</span> <span class="n">TokenImpersonationLevel</span><span class="p">,</span> <span class="p">(</span><span class="n">LPVOID</span><span class="p">)</span><span class="n">tokenImpLevel</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">TOKEN_TYPE</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">structLen</span><span class="p">))</span> <span class="p">{</span>

			<span class="n">PrintError</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"GetTokenInformation()"</span><span class="p">),</span> <span class="nb">false</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="k">switch</span> <span class="p">(</span><span class="o">*</span><span class="n">tokenImpLevel</span><span class="p">)</span> <span class="p">{</span>

			<span class="k">case</span> <span class="n">SecurityAnonymous</span><span class="p">:</span>
				<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"Impersonation Level: SecurityAnonymous</span><span class="se">\n</span><span class="s">"</span><span class="p">));</span>
					<span class="k">break</span><span class="p">;</span>

			<span class="k">case</span> <span class="n">SecurityIdentification</span><span class="p">:</span>
				<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"Impersonation Level: SecurityIdentification</span><span class="se">\n</span><span class="s">"</span><span class="p">));</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="k">case</span> <span class="n">SecurityImpersonation</span><span class="p">:</span>
				<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"Impersonation Level: SecurityImpersonation</span><span class="se">\n</span><span class="s">"</span><span class="p">));</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="k">case</span> <span class="n">SecurityDelegation</span><span class="p">:</span>
				<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"Impersonation Level: SecurityDelegation</span><span class="se">\n</span><span class="s">"</span><span class="p">));</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"</span><span class="se">\n\n</span><span class="s">"</span><span class="p">));</span>

	<span class="n">free</span><span class="p">(</span><span class="n">tokenInfo</span><span class="p">);</span>


<span class="p">}</span>

<span class="kt">void</span> <span class="nf">GetTokenElevation</span><span class="p">(</span><span class="n">HANDLE</span> <span class="n">processToken</span><span class="p">)</span> <span class="p">{</span>

	<span class="n">DWORD</span> <span class="n">structLen</span><span class="p">;</span>

	<span class="n">PTOKEN_ELEVATION</span> <span class="n">tokenInfo</span> <span class="o">=</span> <span class="p">(</span><span class="n">PTOKEN_ELEVATION</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">TOKEN_ELEVATION</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">GetTokenInformation</span><span class="p">(</span><span class="n">processToken</span><span class="p">,</span> <span class="n">TokenElevation</span><span class="p">,</span> <span class="p">(</span><span class="n">LPVOID</span><span class="p">)</span><span class="n">tokenInfo</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">TOKEN_ELEVATION</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">structLen</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">PrintError</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"GetTokenInformation()"</span><span class="p">),</span> <span class="nb">false</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"************************ TOKEN ELEVATION: </span><span class="se">\n</span><span class="s">"</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tokenInfo</span><span class="o">-&gt;</span><span class="n">TokenIsElevated</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"Token Elevated: TRUE</span><span class="se">\n</span><span class="s">"</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"Token Elevated: FALSE</span><span class="se">\n</span><span class="s">"</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">));</span>

	<span class="n">free</span><span class="p">(</span><span class="n">tokenInfo</span><span class="p">);</span>


<span class="p">}</span>
</pre></table></code></div></div><p>Na função <code class="language-plaintext highlighter-rouge">main</code> do programa, eu invoco cada uma destas funções de <em>parsing</em> passando o <em>handle</em> do token e, ao final, eu fecho os <em>handles</em> abertos.</p><p>Abaixo o código completo:</p><div lang="cpp" class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
237
238
239
240
241
242
243
244
245
246
247
248
249
250
251
252
253
254
255
256
257
258
259
260
261
262
263
264
265
266
267
268
269
270
271
272
273
274
275
276
277
278
279
280
281
282
283
284
285
286
287
288
289
290
291
292
293
294
295
296
297
298
299
300
301
302
303
304
305
306
307
308
309
310
311
312
313
314
315
316
317
318
319
320
321
322
323
324
325
326
327
328
329
330
331
332
333
334
335
336
337
338
339
340
341
342
343
344
345
346
347
348
349
350
351
352
353
354
355
356
357
358
359
360
361
362
363
364
365
366
367
368
369
370
371
372
373
374
375
376
377
378
379
380
381
382
383
384
385
386
387
388
389
390
391
392
393
394
395
396
397
398
399
400
401
402
403
404
405
406
407
408
409
410
411
412
413
414
415
416
417
418
419
420
421
422
423
424
425
426
427
428
429
430
431
432
433
434
435
436
437
438
439
440
441
442
443
444
445
446
447
448
449
450
451
452
453
454
455
456
457
458
459
460
461
462
463
464
465
466
467
468
469
470
471
472
473
474
475
476
477
478
479
480
481
482
483
484
485
486
487
488
489
490
491
492
493
494
495
496
497
498
499
500
501
502
503
504
505
506
507
508
509
510
511
512
513
514
515
516
517
518
519
520
521
522
523
524
525
526
527
528
529
530
531
532
533
534
535
536
537
538
539
540
541
542
543
544
545
546
547
548
549
550
551
552
553
554
555
556
557
558
559
560
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;Windows.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;tchar.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;WtsApi32.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;sddl.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;strsafe.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;shellapi.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;winnt.h&gt;</span><span class="cp">
</span>
<span class="cp">#pragma comment(lib, "wtsapi32")
#pragma comment(lib, "Advapi32")
</span>
<span class="cp">#define MAX_ACCOUNTNAME_LEN 1024
#define MAX_DOMAINNAME_LEN 1024
#define	MAX_FILE_PATH_LEN	5000
#define MAX_PRIV_LEN	5000
</span>
<span class="kt">void</span> <span class="nf">PrintError</span><span class="p">(</span><span class="n">LPCTSTR</span> <span class="n">lpszFunction</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">exitProcess</span><span class="p">)</span>
<span class="p">{</span>
	<span class="c1">// Retrieve the system error message for the last-error code</span>

	<span class="n">LPVOID</span> <span class="n">lpMsgBuf</span><span class="p">;</span>
	<span class="n">LPVOID</span> <span class="n">lpDisplayBuf</span><span class="p">;</span>
	<span class="n">DWORD</span> <span class="n">dw</span> <span class="o">=</span> <span class="n">GetLastError</span><span class="p">();</span>

	<span class="n">FormatMessage</span><span class="p">(</span>
		<span class="n">FORMAT_MESSAGE_ALLOCATE_BUFFER</span> <span class="o">|</span>
		<span class="n">FORMAT_MESSAGE_FROM_SYSTEM</span> <span class="o">|</span>
		<span class="n">FORMAT_MESSAGE_IGNORE_INSERTS</span><span class="p">,</span>
		<span class="nb">NULL</span><span class="p">,</span>
		<span class="n">dw</span><span class="p">,</span>
		<span class="n">MAKELANGID</span><span class="p">(</span><span class="n">LANG_NEUTRAL</span><span class="p">,</span> <span class="n">SUBLANG_DEFAULT</span><span class="p">),</span>
		<span class="p">(</span><span class="n">LPTSTR</span><span class="p">)</span><span class="o">&amp;</span><span class="n">lpMsgBuf</span><span class="p">,</span>
		<span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="c1">// Display the error message and exit the process</span>

	<span class="n">lpDisplayBuf</span> <span class="o">=</span> <span class="p">(</span><span class="n">LPVOID</span><span class="p">)</span><span class="n">LocalAlloc</span><span class="p">(</span><span class="n">LMEM_ZEROINIT</span><span class="p">,</span>
		<span class="p">(</span><span class="n">lstrlen</span><span class="p">((</span><span class="n">LPCTSTR</span><span class="p">)</span><span class="n">lpMsgBuf</span><span class="p">)</span> <span class="o">+</span> <span class="n">lstrlen</span><span class="p">((</span><span class="n">LPCTSTR</span><span class="p">)</span><span class="n">lpszFunction</span><span class="p">)</span> <span class="o">+</span> <span class="mi">40</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">TCHAR</span><span class="p">));</span>
	<span class="n">StringCchPrintf</span><span class="p">((</span><span class="n">LPTSTR</span><span class="p">)</span><span class="n">lpDisplayBuf</span><span class="p">,</span>
		<span class="n">LocalSize</span><span class="p">(</span><span class="n">lpDisplayBuf</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">TCHAR</span><span class="p">),</span>
		<span class="n">TEXT</span><span class="p">(</span><span class="s">"%s failed with error %d: %s"</span><span class="p">),</span>
		<span class="n">lpszFunction</span><span class="p">,</span> <span class="n">dw</span><span class="p">,</span> <span class="n">lpMsgBuf</span><span class="p">);</span>
	<span class="c1">//MessageBox(NULL, (LPCTSTR)lpDisplayBuf, TEXT("Error"), MB_OK);</span>
	<span class="n">_tprintf</span><span class="p">(</span><span class="n">TEXT</span><span class="p">(</span><span class="s">"Erro: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">),</span> <span class="p">(</span><span class="n">LPTSTR</span><span class="p">)</span><span class="n">lpDisplayBuf</span><span class="p">);</span>

	<span class="n">LocalFree</span><span class="p">(</span><span class="n">lpMsgBuf</span><span class="p">);</span>
	<span class="n">LocalFree</span><span class="p">(</span><span class="n">lpDisplayBuf</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">exitProcess</span><span class="p">)</span> <span class="n">ExitProcess</span><span class="p">(</span><span class="n">dw</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// coleta o tamanho da struct</span>
<span class="n">DWORD</span> <span class="nf">GetTokenInfoLen</span><span class="p">(</span><span class="n">HANDLE</span> <span class="n">processToken</span><span class="p">,</span> <span class="n">TOKEN_INFORMATION_CLASS</span> <span class="n">info</span><span class="p">)</span> <span class="p">{</span>

	<span class="n">DWORD</span> <span class="n">structSize</span><span class="p">;</span>

	<span class="n">GetTokenInformation</span><span class="p">(</span><span class="n">processToken</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">structSize</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">structSize</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">SIDType</span><span class="p">(</span><span class="n">SID_NAME_USE</span> <span class="n">type</span><span class="p">)</span> <span class="p">{</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>

	<span class="k">case</span> <span class="n">SidTypeUser</span><span class="p">:</span>

		<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"SID Type: SidTypeUser: SID de usuario.</span><span class="se">\n</span><span class="s">"</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SidTypeGroup</span><span class="p">:</span>
		<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"SID Type: SidTypeGroup: SID de grupo</span><span class="se">\n</span><span class="s">"</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SidTypeDomain</span><span class="p">:</span>
		<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"SID Type: SidTypeDomain: SID de dominio</span><span class="se">\n</span><span class="s">"</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SidTypeAlias</span><span class="p">:</span>
		<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"SID Type: SidTypeAlias: SID alias</span><span class="se">\n</span><span class="s">"</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SidTypeWellKnownGroup</span><span class="p">:</span>
		<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"SID Type: SidTypeWellKnownGroup: SID de grupo well-known</span><span class="se">\n</span><span class="s">"</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SidTypeDeletedAccount</span><span class="p">:</span>
		<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"SID Type: SidTypeDeletedAccount: SID de conta deletada</span><span class="se">\n</span><span class="s">"</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SidTypeInvalid</span><span class="p">:</span>
		<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"SID Type: SidTypeInvalid: SID invalido</span><span class="se">\n</span><span class="s">"</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SidTypeUnknown</span><span class="p">:</span>
		<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"SID Type: SidTypeUnknown: SID nao conhecido</span><span class="se">\n</span><span class="s">"</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SidTypeComputer</span><span class="p">:</span>
		<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"SID Type: SidTypeComputer: SID de computador</span><span class="se">\n</span><span class="s">"</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SidTypeLabel</span><span class="p">:</span>
		<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"SID Type: SidTypeLabel: SID mandatory integrity label</span><span class="se">\n</span><span class="s">"</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">PrintSidInfo</span><span class="p">(</span><span class="n">PSID</span> <span class="n">psid</span><span class="p">)</span> <span class="p">{</span>

	<span class="n">LPTSTR</span> <span class="n">stringSID</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ConvertSidToStringSid</span><span class="p">(</span><span class="n">psid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">stringSID</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">PrintError</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"ConvertSidToStringSid()"</span><span class="p">),</span> <span class="nb">false</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">TCHAR</span> <span class="n">accountName</span><span class="p">[</span><span class="n">MAX_ACCOUNTNAME_LEN</span><span class="p">];</span>
	<span class="n">DWORD</span> <span class="n">accountNameBuffer</span> <span class="o">=</span> <span class="n">MAX_ACCOUNTNAME_LEN</span><span class="p">;</span>
	<span class="n">TCHAR</span> <span class="n">domainName</span><span class="p">[</span><span class="n">MAX_DOMAINNAME_LEN</span><span class="p">];</span>
	<span class="n">DWORD</span> <span class="n">domainNameBuffer</span> <span class="o">=</span> <span class="n">MAX_DOMAINNAME_LEN</span><span class="p">;</span>
	<span class="n">SID_NAME_USE</span> <span class="n">peUse</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">LookupAccountSid</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">psid</span><span class="p">,</span> <span class="n">accountName</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">accountNameBuffer</span><span class="p">,</span> <span class="n">domainName</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">domainNameBuffer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">peUse</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">PrintError</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"LookupAccountSid()"</span><span class="p">),</span> <span class="nb">false</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"SID: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">),</span> <span class="n">stringSID</span><span class="p">);</span>
	<span class="n">SIDType</span><span class="p">(</span><span class="n">peUse</span><span class="p">);</span>
	<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"Conta: %s</span><span class="se">\\</span><span class="s">%s</span><span class="se">\n\n</span><span class="s">"</span><span class="p">),</span> <span class="n">domainName</span><span class="p">,</span> <span class="n">accountName</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">GetTokenOwner</span><span class="p">(</span><span class="n">HANDLE</span> <span class="n">processToken</span><span class="p">)</span> <span class="p">{</span>

	<span class="n">DWORD</span> <span class="n">infoLen</span> <span class="o">=</span> <span class="n">GetTokenInfoLen</span><span class="p">(</span><span class="n">processToken</span><span class="p">,</span> <span class="n">TokenOwner</span><span class="p">);</span>
	<span class="n">DWORD</span> <span class="n">structLen</span><span class="p">;</span>

	<span class="n">PTOKEN_OWNER</span> <span class="n">tokenInfo</span> <span class="o">=</span> <span class="p">(</span><span class="n">PTOKEN_OWNER</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">infoLen</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">GetTokenInformation</span><span class="p">(</span><span class="n">processToken</span><span class="p">,</span> <span class="n">TokenOwner</span><span class="p">,</span> <span class="p">(</span><span class="n">LPVOID</span><span class="p">)</span><span class="n">tokenInfo</span><span class="p">,</span> <span class="n">infoLen</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">structLen</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">PrintError</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"GetTokenInformation()"</span><span class="p">),</span> <span class="nb">false</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"************************ TOKEN OWNER: </span><span class="se">\n</span><span class="s">"</span><span class="p">));</span>
	<span class="n">PrintSidInfo</span><span class="p">(</span><span class="n">tokenInfo</span><span class="o">-&gt;</span><span class="n">Owner</span><span class="p">);</span>

	<span class="n">free</span><span class="p">(</span><span class="n">tokenInfo</span><span class="p">);</span>


<span class="p">}</span>

<span class="kt">void</span> <span class="nf">GetTokenUser</span><span class="p">(</span><span class="n">HANDLE</span> <span class="n">processToken</span><span class="p">)</span> <span class="p">{</span>

	<span class="n">DWORD</span> <span class="n">infoLen</span> <span class="o">=</span> <span class="n">GetTokenInfoLen</span><span class="p">(</span><span class="n">processToken</span><span class="p">,</span> <span class="n">TokenUser</span><span class="p">);</span>
	<span class="n">DWORD</span> <span class="n">structLen</span><span class="p">;</span>

	<span class="n">PTOKEN_USER</span> <span class="n">tokenInfo</span> <span class="o">=</span> <span class="p">(</span><span class="n">PTOKEN_USER</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">infoLen</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">GetTokenInformation</span><span class="p">(</span><span class="n">processToken</span><span class="p">,</span> <span class="n">TokenUser</span><span class="p">,</span> <span class="p">(</span><span class="n">LPVOID</span><span class="p">)</span><span class="n">tokenInfo</span><span class="p">,</span> <span class="n">infoLen</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">structLen</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">PrintError</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"GetTokenInformation()"</span><span class="p">),</span> <span class="nb">false</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"************************ TOKEN USER: </span><span class="se">\n</span><span class="s">"</span><span class="p">));</span>
	<span class="n">PrintSidInfo</span><span class="p">(</span><span class="n">tokenInfo</span><span class="o">-&gt;</span><span class="n">User</span><span class="p">.</span><span class="n">Sid</span><span class="p">);</span>

	<span class="n">free</span><span class="p">(</span><span class="n">tokenInfo</span><span class="p">);</span>


<span class="p">}</span>

<span class="kt">void</span> <span class="nf">GetTokenPrimaryGroup</span><span class="p">(</span><span class="n">HANDLE</span> <span class="n">processToken</span><span class="p">)</span> <span class="p">{</span>

	<span class="n">DWORD</span> <span class="n">infoLen</span> <span class="o">=</span> <span class="n">GetTokenInfoLen</span><span class="p">(</span><span class="n">processToken</span><span class="p">,</span> <span class="n">TokenPrimaryGroup</span><span class="p">);</span>
	<span class="n">DWORD</span> <span class="n">structLen</span><span class="p">;</span>

	<span class="n">PTOKEN_PRIMARY_GROUP</span> <span class="n">tokenInfo</span> <span class="o">=</span> <span class="p">(</span><span class="n">PTOKEN_PRIMARY_GROUP</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">infoLen</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">GetTokenInformation</span><span class="p">(</span><span class="n">processToken</span><span class="p">,</span> <span class="n">TokenPrimaryGroup</span><span class="p">,</span> <span class="p">(</span><span class="n">LPVOID</span><span class="p">)</span><span class="n">tokenInfo</span><span class="p">,</span> <span class="n">infoLen</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">structLen</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">PrintError</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"GetTokenInformation()"</span><span class="p">),</span> <span class="nb">false</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"************************ TOKEN PRIMARY GROUP: </span><span class="se">\n</span><span class="s">"</span><span class="p">));</span>
	<span class="n">PrintSidInfo</span><span class="p">(</span><span class="n">tokenInfo</span><span class="o">-&gt;</span><span class="n">PrimaryGroup</span><span class="p">);</span>

	<span class="n">free</span><span class="p">(</span><span class="n">tokenInfo</span><span class="p">);</span>


<span class="p">}</span>

<span class="kt">void</span> <span class="nf">GetTokenGroups</span><span class="p">(</span><span class="n">HANDLE</span> <span class="n">processToken</span><span class="p">)</span> <span class="p">{</span>

	<span class="n">DWORD</span> <span class="n">infoLen</span> <span class="o">=</span> <span class="n">GetTokenInfoLen</span><span class="p">(</span><span class="n">processToken</span><span class="p">,</span> <span class="n">TokenGroups</span><span class="p">);</span>
	<span class="n">DWORD</span> <span class="n">structLen</span><span class="p">;</span>

	<span class="n">PTOKEN_GROUPS</span> <span class="n">tokenInfo</span> <span class="o">=</span> <span class="p">(</span><span class="n">PTOKEN_GROUPS</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">infoLen</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">GetTokenInformation</span><span class="p">(</span><span class="n">processToken</span><span class="p">,</span> <span class="n">TokenGroups</span><span class="p">,</span> <span class="p">(</span><span class="n">LPVOID</span><span class="p">)</span><span class="n">tokenInfo</span><span class="p">,</span> <span class="n">infoLen</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">structLen</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">PrintError</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"GetTokenInformation()"</span><span class="p">),</span> <span class="nb">false</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"************************ TOKEN GROUPS: </span><span class="se">\n</span><span class="s">"</span><span class="p">));</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">DWORD</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">tokenInfo</span><span class="o">-&gt;</span><span class="n">GroupCount</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">PrintSidInfo</span><span class="p">(</span><span class="n">tokenInfo</span><span class="o">-&gt;</span><span class="n">Groups</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">Sid</span><span class="p">);</span>
	<span class="p">}</span>
	

	<span class="n">free</span><span class="p">(</span><span class="n">tokenInfo</span><span class="p">);</span>


<span class="p">}</span>

<span class="kt">void</span> <span class="nf">GetTokenPrivileges</span><span class="p">(</span><span class="n">HANDLE</span> <span class="n">processToken</span><span class="p">)</span> <span class="p">{</span>

	<span class="n">DWORD</span> <span class="n">infoLen</span> <span class="o">=</span> <span class="n">GetTokenInfoLen</span><span class="p">(</span><span class="n">processToken</span><span class="p">,</span> <span class="n">TokenPrivileges</span><span class="p">);</span>
	<span class="n">DWORD</span> <span class="n">structLen</span><span class="p">;</span>

	<span class="n">PTOKEN_PRIVILEGES</span> <span class="n">tokenInfo</span> <span class="o">=</span> <span class="p">(</span><span class="n">PTOKEN_PRIVILEGES</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">infoLen</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">GetTokenInformation</span><span class="p">(</span><span class="n">processToken</span><span class="p">,</span> <span class="n">TokenPrivileges</span><span class="p">,</span> <span class="p">(</span><span class="n">LPVOID</span><span class="p">)</span><span class="n">tokenInfo</span><span class="p">,</span> <span class="n">infoLen</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">structLen</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">PrintError</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"GetTokenInformation()"</span><span class="p">),</span> <span class="nb">false</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">TCHAR</span> <span class="n">privName</span><span class="p">[</span><span class="n">MAX_PRIV_LEN</span><span class="p">];</span>
	<span class="n">DWORD</span> <span class="n">privNameSize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">privName</span><span class="p">);</span>

	<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"************************ TOKEN PRIVILEGES: </span><span class="se">\n</span><span class="s">"</span><span class="p">));</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">DWORD</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">tokenInfo</span><span class="o">-&gt;</span><span class="n">PrivilegeCount</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">privNameSize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">privName</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">LookupPrivilegeName</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tokenInfo</span><span class="o">-&gt;</span><span class="n">Privileges</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">Luid</span><span class="p">,</span> <span class="n">privName</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">privNameSize</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">PrintError</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"LookupPrivilegeName()"</span><span class="p">),</span> <span class="nb">false</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">tokenInfo</span><span class="o">-&gt;</span><span class="n">Privileges</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">Attributes</span> <span class="o">&amp;</span> <span class="n">SE_PRIVILEGE_ENABLED</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"%3d. Enabled        %s</span><span class="se">\n</span><span class="s">"</span><span class="p">),</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">privName</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">else</span> <span class="p">{</span>
				<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"%3d. Disabled       %s</span><span class="se">\n</span><span class="s">"</span><span class="p">),</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">privName</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">));</span>

	<span class="n">free</span><span class="p">(</span><span class="n">tokenInfo</span><span class="p">);</span>


<span class="p">}</span>

<span class="kt">void</span> <span class="nf">GetTokenSource</span><span class="p">(</span><span class="n">HANDLE</span> <span class="n">processToken</span><span class="p">)</span> <span class="p">{</span>

	<span class="n">DWORD</span> <span class="n">structLen</span><span class="p">;</span>

	<span class="n">PTOKEN_SOURCE</span> <span class="n">tokenInfo</span> <span class="o">=</span> <span class="p">(</span><span class="n">PTOKEN_SOURCE</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">TOKEN_SOURCE</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">GetTokenInformation</span><span class="p">(</span><span class="n">processToken</span><span class="p">,</span> <span class="n">TokenSource</span><span class="p">,</span> <span class="p">(</span><span class="n">LPVOID</span><span class="p">)</span><span class="n">tokenInfo</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">TOKEN_SOURCE</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">structLen</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">PrintError</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"GetTokenInformation()"</span><span class="p">),</span> <span class="nb">false</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"************************ TOKEN SOURCE: </span><span class="se">\n</span><span class="s">"</span><span class="p">));</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">DWORD</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">tokenInfo</span><span class="o">-&gt;</span><span class="n">SourceName</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"%c"</span><span class="p">),</span> <span class="n">tokenInfo</span><span class="o">-&gt;</span><span class="n">SourceName</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"</span><span class="se">\n\n</span><span class="s">"</span><span class="p">));</span>

	<span class="n">free</span><span class="p">(</span><span class="n">tokenInfo</span><span class="p">);</span>


<span class="p">}</span>

<span class="kt">void</span> <span class="nf">GetTokenType</span><span class="p">(</span><span class="n">HANDLE</span> <span class="n">processToken</span><span class="p">)</span> <span class="p">{</span>

	<span class="n">DWORD</span> <span class="n">structLen</span><span class="p">;</span>

	<span class="n">PTOKEN_TYPE</span> <span class="n">tokenInfo</span> <span class="o">=</span> <span class="p">(</span><span class="n">PTOKEN_TYPE</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">PTOKEN_TYPE</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">GetTokenInformation</span><span class="p">(</span><span class="n">processToken</span><span class="p">,</span> <span class="n">TokenType</span><span class="p">,</span> <span class="p">(</span><span class="n">LPVOID</span><span class="p">)</span><span class="n">tokenInfo</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">PTOKEN_TYPE</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">structLen</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">PrintError</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"GetTokenInformation()"</span><span class="p">),</span> <span class="nb">false</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"************************ TOKEN TYPE: </span><span class="se">\n</span><span class="s">"</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">tokenInfo</span> <span class="o">==</span> <span class="n">TokenPrimary</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"TokenPrimary"</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"TokenImpersonation"</span><span class="p">));</span>

		<span class="c1">// procurando o tipo de impersonation</span>
		<span class="n">PSECURITY_IMPERSONATION_LEVEL</span> <span class="n">tokenImpLevel</span> <span class="o">=</span> <span class="p">(</span><span class="n">PSECURITY_IMPERSONATION_LEVEL</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">SECURITY_IMPERSONATION_LEVEL</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">GetTokenInformation</span><span class="p">(</span><span class="n">processToken</span><span class="p">,</span> <span class="n">TokenImpersonationLevel</span><span class="p">,</span> <span class="p">(</span><span class="n">LPVOID</span><span class="p">)</span><span class="n">tokenImpLevel</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">TOKEN_TYPE</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">structLen</span><span class="p">))</span> <span class="p">{</span>

			<span class="n">PrintError</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"GetTokenInformation()"</span><span class="p">),</span> <span class="nb">false</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="k">switch</span> <span class="p">(</span><span class="o">*</span><span class="n">tokenImpLevel</span><span class="p">)</span> <span class="p">{</span>

			<span class="k">case</span> <span class="n">SecurityAnonymous</span><span class="p">:</span>
				<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"Impersonation Level: SecurityAnonymous</span><span class="se">\n</span><span class="s">"</span><span class="p">));</span>
					<span class="k">break</span><span class="p">;</span>

			<span class="k">case</span> <span class="n">SecurityIdentification</span><span class="p">:</span>
				<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"Impersonation Level: SecurityIdentification</span><span class="se">\n</span><span class="s">"</span><span class="p">));</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="k">case</span> <span class="n">SecurityImpersonation</span><span class="p">:</span>
				<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"Impersonation Level: SecurityImpersonation</span><span class="se">\n</span><span class="s">"</span><span class="p">));</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="k">case</span> <span class="n">SecurityDelegation</span><span class="p">:</span>
				<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"Impersonation Level: SecurityDelegation</span><span class="se">\n</span><span class="s">"</span><span class="p">));</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"</span><span class="se">\n\n</span><span class="s">"</span><span class="p">));</span>

	<span class="n">free</span><span class="p">(</span><span class="n">tokenInfo</span><span class="p">);</span>


<span class="p">}</span>

<span class="kt">void</span> <span class="nf">GetTokenElevation</span><span class="p">(</span><span class="n">HANDLE</span> <span class="n">processToken</span><span class="p">)</span> <span class="p">{</span>

	<span class="n">DWORD</span> <span class="n">structLen</span><span class="p">;</span>

	<span class="n">PTOKEN_ELEVATION</span> <span class="n">tokenInfo</span> <span class="o">=</span> <span class="p">(</span><span class="n">PTOKEN_ELEVATION</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">TOKEN_ELEVATION</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">GetTokenInformation</span><span class="p">(</span><span class="n">processToken</span><span class="p">,</span> <span class="n">TokenElevation</span><span class="p">,</span> <span class="p">(</span><span class="n">LPVOID</span><span class="p">)</span><span class="n">tokenInfo</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">TOKEN_ELEVATION</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">structLen</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">PrintError</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"GetTokenInformation()"</span><span class="p">),</span> <span class="nb">false</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"************************ TOKEN ELEVATION: </span><span class="se">\n</span><span class="s">"</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tokenInfo</span><span class="o">-&gt;</span><span class="n">TokenIsElevated</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"Token Elevated: TRUE</span><span class="se">\n</span><span class="s">"</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"Token Elevated: FALSE</span><span class="se">\n</span><span class="s">"</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">));</span>

	<span class="n">free</span><span class="p">(</span><span class="n">tokenInfo</span><span class="p">);</span>


<span class="p">}</span>

<span class="kt">void</span> <span class="nf">Relaunch</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>

	<span class="n">SHELLEXECUTEINFO</span> <span class="n">execInfo</span><span class="p">;</span>
	<span class="n">WCHAR</span> <span class="n">filePath</span><span class="p">[</span><span class="n">MAX_FILE_PATH_LEN</span><span class="p">];</span>
	<span class="n">DWORD</span> <span class="n">filePathLen</span> <span class="o">=</span> <span class="n">MAX_FILE_PATH_LEN</span><span class="p">;</span>

	<span class="c1">// coletando o path do programa</span>
	<span class="n">GetModuleFileName</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">filePath</span><span class="p">,</span> <span class="n">filePathLen</span><span class="p">);</span>

	<span class="c1">// preenchendo a estrutura SHELLEXECUTEINFO</span>
	<span class="n">execInfo</span><span class="p">.</span><span class="n">cbSize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">SHELLEXECUTEINFO</span><span class="p">);</span>
	<span class="n">execInfo</span><span class="p">.</span><span class="n">fMask</span> <span class="o">=</span> <span class="n">SEE_MASK_DEFAULT</span><span class="p">;</span>
	<span class="n">execInfo</span><span class="p">.</span><span class="n">lpVerb</span> <span class="o">=</span> <span class="n">_T</span><span class="p">(</span><span class="s">"runas"</span><span class="p">);</span>
	<span class="n">execInfo</span><span class="p">.</span><span class="n">lpFile</span> <span class="o">=</span> <span class="n">filePath</span><span class="p">;</span>
	<span class="n">execInfo</span><span class="p">.</span><span class="n">lpParameters</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">execInfo</span><span class="p">.</span><span class="n">lpDirectory</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">execInfo</span><span class="p">.</span><span class="n">nShow</span> <span class="o">=</span> <span class="n">SW_SHOWNORMAL</span><span class="p">;</span>

	<span class="n">ShellExecuteEx</span><span class="p">(</span><span class="o">&amp;</span><span class="n">execInfo</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// função para habilitar SeDebugPrivilege</span>
<span class="n">BOOL</span> <span class="nf">EnableSeDebug</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>

	<span class="n">LUID</span> <span class="n">privilegeLuid</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">LookupPrivilegeValue</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">_T</span><span class="p">(</span><span class="s">"SeDebugPrivilege"</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">privilegeLuid</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">PrintError</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"LookupPrivilegeValue()"</span><span class="p">),</span> <span class="nb">true</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="c1">// criando a estrutura do token</span>
	<span class="n">TOKEN_PRIVILEGES</span> <span class="n">tkPrivs</span><span class="p">;</span>

	<span class="n">tkPrivs</span><span class="p">.</span><span class="n">PrivilegeCount</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// quantidade de privilégios a serem configurados</span>
	<span class="n">tkPrivs</span><span class="p">.</span><span class="n">Privileges</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">Luid</span> <span class="o">=</span> <span class="n">privilegeLuid</span><span class="p">;</span> <span class="c1">// LUID do primeiro e único privilégio (SeDebugPrivilege)</span>
	<span class="n">tkPrivs</span><span class="p">.</span><span class="n">Privileges</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">Attributes</span> <span class="o">=</span> <span class="n">SE_PRIVILEGE_ENABLED</span><span class="p">;</span> <span class="c1">// atributo que o privilégio receberá</span>

	<span class="n">HANDLE</span> <span class="n">currentProcessHandle</span> <span class="o">=</span> <span class="n">GetCurrentProcess</span><span class="p">();</span>
	<span class="n">HANDLE</span> <span class="n">processToken</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">OpenProcessToken</span><span class="p">(</span><span class="n">currentProcessHandle</span><span class="p">,</span> <span class="n">TOKEN_ADJUST_PRIVILEGES</span> <span class="o">|</span> <span class="n">TOKEN_QUERY</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">processToken</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">PrintError</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"OpenProcessToken()"</span><span class="p">),</span> <span class="nb">true</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="c1">// coletando o tamanho da estrutura</span>
	<span class="n">DWORD</span> <span class="n">firstStructSize</span> <span class="o">=</span> <span class="n">GetTokenInfoLen</span><span class="p">(</span><span class="n">processToken</span><span class="p">,</span> <span class="n">TokenPrivileges</span><span class="p">);</span>

	<span class="c1">// invocando GetTokenInformation() com todos os parâmetros</span>
	<span class="n">DWORD</span> <span class="n">secondStructSize</span><span class="p">;</span> <span class="c1">// variável que receberá o tamanho da resposta na segunda execução</span>
	<span class="n">PTOKEN_PRIVILEGES</span> <span class="n">processTokenPriv</span><span class="p">;</span> <span class="c1">// ponteiro para estrutura TOKEN_PRIVILEGES que receberá a resposta</span>

	<span class="n">processTokenPriv</span> <span class="o">=</span> <span class="p">(</span><span class="n">PTOKEN_PRIVILEGES</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">firstStructSize</span><span class="p">);</span> <span class="c1">// alocando o buffer</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">GetTokenInformation</span><span class="p">(</span><span class="n">processToken</span><span class="p">,</span> <span class="n">TokenPrivileges</span><span class="p">,</span> <span class="n">processTokenPriv</span><span class="p">,</span> <span class="n">firstStructSize</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">secondStructSize</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">PrintError</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"GetTokenInformation()"</span><span class="p">),</span> <span class="nb">true</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="c1">// iterando sobre a estrutura TOKEN_PRIVILEGES</span>
	<span class="n">PLUID_AND_ATTRIBUTES</span> <span class="n">luidStruct</span><span class="p">;</span> <span class="c1">// ponteiro para estrutura que receberá cada membro do array na iteração</span>
	<span class="kt">bool</span> <span class="n">seDebug</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span> <span class="c1">// variável de controle caso o privilégio exista</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">DWORD</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">processTokenPriv</span><span class="o">-&gt;</span><span class="n">PrivilegeCount</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">luidStruct</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">processTokenPriv</span><span class="o">-&gt;</span><span class="n">Privileges</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">luidStruct</span><span class="o">-&gt;</span><span class="n">Luid</span><span class="p">.</span><span class="n">LowPart</span> <span class="o">==</span> <span class="n">privilegeLuid</span><span class="p">.</span><span class="n">LowPart</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">luidStruct</span><span class="o">-&gt;</span><span class="n">Luid</span><span class="p">.</span><span class="n">HighPart</span> <span class="o">==</span> <span class="n">privilegeLuid</span><span class="p">.</span><span class="n">HighPart</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"[+] SeDebugPrivilege encontrada para habilitar!</span><span class="se">\n\n</span><span class="s">"</span><span class="p">));</span>
			<span class="n">seDebug</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// caso não encontre o SeDebugPrivilege</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">seDebug</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"[-] SeDebugPrivilege nao encontrado</span><span class="se">\n</span><span class="s">Executando com privilegios administrativos!</span><span class="se">\n\n</span><span class="s">"</span><span class="p">));</span>
		<span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">AdjustTokenPrivileges</span><span class="p">(</span><span class="n">processToken</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tkPrivs</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">PrintError</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"AdjustTokenPrivileges()"</span><span class="p">),</span> <span class="nb">true</span><span class="p">);</span>
	<span class="p">}</span>



	<span class="k">return</span> <span class="n">TRUE</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">EnableSeDebug</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">Relaunch</span><span class="p">();</span>
		<span class="n">ExitProcess</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"Adicionando privilegio de debug!</span><span class="se">\n\n</span><span class="s">"</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="n">DWORD</span> <span class="n">level</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// variável que indica o tipo da estrutura PWTS_PROCESS_INFO_EX</span>
	<span class="n">PWTS_PROCESS_INFO_EX</span> <span class="n">processes</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="c1">// variável que contém uma estrutura PWTS_PROCESS_INFO_EX vazia</span>
	<span class="n">DWORD</span> <span class="n">processCounter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// variável que conterá a quantidade de estruturas enumeradas</span>

	<span class="c1">// enumerando os processos</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">WTSEnumerateProcessesEx</span><span class="p">(</span>
		<span class="n">WTS_CURRENT_SERVER_HANDLE</span><span class="p">,</span>
		<span class="o">&amp;</span><span class="n">level</span><span class="p">,</span>
		<span class="n">WTS_ANY_SESSION</span><span class="p">,</span>
		<span class="p">(</span><span class="n">LPTSTR</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">processes</span><span class="p">,</span>
		<span class="o">&amp;</span><span class="n">processCounter</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="c1">// imprimindo dados das estruturas</span>
	<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"Processos encontrados: %d</span><span class="se">\n\n</span><span class="s">"</span><span class="p">),</span> <span class="n">processCounter</span><span class="p">);</span>
	<span class="n">LPTSTR</span> <span class="n">stringSID</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="c1">// ponteiro do tipo string que receberá o SID do usuário que executa o processo</span>
	<span class="n">PWTS_PROCESS_INFO_EX</span> <span class="n">processesPtr</span> <span class="o">=</span> <span class="n">processes</span><span class="p">;</span>

	<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"#</span><span class="se">\t</span><span class="s">PID</span><span class="se">\t</span><span class="s">Handles</span><span class="se">\t</span><span class="s">Threads</span><span class="se">\t</span><span class="s">Process Name</span><span class="se">\t\t</span><span class="s">Account</span><span class="se">\n\n</span><span class="s">"</span><span class="p">));</span>

	<span class="c1">// iterando sobre as estruturas</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">DWORD</span> <span class="n">counter</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">counter</span> <span class="o">&lt;=</span> <span class="n">processCounter</span><span class="p">;</span> <span class="n">counter</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"%d</span><span class="se">\t</span><span class="s">"</span><span class="p">),</span> <span class="n">counter</span><span class="p">);</span>
		<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"%d</span><span class="se">\t</span><span class="s">"</span><span class="p">),</span> <span class="n">processes</span><span class="o">-&gt;</span><span class="n">ProcessId</span><span class="p">);</span>
		<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"%d</span><span class="se">\t</span><span class="s">"</span><span class="p">),</span> <span class="n">processes</span><span class="o">-&gt;</span><span class="n">HandleCount</span><span class="p">);</span>
		<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"%d</span><span class="se">\t</span><span class="s">"</span><span class="p">),</span> <span class="n">processes</span><span class="o">-&gt;</span><span class="n">NumberOfThreads</span><span class="p">);</span>
		<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"%s</span><span class="se">\t\t</span><span class="s">"</span><span class="p">),</span> <span class="n">processes</span><span class="o">-&gt;</span><span class="n">pProcessName</span><span class="p">);</span>

		<span class="n">TCHAR</span> <span class="n">accountName</span><span class="p">[</span><span class="n">MAX_ACCOUNTNAME_LEN</span><span class="p">];</span>
		<span class="n">DWORD</span> <span class="n">accountNameBuffer</span> <span class="o">=</span> <span class="n">MAX_ACCOUNTNAME_LEN</span><span class="p">;</span>
		<span class="n">TCHAR</span> <span class="n">domainName</span><span class="p">[</span><span class="n">MAX_DOMAINNAME_LEN</span><span class="p">];</span>
		<span class="n">DWORD</span> <span class="n">domainNameBuffer</span> <span class="o">=</span> <span class="n">MAX_DOMAINNAME_LEN</span><span class="p">;</span>
		<span class="n">SID_NAME_USE</span> <span class="n">peUse</span><span class="p">;</span>

		<span class="c1">// procura dados da conta através do SID</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">LookupAccountSid</span><span class="p">(</span>
			<span class="nb">NULL</span><span class="p">,</span>
			<span class="n">processes</span><span class="o">-&gt;</span><span class="n">pUserSid</span><span class="p">,</span>
			<span class="n">accountName</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">accountNameBuffer</span><span class="p">,</span>
			<span class="n">domainName</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">domainNameBuffer</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">peUse</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">));</span>
		<span class="p">}</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"%s</span><span class="se">\\</span><span class="s">%s</span><span class="se">\n</span><span class="s">"</span><span class="p">),</span> <span class="n">domainName</span><span class="p">,</span> <span class="n">accountName</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">processes</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="c1">// liberando a memória da estrutura após o uso</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">WTSFreeMemoryEx</span><span class="p">(</span><span class="n">WTSTypeProcessInfoLevel1</span><span class="p">,</span> <span class="n">processesPtr</span><span class="p">,</span> <span class="n">processCounter</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">processes</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="c1">// ********************************** inicio do dump do token</span>
	<span class="kt">int</span> <span class="n">pid</span><span class="p">;</span>

	<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"</span><span class="se">\n\n</span><span class="s">Fazer o dump do token para qual PID?: "</span><span class="p">));</span>
	<span class="n">scanf_s</span><span class="p">(</span><span class="s">"%d[^</span><span class="se">\n</span><span class="s">]"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pid</span><span class="p">);</span>
	<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">[+] Fazendo dump do token para o PID: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">),</span> <span class="n">pid</span><span class="p">);</span>

	<span class="c1">// criando um handle para o processo do qual extrairemos o token</span>
	<span class="n">HANDLE</span> <span class="n">processHandle</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="p">(</span><span class="n">processHandle</span> <span class="o">=</span> <span class="n">OpenProcess</span><span class="p">(</span><span class="n">MAXIMUM_ALLOWED</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="n">pid</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">PrintError</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"OpenProcess()"</span><span class="p">),</span> <span class="nb">false</span><span class="p">);</span>

	<span class="p">}</span>


	<span class="c1">// criando um handle para o token</span>
	<span class="n">HANDLE</span> <span class="n">processToken</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">OpenProcessToken</span><span class="p">(</span><span class="n">processHandle</span><span class="p">,</span> <span class="n">MAXIMUM_ALLOWED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">processToken</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">PrintError</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"OpenProcessToken()"</span><span class="p">),</span> <span class="nb">false</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="c1">// parsing das informações do token</span>
	<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"[+] Parsing das informacoes do token:</span><span class="se">\n</span><span class="s">"</span><span class="p">));</span>

	<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">*********************INFORMACOES DO TOKEN**********************</span><span class="se">\n\n</span><span class="s">"</span><span class="p">));</span>
	<span class="n">GetTokenOwner</span><span class="p">(</span><span class="n">processToken</span><span class="p">);</span>
	<span class="n">GetTokenUser</span><span class="p">(</span><span class="n">processToken</span><span class="p">);</span>
	<span class="n">GetTokenPrimaryGroup</span><span class="p">(</span><span class="n">processToken</span><span class="p">);</span>
	<span class="n">GetTokenGroups</span><span class="p">(</span><span class="n">processToken</span><span class="p">);</span>
	<span class="n">GetTokenPrivileges</span><span class="p">(</span><span class="n">processToken</span><span class="p">);</span>
	<span class="n">GetTokenSource</span><span class="p">(</span><span class="n">processToken</span><span class="p">);</span>
	<span class="n">GetTokenType</span><span class="p">(</span><span class="n">processToken</span><span class="p">);</span>
	<span class="n">GetTokenElevation</span><span class="p">(</span><span class="n">processToken</span><span class="p">);</span>

	<span class="n">CloseHandle</span><span class="p">(</span><span class="n">processHandle</span><span class="p">);</span>
	<span class="n">CloseHandle</span><span class="p">(</span><span class="n">processToken</span><span class="p">);</span>

	<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"</span><span class="se">\n\n</span><span class="s">Pressione qualquer tecla para finalizar()</span><span class="se">\n</span><span class="s">"</span><span class="p">));</span>

	<span class="n">getchar</span><span class="p">();</span>
	<span class="n">getchar</span><span class="p">();</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Quando executamos o programa como um usuário, ele continua solicitando elevação para administrador e enumera tosos os processos, porém, no final, ele solicita o PID do processo alvo para o <em>dump</em> do token:</p><p><img data-proofer-ignore data-src="/img/posts/Pasted%20image%2020240815132229.png" alt="" /></p><p>Quando inserimos um PID válido, ele enumera as informações do token.</p><p><img data-proofer-ignore data-src="/img/posts/Pasted%20image%2020240815132347.png" alt="" /></p><h3 id="ajustando-detalhes">Ajustando detalhes</h3><p>A enumeração ainda tem uma pequena falha, mesmo o executando como administrador, ainda existem processos que retornam erro ao enumarar. No exemplo abaixo, tentaremos enumerar o PID <strong>92</strong> do processo <strong><em>Registry</em></strong>.</p><p><img data-proofer-ignore data-src="/img/posts/Pasted%20image%2020240815134748.png" alt="" /></p><p><img data-proofer-ignore data-src="/img/posts/Pasted%20image%2020240815134829.png" alt="" /></p><p>O programa retorna falha em todas as tentativas, pois não conseguiu abrir um <em>handle</em> para o processo.</p><p>Isso ocorre, pois estamos utilizando os direitos <code class="language-plaintext highlighter-rouge">MAXIMUM_ALLOWED</code> na função <code class="language-plaintext highlighter-rouge">OpenProcess</code>, porém, existem processos protegidos pelo próprio sistema que não permitem o uso destes direitos.</p><p>Se olharmos a documentação do <a href="https://learn.microsoft.com/en-us/windows/win32/procthread/process-security-and-access-rights"><em>Process Security and Access Rights</em></a> veremos que direitos gerais e de modificação não são permitidos para processos protegidos, neste caso, podemos utilizar os direitos <code class="language-plaintext highlighter-rouge">PROCESS_QUERY_LIMITED_INFORMATION</code> para enumerá-los.</p><p><img data-proofer-ignore data-src="/img/posts/Pasted%20image%2020240815135154.png" alt="" /></p><p>Assim, podemos continuar utilizando o <code class="language-plaintext highlighter-rouge">MAXIMUM_ALLOWED</code> inicialmente, porém criar uma condição de erro que altere para <code class="language-plaintext highlighter-rouge">PROCESS_QUERY_LIMITED_INFORMATION</code> quando não for possível criar o <em>handle</em>. O código final com a implementação fica da seguinte forma:</p><div lang="cpp" class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
237
238
239
240
241
242
243
244
245
246
247
248
249
250
251
252
253
254
255
256
257
258
259
260
261
262
263
264
265
266
267
268
269
270
271
272
273
274
275
276
277
278
279
280
281
282
283
284
285
286
287
288
289
290
291
292
293
294
295
296
297
298
299
300
301
302
303
304
305
306
307
308
309
310
311
312
313
314
315
316
317
318
319
320
321
322
323
324
325
326
327
328
329
330
331
332
333
334
335
336
337
338
339
340
341
342
343
344
345
346
347
348
349
350
351
352
353
354
355
356
357
358
359
360
361
362
363
364
365
366
367
368
369
370
371
372
373
374
375
376
377
378
379
380
381
382
383
384
385
386
387
388
389
390
391
392
393
394
395
396
397
398
399
400
401
402
403
404
405
406
407
408
409
410
411
412
413
414
415
416
417
418
419
420
421
422
423
424
425
426
427
428
429
430
431
432
433
434
435
436
437
438
439
440
441
442
443
444
445
446
447
448
449
450
451
452
453
454
455
456
457
458
459
460
461
462
463
464
465
466
467
468
469
470
471
472
473
474
475
476
477
478
479
480
481
482
483
484
485
486
487
488
489
490
491
492
493
494
495
496
497
498
499
500
501
502
503
504
505
506
507
508
509
510
511
512
513
514
515
516
517
518
519
520
521
522
523
524
525
526
527
528
529
530
531
532
533
534
535
536
537
538
539
540
541
542
543
544
545
546
547
548
549
550
551
552
553
554
555
556
557
558
559
560
561
562
563
564
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;Windows.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;tchar.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;WtsApi32.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;sddl.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;strsafe.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;shellapi.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;winnt.h&gt;</span><span class="cp">
</span>
<span class="cp">#pragma comment(lib, "wtsapi32")
#pragma comment(lib, "Advapi32")
</span>
<span class="cp">#define MAX_ACCOUNTNAME_LEN 1024
#define MAX_DOMAINNAME_LEN 1024
#define	MAX_FILE_PATH_LEN	5000
#define MAX_PRIV_LEN	5000
</span>
<span class="kt">void</span> <span class="nf">PrintError</span><span class="p">(</span><span class="n">LPCTSTR</span> <span class="n">lpszFunction</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">exitProcess</span><span class="p">)</span>
<span class="p">{</span>
	<span class="c1">// Retrieve the system error message for the last-error code</span>

	<span class="n">LPVOID</span> <span class="n">lpMsgBuf</span><span class="p">;</span>
	<span class="n">LPVOID</span> <span class="n">lpDisplayBuf</span><span class="p">;</span>
	<span class="n">DWORD</span> <span class="n">dw</span> <span class="o">=</span> <span class="n">GetLastError</span><span class="p">();</span>

	<span class="n">FormatMessage</span><span class="p">(</span>
		<span class="n">FORMAT_MESSAGE_ALLOCATE_BUFFER</span> <span class="o">|</span>
		<span class="n">FORMAT_MESSAGE_FROM_SYSTEM</span> <span class="o">|</span>
		<span class="n">FORMAT_MESSAGE_IGNORE_INSERTS</span><span class="p">,</span>
		<span class="nb">NULL</span><span class="p">,</span>
		<span class="n">dw</span><span class="p">,</span>
		<span class="n">MAKELANGID</span><span class="p">(</span><span class="n">LANG_NEUTRAL</span><span class="p">,</span> <span class="n">SUBLANG_DEFAULT</span><span class="p">),</span>
		<span class="p">(</span><span class="n">LPTSTR</span><span class="p">)</span><span class="o">&amp;</span><span class="n">lpMsgBuf</span><span class="p">,</span>
		<span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="c1">// Display the error message and exit the process</span>

	<span class="n">lpDisplayBuf</span> <span class="o">=</span> <span class="p">(</span><span class="n">LPVOID</span><span class="p">)</span><span class="n">LocalAlloc</span><span class="p">(</span><span class="n">LMEM_ZEROINIT</span><span class="p">,</span>
		<span class="p">(</span><span class="n">lstrlen</span><span class="p">((</span><span class="n">LPCTSTR</span><span class="p">)</span><span class="n">lpMsgBuf</span><span class="p">)</span> <span class="o">+</span> <span class="n">lstrlen</span><span class="p">((</span><span class="n">LPCTSTR</span><span class="p">)</span><span class="n">lpszFunction</span><span class="p">)</span> <span class="o">+</span> <span class="mi">40</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">TCHAR</span><span class="p">));</span>
	<span class="n">StringCchPrintf</span><span class="p">((</span><span class="n">LPTSTR</span><span class="p">)</span><span class="n">lpDisplayBuf</span><span class="p">,</span>
		<span class="n">LocalSize</span><span class="p">(</span><span class="n">lpDisplayBuf</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">TCHAR</span><span class="p">),</span>
		<span class="n">TEXT</span><span class="p">(</span><span class="s">"%s failed with error %d: %s"</span><span class="p">),</span>
		<span class="n">lpszFunction</span><span class="p">,</span> <span class="n">dw</span><span class="p">,</span> <span class="n">lpMsgBuf</span><span class="p">);</span>
	<span class="c1">//MessageBox(NULL, (LPCTSTR)lpDisplayBuf, TEXT("Error"), MB_OK);</span>
	<span class="n">_tprintf</span><span class="p">(</span><span class="n">TEXT</span><span class="p">(</span><span class="s">"Erro: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">),</span> <span class="p">(</span><span class="n">LPTSTR</span><span class="p">)</span><span class="n">lpDisplayBuf</span><span class="p">);</span>

	<span class="n">LocalFree</span><span class="p">(</span><span class="n">lpMsgBuf</span><span class="p">);</span>
	<span class="n">LocalFree</span><span class="p">(</span><span class="n">lpDisplayBuf</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">exitProcess</span><span class="p">)</span> <span class="n">ExitProcess</span><span class="p">(</span><span class="n">dw</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// coleta o tamanho da struct</span>
<span class="n">DWORD</span> <span class="nf">GetTokenInfoLen</span><span class="p">(</span><span class="n">HANDLE</span> <span class="n">processToken</span><span class="p">,</span> <span class="n">TOKEN_INFORMATION_CLASS</span> <span class="n">info</span><span class="p">)</span> <span class="p">{</span>

	<span class="n">DWORD</span> <span class="n">structSize</span><span class="p">;</span>

	<span class="n">GetTokenInformation</span><span class="p">(</span><span class="n">processToken</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">structSize</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">structSize</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">SIDType</span><span class="p">(</span><span class="n">SID_NAME_USE</span> <span class="n">type</span><span class="p">)</span> <span class="p">{</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>

	<span class="k">case</span> <span class="n">SidTypeUser</span><span class="p">:</span>

		<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"SID Type: SidTypeUser: SID de usuario.</span><span class="se">\n</span><span class="s">"</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SidTypeGroup</span><span class="p">:</span>
		<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"SID Type: SidTypeGroup: SID de grupo</span><span class="se">\n</span><span class="s">"</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SidTypeDomain</span><span class="p">:</span>
		<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"SID Type: SidTypeDomain: SID de dominio</span><span class="se">\n</span><span class="s">"</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SidTypeAlias</span><span class="p">:</span>
		<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"SID Type: SidTypeAlias: SID alias</span><span class="se">\n</span><span class="s">"</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SidTypeWellKnownGroup</span><span class="p">:</span>
		<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"SID Type: SidTypeWellKnownGroup: SID de grupo well-known</span><span class="se">\n</span><span class="s">"</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SidTypeDeletedAccount</span><span class="p">:</span>
		<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"SID Type: SidTypeDeletedAccount: SID de conta deletada</span><span class="se">\n</span><span class="s">"</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SidTypeInvalid</span><span class="p">:</span>
		<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"SID Type: SidTypeInvalid: SID invalido</span><span class="se">\n</span><span class="s">"</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SidTypeUnknown</span><span class="p">:</span>
		<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"SID Type: SidTypeUnknown: SID nao conhecido</span><span class="se">\n</span><span class="s">"</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SidTypeComputer</span><span class="p">:</span>
		<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"SID Type: SidTypeComputer: SID de computador</span><span class="se">\n</span><span class="s">"</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SidTypeLabel</span><span class="p">:</span>
		<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"SID Type: SidTypeLabel: SID mandatory integrity label</span><span class="se">\n</span><span class="s">"</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">PrintSidInfo</span><span class="p">(</span><span class="n">PSID</span> <span class="n">psid</span><span class="p">)</span> <span class="p">{</span>

	<span class="n">LPTSTR</span> <span class="n">stringSID</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ConvertSidToStringSid</span><span class="p">(</span><span class="n">psid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">stringSID</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">PrintError</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"ConvertSidToStringSid()"</span><span class="p">),</span> <span class="nb">false</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">TCHAR</span> <span class="n">accountName</span><span class="p">[</span><span class="n">MAX_ACCOUNTNAME_LEN</span><span class="p">];</span>
	<span class="n">DWORD</span> <span class="n">accountNameBuffer</span> <span class="o">=</span> <span class="n">MAX_ACCOUNTNAME_LEN</span><span class="p">;</span>
	<span class="n">TCHAR</span> <span class="n">domainName</span><span class="p">[</span><span class="n">MAX_DOMAINNAME_LEN</span><span class="p">];</span>
	<span class="n">DWORD</span> <span class="n">domainNameBuffer</span> <span class="o">=</span> <span class="n">MAX_DOMAINNAME_LEN</span><span class="p">;</span>
	<span class="n">SID_NAME_USE</span> <span class="n">peUse</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">LookupAccountSid</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">psid</span><span class="p">,</span> <span class="n">accountName</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">accountNameBuffer</span><span class="p">,</span> <span class="n">domainName</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">domainNameBuffer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">peUse</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">PrintError</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"LookupAccountSid()"</span><span class="p">),</span> <span class="nb">false</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"SID: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">),</span> <span class="n">stringSID</span><span class="p">);</span>
	<span class="n">SIDType</span><span class="p">(</span><span class="n">peUse</span><span class="p">);</span>
	<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"Conta: %s</span><span class="se">\\</span><span class="s">%s</span><span class="se">\n\n</span><span class="s">"</span><span class="p">),</span> <span class="n">domainName</span><span class="p">,</span> <span class="n">accountName</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">GetTokenOwner</span><span class="p">(</span><span class="n">HANDLE</span> <span class="n">processToken</span><span class="p">)</span> <span class="p">{</span>

	<span class="n">DWORD</span> <span class="n">infoLen</span> <span class="o">=</span> <span class="n">GetTokenInfoLen</span><span class="p">(</span><span class="n">processToken</span><span class="p">,</span> <span class="n">TokenOwner</span><span class="p">);</span>
	<span class="n">DWORD</span> <span class="n">structLen</span><span class="p">;</span>

	<span class="n">PTOKEN_OWNER</span> <span class="n">tokenInfo</span> <span class="o">=</span> <span class="p">(</span><span class="n">PTOKEN_OWNER</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">infoLen</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">GetTokenInformation</span><span class="p">(</span><span class="n">processToken</span><span class="p">,</span> <span class="n">TokenOwner</span><span class="p">,</span> <span class="p">(</span><span class="n">LPVOID</span><span class="p">)</span><span class="n">tokenInfo</span><span class="p">,</span> <span class="n">infoLen</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">structLen</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">PrintError</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"GetTokenInformation()"</span><span class="p">),</span> <span class="nb">false</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"************************ TOKEN OWNER: </span><span class="se">\n</span><span class="s">"</span><span class="p">));</span>
	<span class="n">PrintSidInfo</span><span class="p">(</span><span class="n">tokenInfo</span><span class="o">-&gt;</span><span class="n">Owner</span><span class="p">);</span>

	<span class="n">free</span><span class="p">(</span><span class="n">tokenInfo</span><span class="p">);</span>


<span class="p">}</span>

<span class="kt">void</span> <span class="nf">GetTokenUser</span><span class="p">(</span><span class="n">HANDLE</span> <span class="n">processToken</span><span class="p">)</span> <span class="p">{</span>

	<span class="n">DWORD</span> <span class="n">infoLen</span> <span class="o">=</span> <span class="n">GetTokenInfoLen</span><span class="p">(</span><span class="n">processToken</span><span class="p">,</span> <span class="n">TokenUser</span><span class="p">);</span>
	<span class="n">DWORD</span> <span class="n">structLen</span><span class="p">;</span>

	<span class="n">PTOKEN_USER</span> <span class="n">tokenInfo</span> <span class="o">=</span> <span class="p">(</span><span class="n">PTOKEN_USER</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">infoLen</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">GetTokenInformation</span><span class="p">(</span><span class="n">processToken</span><span class="p">,</span> <span class="n">TokenUser</span><span class="p">,</span> <span class="p">(</span><span class="n">LPVOID</span><span class="p">)</span><span class="n">tokenInfo</span><span class="p">,</span> <span class="n">infoLen</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">structLen</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">PrintError</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"GetTokenInformation()"</span><span class="p">),</span> <span class="nb">false</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"************************ TOKEN USER: </span><span class="se">\n</span><span class="s">"</span><span class="p">));</span>
	<span class="n">PrintSidInfo</span><span class="p">(</span><span class="n">tokenInfo</span><span class="o">-&gt;</span><span class="n">User</span><span class="p">.</span><span class="n">Sid</span><span class="p">);</span>

	<span class="n">free</span><span class="p">(</span><span class="n">tokenInfo</span><span class="p">);</span>


<span class="p">}</span>

<span class="kt">void</span> <span class="nf">GetTokenPrimaryGroup</span><span class="p">(</span><span class="n">HANDLE</span> <span class="n">processToken</span><span class="p">)</span> <span class="p">{</span>

	<span class="n">DWORD</span> <span class="n">infoLen</span> <span class="o">=</span> <span class="n">GetTokenInfoLen</span><span class="p">(</span><span class="n">processToken</span><span class="p">,</span> <span class="n">TokenPrimaryGroup</span><span class="p">);</span>
	<span class="n">DWORD</span> <span class="n">structLen</span><span class="p">;</span>

	<span class="n">PTOKEN_PRIMARY_GROUP</span> <span class="n">tokenInfo</span> <span class="o">=</span> <span class="p">(</span><span class="n">PTOKEN_PRIMARY_GROUP</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">infoLen</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">GetTokenInformation</span><span class="p">(</span><span class="n">processToken</span><span class="p">,</span> <span class="n">TokenPrimaryGroup</span><span class="p">,</span> <span class="p">(</span><span class="n">LPVOID</span><span class="p">)</span><span class="n">tokenInfo</span><span class="p">,</span> <span class="n">infoLen</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">structLen</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">PrintError</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"GetTokenInformation()"</span><span class="p">),</span> <span class="nb">false</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"************************ TOKEN PRIMARY GROUP: </span><span class="se">\n</span><span class="s">"</span><span class="p">));</span>
	<span class="n">PrintSidInfo</span><span class="p">(</span><span class="n">tokenInfo</span><span class="o">-&gt;</span><span class="n">PrimaryGroup</span><span class="p">);</span>

	<span class="n">free</span><span class="p">(</span><span class="n">tokenInfo</span><span class="p">);</span>


<span class="p">}</span>

<span class="kt">void</span> <span class="nf">GetTokenGroups</span><span class="p">(</span><span class="n">HANDLE</span> <span class="n">processToken</span><span class="p">)</span> <span class="p">{</span>

	<span class="n">DWORD</span> <span class="n">infoLen</span> <span class="o">=</span> <span class="n">GetTokenInfoLen</span><span class="p">(</span><span class="n">processToken</span><span class="p">,</span> <span class="n">TokenGroups</span><span class="p">);</span>
	<span class="n">DWORD</span> <span class="n">structLen</span><span class="p">;</span>

	<span class="n">PTOKEN_GROUPS</span> <span class="n">tokenInfo</span> <span class="o">=</span> <span class="p">(</span><span class="n">PTOKEN_GROUPS</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">infoLen</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">GetTokenInformation</span><span class="p">(</span><span class="n">processToken</span><span class="p">,</span> <span class="n">TokenGroups</span><span class="p">,</span> <span class="p">(</span><span class="n">LPVOID</span><span class="p">)</span><span class="n">tokenInfo</span><span class="p">,</span> <span class="n">infoLen</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">structLen</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">PrintError</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"GetTokenInformation()"</span><span class="p">),</span> <span class="nb">false</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"************************ TOKEN GROUPS: </span><span class="se">\n</span><span class="s">"</span><span class="p">));</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">DWORD</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">tokenInfo</span><span class="o">-&gt;</span><span class="n">GroupCount</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">PrintSidInfo</span><span class="p">(</span><span class="n">tokenInfo</span><span class="o">-&gt;</span><span class="n">Groups</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">Sid</span><span class="p">);</span>
	<span class="p">}</span>
	

	<span class="n">free</span><span class="p">(</span><span class="n">tokenInfo</span><span class="p">);</span>


<span class="p">}</span>

<span class="kt">void</span> <span class="nf">GetTokenPrivileges</span><span class="p">(</span><span class="n">HANDLE</span> <span class="n">processToken</span><span class="p">)</span> <span class="p">{</span>

	<span class="n">DWORD</span> <span class="n">infoLen</span> <span class="o">=</span> <span class="n">GetTokenInfoLen</span><span class="p">(</span><span class="n">processToken</span><span class="p">,</span> <span class="n">TokenPrivileges</span><span class="p">);</span>
	<span class="n">DWORD</span> <span class="n">structLen</span><span class="p">;</span>

	<span class="n">PTOKEN_PRIVILEGES</span> <span class="n">tokenInfo</span> <span class="o">=</span> <span class="p">(</span><span class="n">PTOKEN_PRIVILEGES</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">infoLen</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">GetTokenInformation</span><span class="p">(</span><span class="n">processToken</span><span class="p">,</span> <span class="n">TokenPrivileges</span><span class="p">,</span> <span class="p">(</span><span class="n">LPVOID</span><span class="p">)</span><span class="n">tokenInfo</span><span class="p">,</span> <span class="n">infoLen</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">structLen</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">PrintError</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"GetTokenInformation()"</span><span class="p">),</span> <span class="nb">false</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">TCHAR</span> <span class="n">privName</span><span class="p">[</span><span class="n">MAX_PRIV_LEN</span><span class="p">];</span>
	<span class="n">DWORD</span> <span class="n">privNameSize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">privName</span><span class="p">);</span>

	<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"************************ TOKEN PRIVILEGES: </span><span class="se">\n</span><span class="s">"</span><span class="p">));</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">DWORD</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">tokenInfo</span><span class="o">-&gt;</span><span class="n">PrivilegeCount</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">privNameSize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">privName</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">LookupPrivilegeName</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tokenInfo</span><span class="o">-&gt;</span><span class="n">Privileges</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">Luid</span><span class="p">,</span> <span class="n">privName</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">privNameSize</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">PrintError</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"LookupPrivilegeName()"</span><span class="p">),</span> <span class="nb">false</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">tokenInfo</span><span class="o">-&gt;</span><span class="n">Privileges</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">Attributes</span> <span class="o">&amp;</span> <span class="n">SE_PRIVILEGE_ENABLED</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"%3d. Enabled        %s</span><span class="se">\n</span><span class="s">"</span><span class="p">),</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">privName</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">else</span> <span class="p">{</span>
				<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"%3d. Disabled       %s</span><span class="se">\n</span><span class="s">"</span><span class="p">),</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">privName</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">));</span>

	<span class="n">free</span><span class="p">(</span><span class="n">tokenInfo</span><span class="p">);</span>


<span class="p">}</span>

<span class="kt">void</span> <span class="nf">GetTokenSource</span><span class="p">(</span><span class="n">HANDLE</span> <span class="n">processToken</span><span class="p">)</span> <span class="p">{</span>

	<span class="n">DWORD</span> <span class="n">structLen</span><span class="p">;</span>

	<span class="n">PTOKEN_SOURCE</span> <span class="n">tokenInfo</span> <span class="o">=</span> <span class="p">(</span><span class="n">PTOKEN_SOURCE</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">TOKEN_SOURCE</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">GetTokenInformation</span><span class="p">(</span><span class="n">processToken</span><span class="p">,</span> <span class="n">TokenSource</span><span class="p">,</span> <span class="p">(</span><span class="n">LPVOID</span><span class="p">)</span><span class="n">tokenInfo</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">TOKEN_SOURCE</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">structLen</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">PrintError</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"GetTokenInformation()"</span><span class="p">),</span> <span class="nb">false</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"************************ TOKEN SOURCE: </span><span class="se">\n</span><span class="s">"</span><span class="p">));</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">DWORD</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">tokenInfo</span><span class="o">-&gt;</span><span class="n">SourceName</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"%c"</span><span class="p">),</span> <span class="n">tokenInfo</span><span class="o">-&gt;</span><span class="n">SourceName</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"</span><span class="se">\n\n</span><span class="s">"</span><span class="p">));</span>

	<span class="n">free</span><span class="p">(</span><span class="n">tokenInfo</span><span class="p">);</span>


<span class="p">}</span>

<span class="kt">void</span> <span class="nf">GetTokenType</span><span class="p">(</span><span class="n">HANDLE</span> <span class="n">processToken</span><span class="p">)</span> <span class="p">{</span>

	<span class="n">DWORD</span> <span class="n">structLen</span><span class="p">;</span>

	<span class="n">PTOKEN_TYPE</span> <span class="n">tokenInfo</span> <span class="o">=</span> <span class="p">(</span><span class="n">PTOKEN_TYPE</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">PTOKEN_TYPE</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">GetTokenInformation</span><span class="p">(</span><span class="n">processToken</span><span class="p">,</span> <span class="n">TokenType</span><span class="p">,</span> <span class="p">(</span><span class="n">LPVOID</span><span class="p">)</span><span class="n">tokenInfo</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">PTOKEN_TYPE</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">structLen</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">PrintError</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"GetTokenInformation()"</span><span class="p">),</span> <span class="nb">false</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"************************ TOKEN TYPE: </span><span class="se">\n</span><span class="s">"</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">tokenInfo</span> <span class="o">==</span> <span class="n">TokenPrimary</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"TokenPrimary"</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"TokenImpersonation"</span><span class="p">));</span>

		<span class="c1">// procurando o tipo de impersonation</span>
		<span class="n">PSECURITY_IMPERSONATION_LEVEL</span> <span class="n">tokenImpLevel</span> <span class="o">=</span> <span class="p">(</span><span class="n">PSECURITY_IMPERSONATION_LEVEL</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">SECURITY_IMPERSONATION_LEVEL</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">GetTokenInformation</span><span class="p">(</span><span class="n">processToken</span><span class="p">,</span> <span class="n">TokenImpersonationLevel</span><span class="p">,</span> <span class="p">(</span><span class="n">LPVOID</span><span class="p">)</span><span class="n">tokenImpLevel</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">TOKEN_TYPE</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">structLen</span><span class="p">))</span> <span class="p">{</span>

			<span class="n">PrintError</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"GetTokenInformation()"</span><span class="p">),</span> <span class="nb">false</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="k">switch</span> <span class="p">(</span><span class="o">*</span><span class="n">tokenImpLevel</span><span class="p">)</span> <span class="p">{</span>

			<span class="k">case</span> <span class="n">SecurityAnonymous</span><span class="p">:</span>
				<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"Impersonation Level: SecurityAnonymous</span><span class="se">\n</span><span class="s">"</span><span class="p">));</span>
					<span class="k">break</span><span class="p">;</span>

			<span class="k">case</span> <span class="n">SecurityIdentification</span><span class="p">:</span>
				<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"Impersonation Level: SecurityIdentification</span><span class="se">\n</span><span class="s">"</span><span class="p">));</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="k">case</span> <span class="n">SecurityImpersonation</span><span class="p">:</span>
				<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"Impersonation Level: SecurityImpersonation</span><span class="se">\n</span><span class="s">"</span><span class="p">));</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="k">case</span> <span class="n">SecurityDelegation</span><span class="p">:</span>
				<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"Impersonation Level: SecurityDelegation</span><span class="se">\n</span><span class="s">"</span><span class="p">));</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"</span><span class="se">\n\n</span><span class="s">"</span><span class="p">));</span>

	<span class="n">free</span><span class="p">(</span><span class="n">tokenInfo</span><span class="p">);</span>


<span class="p">}</span>

<span class="kt">void</span> <span class="nf">GetTokenElevation</span><span class="p">(</span><span class="n">HANDLE</span> <span class="n">processToken</span><span class="p">)</span> <span class="p">{</span>

	<span class="n">DWORD</span> <span class="n">structLen</span><span class="p">;</span>

	<span class="n">PTOKEN_ELEVATION</span> <span class="n">tokenInfo</span> <span class="o">=</span> <span class="p">(</span><span class="n">PTOKEN_ELEVATION</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">TOKEN_ELEVATION</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">GetTokenInformation</span><span class="p">(</span><span class="n">processToken</span><span class="p">,</span> <span class="n">TokenElevation</span><span class="p">,</span> <span class="p">(</span><span class="n">LPVOID</span><span class="p">)</span><span class="n">tokenInfo</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">TOKEN_ELEVATION</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">structLen</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">PrintError</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"GetTokenInformation()"</span><span class="p">),</span> <span class="nb">false</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"************************ TOKEN ELEVATION: </span><span class="se">\n</span><span class="s">"</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tokenInfo</span><span class="o">-&gt;</span><span class="n">TokenIsElevated</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"Token Elevated: TRUE</span><span class="se">\n</span><span class="s">"</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"Token Elevated: FALSE</span><span class="se">\n</span><span class="s">"</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">));</span>

	<span class="n">free</span><span class="p">(</span><span class="n">tokenInfo</span><span class="p">);</span>


<span class="p">}</span>

<span class="kt">void</span> <span class="nf">Relaunch</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>

	<span class="n">SHELLEXECUTEINFO</span> <span class="n">execInfo</span><span class="p">;</span>
	<span class="n">WCHAR</span> <span class="n">filePath</span><span class="p">[</span><span class="n">MAX_FILE_PATH_LEN</span><span class="p">];</span>
	<span class="n">DWORD</span> <span class="n">filePathLen</span> <span class="o">=</span> <span class="n">MAX_FILE_PATH_LEN</span><span class="p">;</span>

	<span class="c1">// coletando o path do programa</span>
	<span class="n">GetModuleFileName</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">filePath</span><span class="p">,</span> <span class="n">filePathLen</span><span class="p">);</span>

	<span class="c1">// preenchendo a estrutura SHELLEXECUTEINFO</span>
	<span class="n">execInfo</span><span class="p">.</span><span class="n">cbSize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">SHELLEXECUTEINFO</span><span class="p">);</span>
	<span class="n">execInfo</span><span class="p">.</span><span class="n">fMask</span> <span class="o">=</span> <span class="n">SEE_MASK_DEFAULT</span><span class="p">;</span>
	<span class="n">execInfo</span><span class="p">.</span><span class="n">lpVerb</span> <span class="o">=</span> <span class="n">_T</span><span class="p">(</span><span class="s">"runas"</span><span class="p">);</span>
	<span class="n">execInfo</span><span class="p">.</span><span class="n">lpFile</span> <span class="o">=</span> <span class="n">filePath</span><span class="p">;</span>
	<span class="n">execInfo</span><span class="p">.</span><span class="n">lpParameters</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">execInfo</span><span class="p">.</span><span class="n">lpDirectory</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">execInfo</span><span class="p">.</span><span class="n">nShow</span> <span class="o">=</span> <span class="n">SW_SHOWNORMAL</span><span class="p">;</span>

	<span class="n">ShellExecuteEx</span><span class="p">(</span><span class="o">&amp;</span><span class="n">execInfo</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// função para habilitar SeDebugPrivilege</span>
<span class="n">BOOL</span> <span class="nf">EnableSeDebug</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>

	<span class="n">LUID</span> <span class="n">privilegeLuid</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">LookupPrivilegeValue</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">_T</span><span class="p">(</span><span class="s">"SeDebugPrivilege"</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">privilegeLuid</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">PrintError</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"LookupPrivilegeValue()"</span><span class="p">),</span> <span class="nb">true</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="c1">// criando a estrutura do token</span>
	<span class="n">TOKEN_PRIVILEGES</span> <span class="n">tkPrivs</span><span class="p">;</span>

	<span class="n">tkPrivs</span><span class="p">.</span><span class="n">PrivilegeCount</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// quantidade de privilégios a serem configurados</span>
	<span class="n">tkPrivs</span><span class="p">.</span><span class="n">Privileges</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">Luid</span> <span class="o">=</span> <span class="n">privilegeLuid</span><span class="p">;</span> <span class="c1">// LUID do primeiro e único privilégio (SeDebugPrivilege)</span>
	<span class="n">tkPrivs</span><span class="p">.</span><span class="n">Privileges</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">Attributes</span> <span class="o">=</span> <span class="n">SE_PRIVILEGE_ENABLED</span><span class="p">;</span> <span class="c1">// atributo que o privilégio receberá</span>

	<span class="n">HANDLE</span> <span class="n">currentProcessHandle</span> <span class="o">=</span> <span class="n">GetCurrentProcess</span><span class="p">();</span>
	<span class="n">HANDLE</span> <span class="n">processToken</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">OpenProcessToken</span><span class="p">(</span><span class="n">currentProcessHandle</span><span class="p">,</span> <span class="n">TOKEN_ADJUST_PRIVILEGES</span> <span class="o">|</span> <span class="n">TOKEN_QUERY</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">processToken</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">PrintError</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"OpenProcessToken()"</span><span class="p">),</span> <span class="nb">true</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="c1">// coletando o tamanho da estrutura</span>
	<span class="n">DWORD</span> <span class="n">firstStructSize</span> <span class="o">=</span> <span class="n">GetTokenInfoLen</span><span class="p">(</span><span class="n">processToken</span><span class="p">,</span> <span class="n">TokenPrivileges</span><span class="p">);</span>

	<span class="c1">// invocando GetTokenInformation() com todos os parâmetros</span>
	<span class="n">DWORD</span> <span class="n">secondStructSize</span><span class="p">;</span> <span class="c1">// variável que receberá o tamanho da resposta na segunda execução</span>
	<span class="n">PTOKEN_PRIVILEGES</span> <span class="n">processTokenPriv</span><span class="p">;</span> <span class="c1">// ponteiro para estrutura TOKEN_PRIVILEGES que receberá a resposta</span>

	<span class="n">processTokenPriv</span> <span class="o">=</span> <span class="p">(</span><span class="n">PTOKEN_PRIVILEGES</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">firstStructSize</span><span class="p">);</span> <span class="c1">// alocando o buffer</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">GetTokenInformation</span><span class="p">(</span><span class="n">processToken</span><span class="p">,</span> <span class="n">TokenPrivileges</span><span class="p">,</span> <span class="n">processTokenPriv</span><span class="p">,</span> <span class="n">firstStructSize</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">secondStructSize</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">PrintError</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"GetTokenInformation()"</span><span class="p">),</span> <span class="nb">true</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="c1">// iterando sobre a estrutura TOKEN_PRIVILEGES</span>
	<span class="n">PLUID_AND_ATTRIBUTES</span> <span class="n">luidStruct</span><span class="p">;</span> <span class="c1">// ponteiro para estrutura que receberá cada membro do array na iteração</span>
	<span class="kt">bool</span> <span class="n">seDebug</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span> <span class="c1">// variável de controle caso o privilégio exista</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">DWORD</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">processTokenPriv</span><span class="o">-&gt;</span><span class="n">PrivilegeCount</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">luidStruct</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">processTokenPriv</span><span class="o">-&gt;</span><span class="n">Privileges</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">luidStruct</span><span class="o">-&gt;</span><span class="n">Luid</span><span class="p">.</span><span class="n">LowPart</span> <span class="o">==</span> <span class="n">privilegeLuid</span><span class="p">.</span><span class="n">LowPart</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">luidStruct</span><span class="o">-&gt;</span><span class="n">Luid</span><span class="p">.</span><span class="n">HighPart</span> <span class="o">==</span> <span class="n">privilegeLuid</span><span class="p">.</span><span class="n">HighPart</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"[+] SeDebugPrivilege encontrada para habilitar!</span><span class="se">\n\n</span><span class="s">"</span><span class="p">));</span>
			<span class="n">seDebug</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// caso não encontre o SeDebugPrivilege</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">seDebug</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"[-] SeDebugPrivilege nao encontrado</span><span class="se">\n</span><span class="s">Executando com privilegios administrativos!</span><span class="se">\n\n</span><span class="s">"</span><span class="p">));</span>
		<span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">AdjustTokenPrivileges</span><span class="p">(</span><span class="n">processToken</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tkPrivs</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">PrintError</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"AdjustTokenPrivileges()"</span><span class="p">),</span> <span class="nb">true</span><span class="p">);</span>
	<span class="p">}</span>



	<span class="k">return</span> <span class="n">TRUE</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">EnableSeDebug</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">Relaunch</span><span class="p">();</span>
		<span class="n">ExitProcess</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"Adicionando privilegio de debug!</span><span class="se">\n\n</span><span class="s">"</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="n">DWORD</span> <span class="n">level</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// variável que indica o tipo da estrutura PWTS_PROCESS_INFO_EX</span>
	<span class="n">PWTS_PROCESS_INFO_EX</span> <span class="n">processes</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="c1">// variável que contém uma estrutura PWTS_PROCESS_INFO_EX vazia</span>
	<span class="n">DWORD</span> <span class="n">processCounter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// variável que conterá a quantidade de estruturas enumeradas</span>

	<span class="c1">// enumerando os processos</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">WTSEnumerateProcessesEx</span><span class="p">(</span>
		<span class="n">WTS_CURRENT_SERVER_HANDLE</span><span class="p">,</span>
		<span class="o">&amp;</span><span class="n">level</span><span class="p">,</span>
		<span class="n">WTS_ANY_SESSION</span><span class="p">,</span>
		<span class="p">(</span><span class="n">LPTSTR</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">processes</span><span class="p">,</span>
		<span class="o">&amp;</span><span class="n">processCounter</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="c1">// imprimindo dados das estruturas</span>
	<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"Processos encontrados: %d</span><span class="se">\n\n</span><span class="s">"</span><span class="p">),</span> <span class="n">processCounter</span><span class="p">);</span>
	<span class="n">LPTSTR</span> <span class="n">stringSID</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="c1">// ponteiro do tipo string que receberá o SID do usuário que executa o processo</span>
	<span class="n">PWTS_PROCESS_INFO_EX</span> <span class="n">processesPtr</span> <span class="o">=</span> <span class="n">processes</span><span class="p">;</span>

	<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"#</span><span class="se">\t</span><span class="s">PID</span><span class="se">\t</span><span class="s">Handles</span><span class="se">\t</span><span class="s">Threads</span><span class="se">\t</span><span class="s">Process Name</span><span class="se">\t\t</span><span class="s">Account</span><span class="se">\n\n</span><span class="s">"</span><span class="p">));</span>

	<span class="c1">// iterando sobre as estruturas</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">DWORD</span> <span class="n">counter</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">counter</span> <span class="o">&lt;=</span> <span class="n">processCounter</span><span class="p">;</span> <span class="n">counter</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"%d</span><span class="se">\t</span><span class="s">"</span><span class="p">),</span> <span class="n">counter</span><span class="p">);</span>
		<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"%d</span><span class="se">\t</span><span class="s">"</span><span class="p">),</span> <span class="n">processes</span><span class="o">-&gt;</span><span class="n">ProcessId</span><span class="p">);</span>
		<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"%d</span><span class="se">\t</span><span class="s">"</span><span class="p">),</span> <span class="n">processes</span><span class="o">-&gt;</span><span class="n">HandleCount</span><span class="p">);</span>
		<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"%d</span><span class="se">\t</span><span class="s">"</span><span class="p">),</span> <span class="n">processes</span><span class="o">-&gt;</span><span class="n">NumberOfThreads</span><span class="p">);</span>
		<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"%s</span><span class="se">\t\t</span><span class="s">"</span><span class="p">),</span> <span class="n">processes</span><span class="o">-&gt;</span><span class="n">pProcessName</span><span class="p">);</span>

		<span class="n">TCHAR</span> <span class="n">accountName</span><span class="p">[</span><span class="n">MAX_ACCOUNTNAME_LEN</span><span class="p">];</span>
		<span class="n">DWORD</span> <span class="n">accountNameBuffer</span> <span class="o">=</span> <span class="n">MAX_ACCOUNTNAME_LEN</span><span class="p">;</span>
		<span class="n">TCHAR</span> <span class="n">domainName</span><span class="p">[</span><span class="n">MAX_DOMAINNAME_LEN</span><span class="p">];</span>
		<span class="n">DWORD</span> <span class="n">domainNameBuffer</span> <span class="o">=</span> <span class="n">MAX_DOMAINNAME_LEN</span><span class="p">;</span>
		<span class="n">SID_NAME_USE</span> <span class="n">peUse</span><span class="p">;</span>

		<span class="c1">// procura dados da conta através do SID</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">LookupAccountSid</span><span class="p">(</span>
			<span class="nb">NULL</span><span class="p">,</span>
			<span class="n">processes</span><span class="o">-&gt;</span><span class="n">pUserSid</span><span class="p">,</span>
			<span class="n">accountName</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">accountNameBuffer</span><span class="p">,</span>
			<span class="n">domainName</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">domainNameBuffer</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">peUse</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">));</span>
		<span class="p">}</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"%s</span><span class="se">\\</span><span class="s">%s</span><span class="se">\n</span><span class="s">"</span><span class="p">),</span> <span class="n">domainName</span><span class="p">,</span> <span class="n">accountName</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">processes</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="c1">// liberando a memória da estrutura após o uso</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">WTSFreeMemoryEx</span><span class="p">(</span><span class="n">WTSTypeProcessInfoLevel1</span><span class="p">,</span> <span class="n">processesPtr</span><span class="p">,</span> <span class="n">processCounter</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">processes</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="c1">// ********************************** inicio do dump do token</span>
	<span class="kt">int</span> <span class="n">pid</span><span class="p">;</span>

	<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"</span><span class="se">\n\n</span><span class="s">Fazer o dump do token para qual PID?: "</span><span class="p">));</span>
	<span class="n">scanf_s</span><span class="p">(</span><span class="s">"%d[^</span><span class="se">\n</span><span class="s">]"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pid</span><span class="p">);</span>
	<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">[+] Fazendo dump do token para o PID: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">),</span> <span class="n">pid</span><span class="p">);</span>

	<span class="c1">// criando um handle para o processo do qual extrairemos o token</span>
	<span class="n">HANDLE</span> <span class="n">processHandle</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="p">(</span><span class="n">processHandle</span> <span class="o">=</span> <span class="n">OpenProcess</span><span class="p">(</span><span class="n">MAXIMUM_ALLOWED</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="n">pid</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"[-] Falha ao usar OpenProcess() com MAXIMUM_ALLOWED, este processo deve estar protegido!</span><span class="se">\n</span><span class="s">"</span><span class="p">));</span>
		<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"[-] Tentando novamente com com PROCESS_QUERY_LIMITED_INFORMATION!</span><span class="se">\n</span><span class="s">"</span><span class="p">));</span>

		<span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="p">(</span><span class="n">processHandle</span> <span class="o">=</span> <span class="n">OpenProcess</span><span class="p">(</span><span class="n">PROCESS_QUERY_LIMITED_INFORMATION</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="n">pid</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">PrintError</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"OpenProcess()"</span><span class="p">),</span> <span class="nb">false</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>


	<span class="c1">// criando um handle para o token</span>
	<span class="n">HANDLE</span> <span class="n">processToken</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">OpenProcessToken</span><span class="p">(</span><span class="n">processHandle</span><span class="p">,</span> <span class="n">MAXIMUM_ALLOWED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">processToken</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">PrintError</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"OpenProcessToken()"</span><span class="p">),</span> <span class="nb">false</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="c1">// parsing das informações do token</span>
	<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"[+] Parsing das informacoes do token:</span><span class="se">\n</span><span class="s">"</span><span class="p">));</span>

	<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">*********************INFORMACOES DO TOKEN**********************</span><span class="se">\n\n</span><span class="s">"</span><span class="p">));</span>
	<span class="n">GetTokenOwner</span><span class="p">(</span><span class="n">processToken</span><span class="p">);</span>
	<span class="n">GetTokenUser</span><span class="p">(</span><span class="n">processToken</span><span class="p">);</span>
	<span class="n">GetTokenPrimaryGroup</span><span class="p">(</span><span class="n">processToken</span><span class="p">);</span>
	<span class="n">GetTokenGroups</span><span class="p">(</span><span class="n">processToken</span><span class="p">);</span>
	<span class="n">GetTokenPrivileges</span><span class="p">(</span><span class="n">processToken</span><span class="p">);</span>
	<span class="n">GetTokenSource</span><span class="p">(</span><span class="n">processToken</span><span class="p">);</span>
	<span class="n">GetTokenType</span><span class="p">(</span><span class="n">processToken</span><span class="p">);</span>
	<span class="n">GetTokenElevation</span><span class="p">(</span><span class="n">processToken</span><span class="p">);</span>

	<span class="n">CloseHandle</span><span class="p">(</span><span class="n">processHandle</span><span class="p">);</span>
	<span class="n">CloseHandle</span><span class="p">(</span><span class="n">processToken</span><span class="p">);</span>

	<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"</span><span class="se">\n\n</span><span class="s">Pressione qualquer tecla para finalizar()</span><span class="se">\n</span><span class="s">"</span><span class="p">));</span>

	<span class="n">getchar</span><span class="p">();</span>
	<span class="n">getchar</span><span class="p">();</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Agora quando enumeramos o PID 92, conseguimos obter as informações.</p><p><img data-proofer-ignore data-src="/img/posts/Pasted%20image%2020240815135623.png" alt="" /></p><p>O passo-a-passo na criação deste programa, fornece uma boa base para o <em>process listing</em> e o <em>token dumping</em> utilizando as APIs do Windows. Obviamente o desafio é utilizar a criatividade para explorar cada vez mais possibilidades.</p><h1 id="createtoolhelp32snapshot">CreateToolhelp32Snapshot</h1><p>O uso da <a href="https://learn.microsoft.com/en-us/windows/win32/api/tlhelp32/nf-tlhelp32-createtoolhelp32snapshot">CreateToolhelp32Snapshot</a> para <em>process listing</em> foi exemplificado no artigo anterior “<a href="https://h41stur.com/posts/get-process/">Enumerando Processos pelo Nome</a>” onde a utilizamos para encontrar processos em execução pesquisando pelo nome do executável.</p><p>O seu uso é muito simples, uma vez que só exige dois parâmetros: o tipo do <em>snapshot</em> e o PID de um processo específico que pode ser setado como zero, para listar todos os processos.</p><div lang="cpp" class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="n">HANDLE</span> <span class="nf">CreateToolhelp32Snapshot</span><span class="p">(</span>
  <span class="p">[</span><span class="n">in</span><span class="p">]</span> <span class="n">DWORD</span> <span class="n">dwFlags</span><span class="p">,</span>
  <span class="p">[</span><span class="n">in</span><span class="p">]</span> <span class="n">DWORD</span> <span class="n">th32ProcessID</span>
<span class="p">);</span>
</pre></table></code></div></div><p>O tipo de <em>snapshot</em> pode ser desde os processos em execução, ou <em>threads</em> e até mesmo um <em>snapshot</em> completo, seguindo as opções da tabela abaixo:</p><p><img data-proofer-ignore data-src="/img/posts/Pasted%20image%2020240815164903.png" alt="" /></p><h2 id="vantagens-do-uso">Vantagens do uso</h2><p>Utilizar esta API para listar processos tem como sua maior vantagem que seu uso não é considerado malicioso por sistemas antivírus.</p><p>Isso ocorre por uma série de fatores, tais como: não é preciso ter o privilégio <code class="language-plaintext highlighter-rouge">SeDebugPrivilege</code> para obter informações sobre processos; ele não consulta diretamente a memória, mas cria um <em>snapshot</em> para ser analisado, sem interferir em nenhum outro processo em execução; é utilizado por uma infinidade de sistemas de monitoramento, portanto seu uso é considerado “normal”; entre outros.</p><p>Inclusive, por esse motivo, é uma técnica utilizada por alguns <em>malwares</em> famosos como:</p><p><a href="https://ioactive.com/pdfs/ZeusSpyEyeBankingTrojanAnalysis.pdf">Zeus</a></p><p><img data-proofer-ignore data-src="/img/posts/Pasted%20image%2020240815170034.png" alt="" /></p><p>E o <a href="https://documents.trendmicro.com/assets/wp/wp-pos-ram-scraper-malware.pdf">PoS RAM Scraper</a></p><p><img data-proofer-ignore data-src="/img/posts/Pasted%20image%2020240815170130.png" alt="" /></p><h2 id="desvantagens-do-uso">Desvantagens do uso</h2><p>A maior, e nem tão impactante, desvantagem de usar a <code class="language-plaintext highlighter-rouge">CreateToolhelp32Snapshot</code> também está no fato de trabalhar com <em>snapshots</em>, ou seja, é um “retrato” de um momento no sistema, durante a análise deste momento, novos processos podem ser inicializados, finalizados, modificados, novas <em>threads</em> podem ser executadas alterando o contexto do sistema em questão.</p><p>Do ponto de vista <i><span style="color:red;">red team</span></i> é uma desvantagem aceitável, comparado com as vantagens.</p><h2 id="desenvolvendo-o-process-listing">Desenvolvendo o <em>Process Listing</em></h2><p>Para listarmos os processos, podemos criar um <em>snapshot</em> semente destes, passando como tipo, o valor <code class="language-plaintext highlighter-rouge">TH32CS_SNAPPROCESS</code>. A função <code class="language-plaintext highlighter-rouge">CreateToolhelp32Snapshot</code> enviará o <em>snapshot</em> para um <em>handle</em>.</p><p>A partir deste ponto, podemos trabalhar com a lista de processos gerada no <em>snapshot</em> com o uso da função <code class="language-plaintext highlighter-rouge">Process32First</code>.</p><div lang="cpp" class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="n">BOOL</span> <span class="nf">Process32First</span><span class="p">(</span>
  <span class="p">[</span><span class="n">in</span><span class="p">]</span>      <span class="n">HANDLE</span>           <span class="n">hSnapshot</span><span class="p">,</span>
  <span class="p">[</span><span class="n">in</span><span class="p">,</span> <span class="n">out</span><span class="p">]</span> <span class="n">LPPROCESSENTRY32</span> <span class="n">lppe</span>
<span class="p">);</span>
</pre></table></code></div></div><p>Esta função exige como argumento o <em>handle</em> extraído com a lista dos processos, e um ponteiro para uma estrutura do tipo <a href="https://learn.microsoft.com/en-us/windows/win32/api/tlhelp32/ns-tlhelp32-processentry32">PROCESSENTRY32</a> onde ela descarregará as informações sobre o primeiro processo encontrado na lista.</p><p>A estrutura <code class="language-plaintext highlighter-rouge">PROCESSENTRY32</code> tem o seguinte formato:</p><div lang="cpp" class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="nc">tagPROCESSENTRY32</span> <span class="p">{</span>
  <span class="n">DWORD</span>     <span class="n">dwSize</span><span class="p">;</span>
  <span class="n">DWORD</span>     <span class="n">cntUsage</span><span class="p">;</span>
  <span class="n">DWORD</span>     <span class="n">th32ProcessID</span><span class="p">;</span>
  <span class="n">ULONG_PTR</span> <span class="n">th32DefaultHeapID</span><span class="p">;</span>
  <span class="n">DWORD</span>     <span class="n">th32ModuleID</span><span class="p">;</span>
  <span class="n">DWORD</span>     <span class="n">cntThreads</span><span class="p">;</span>
  <span class="n">DWORD</span>     <span class="n">th32ParentProcessID</span><span class="p">;</span>
  <span class="n">LONG</span>      <span class="n">pcPriClassBase</span><span class="p">;</span>
  <span class="n">DWORD</span>     <span class="n">dwFlags</span><span class="p">;</span>
  <span class="n">CHAR</span>      <span class="n">szExeFile</span><span class="p">[</span><span class="n">MAX_PATH</span><span class="p">];</span>
<span class="p">}</span> <span class="n">PROCESSENTRY32</span><span class="p">;</span>
</pre></table></code></div></div><p>Uma informação importante vinda da própria documentação, é que antes de invocarmos a função <code class="language-plaintext highlighter-rouge">Process32First()</code> temos que inicializar o parâmetro <code class="language-plaintext highlighter-rouge">dwSize</code> da estrutura PROCESSENTRY32 com o valor <code class="language-plaintext highlighter-rouge">sizeof(PROCESSENTRY32)</code>, caso contrário o processo falhará.</p><p><img data-proofer-ignore data-src="/img/posts/Pasted%20image%2020240805222649.png" alt="" /></p><p>Uma vez que a função <code class="language-plaintext highlighter-rouge">Process32First()</code> foi executada com sucesso, temos todas as informações sobre o primeiro processo do <em>snapshot</em> contidos na <em>struct</em> PROCESSENTRY32 e podemos consultá-la e obtermos as informações que precisamos.</p><p>Para continuar a navegação no <em>snapshot</em> a partir deste ponto, utilizamos a função <a href="https://learn.microsoft.com/en-us/windows/win32/api/tlhelp32/nf-tlhelp32-process32next">Process32Next</a> que tem basicamente os mesmos argumentos da anterior.</p><div lang="cpp" class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="n">BOOL</span> <span class="nf">Process32Next</span><span class="p">(</span>
  <span class="p">[</span><span class="n">in</span><span class="p">]</span>  <span class="n">HANDLE</span>           <span class="n">hSnapshot</span><span class="p">,</span>
  <span class="p">[</span><span class="n">out</span><span class="p">]</span> <span class="n">LPPROCESSENTRY32</span> <span class="n">lppe</span>
<span class="p">);</span>
</pre></table></code></div></div><p>Após sua execução, a estrutura <code class="language-plaintext highlighter-rouge">PROCESSENTRY32</code> passa a conter os dados do próximo processo do <em>snapshot</em>. A partir deste ponto, podemos percorrer toda a lista de processos contidos no <em>snapshot</em> obtendo as informações necessárias para nossos objetivos.</p><p>É possível notar que a estrutura <code class="language-plaintext highlighter-rouge">PROCESSENTRY32</code> por si só, já contém informações relevantes.</p><p>Um simples programa de <em>process listing</em> pode ser criado da seguinte maneira:</p><div lang="cpp" class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;Windows.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;tchar.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;TlHelp32.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;strsafe.h&gt;</span><span class="cp">
</span>

<span class="kt">void</span> <span class="nf">PrintError</span><span class="p">(</span><span class="n">LPCTSTR</span> <span class="n">lpszFunction</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">exitProcess</span><span class="p">)</span>
<span class="p">{</span>
	<span class="c1">// Retrieve the system error message for the last-error code</span>

	<span class="n">LPVOID</span> <span class="n">lpMsgBuf</span><span class="p">;</span>
	<span class="n">LPVOID</span> <span class="n">lpDisplayBuf</span><span class="p">;</span>
	<span class="n">DWORD</span> <span class="n">dw</span> <span class="o">=</span> <span class="n">GetLastError</span><span class="p">();</span>

	<span class="n">FormatMessage</span><span class="p">(</span>
		<span class="n">FORMAT_MESSAGE_ALLOCATE_BUFFER</span> <span class="o">|</span>
		<span class="n">FORMAT_MESSAGE_FROM_SYSTEM</span> <span class="o">|</span>
		<span class="n">FORMAT_MESSAGE_IGNORE_INSERTS</span><span class="p">,</span>
		<span class="nb">NULL</span><span class="p">,</span>
		<span class="n">dw</span><span class="p">,</span>
		<span class="n">MAKELANGID</span><span class="p">(</span><span class="n">LANG_NEUTRAL</span><span class="p">,</span> <span class="n">SUBLANG_DEFAULT</span><span class="p">),</span>
		<span class="p">(</span><span class="n">LPTSTR</span><span class="p">)</span><span class="o">&amp;</span><span class="n">lpMsgBuf</span><span class="p">,</span>
		<span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="c1">// Display the error message and exit the process</span>

	<span class="n">lpDisplayBuf</span> <span class="o">=</span> <span class="p">(</span><span class="n">LPVOID</span><span class="p">)</span><span class="n">LocalAlloc</span><span class="p">(</span><span class="n">LMEM_ZEROINIT</span><span class="p">,</span>
		<span class="p">(</span><span class="n">lstrlen</span><span class="p">((</span><span class="n">LPCTSTR</span><span class="p">)</span><span class="n">lpMsgBuf</span><span class="p">)</span> <span class="o">+</span> <span class="n">lstrlen</span><span class="p">((</span><span class="n">LPCTSTR</span><span class="p">)</span><span class="n">lpszFunction</span><span class="p">)</span> <span class="o">+</span> <span class="mi">40</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">TCHAR</span><span class="p">));</span>
	<span class="n">StringCchPrintf</span><span class="p">((</span><span class="n">LPTSTR</span><span class="p">)</span><span class="n">lpDisplayBuf</span><span class="p">,</span>
		<span class="n">LocalSize</span><span class="p">(</span><span class="n">lpDisplayBuf</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">TCHAR</span><span class="p">),</span>
		<span class="n">TEXT</span><span class="p">(</span><span class="s">"%s failed with error %d: %s"</span><span class="p">),</span>
		<span class="n">lpszFunction</span><span class="p">,</span> <span class="n">dw</span><span class="p">,</span> <span class="n">lpMsgBuf</span><span class="p">);</span>
	<span class="c1">//MessageBox(NULL, (LPCTSTR)lpDisplayBuf, TEXT("Error"), MB_OK);</span>
	<span class="n">_tprintf</span><span class="p">(</span><span class="n">TEXT</span><span class="p">(</span><span class="s">"Erro: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">),</span> <span class="p">(</span><span class="n">LPTSTR</span><span class="p">)</span><span class="n">lpDisplayBuf</span><span class="p">);</span>

	<span class="n">LocalFree</span><span class="p">(</span><span class="n">lpMsgBuf</span><span class="p">);</span>
	<span class="n">LocalFree</span><span class="p">(</span><span class="n">lpDisplayBuf</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">exitProcess</span><span class="p">)</span> <span class="n">ExitProcess</span><span class="p">(</span><span class="n">dw</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// função para parsing</span>
<span class="kt">void</span> <span class="nf">ParseSnapshot</span><span class="p">(</span><span class="n">LPPROCESSENTRY32</span> <span class="n">process</span><span class="p">)</span> <span class="p">{</span>

	<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"PID: %d</span><span class="se">\t</span><span class="s">Threads: %d</span><span class="se">\t</span><span class="s">Exe File: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">),</span> <span class="n">process</span><span class="o">-&gt;</span><span class="n">th32ProcessID</span><span class="p">,</span> <span class="n">process</span><span class="o">-&gt;</span><span class="n">cntThreads</span><span class="p">,</span> <span class="n">process</span><span class="o">-&gt;</span><span class="n">szExeFile</span><span class="p">);</span>

<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>

	<span class="c1">// handle para o snapshot</span>
	<span class="n">HANDLE</span> <span class="n">processes</span><span class="p">;</span>

	<span class="c1">// extraindo o snapshot</span>
	<span class="n">processes</span> <span class="o">=</span> <span class="n">CreateToolhelp32Snapshot</span><span class="p">(</span><span class="n">TH32CS_SNAPPROCESS</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">INVALID_HANDLE_VALUE</span> <span class="o">==</span> <span class="n">processes</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">PrintError</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"CreateToolhelp32Snapshot"</span><span class="p">),</span> <span class="nb">true</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="c1">// estrutura PROCESSENTRY32</span>
	<span class="n">PROCESSENTRY32</span> <span class="n">processEntry</span><span class="p">;</span>
	<span class="c1">// inicializando a estrutura PROCESSENTRY32</span>
	<span class="n">processEntry</span><span class="p">.</span><span class="n">dwSize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">PROCESSENTRY32</span><span class="p">);</span>

	<span class="c1">// coletando o primeiro processo da lista</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">Process32First</span><span class="p">(</span><span class="n">processes</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">processEntry</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">PrintError</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"Process32First"</span><span class="p">),</span> <span class="nb">true</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="c1">// iterando a lista</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="c1">// enviando para o parsing</span>
		<span class="n">ParseSnapshot</span><span class="p">(</span><span class="o">&amp;</span><span class="n">processEntry</span><span class="p">);</span>

	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">Process32Next</span><span class="p">(</span><span class="n">processes</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">processEntry</span><span class="p">));</span>

	<span class="n">CloseHandle</span><span class="p">(</span><span class="n">processes</span><span class="p">);</span>

	<span class="n">getchar</span><span class="p">();</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Ao executarmos, temos a listagem de processos:</p><p><img data-proofer-ignore data-src="/img/posts/Pasted%20image%2020240815184407.png" alt="" /></p><p>Obviamente este é um exemplo bem simples, porém as possibilidades documentadas de informações passíveis de extração, nos dá um leque muito grande de informações que podem ser coletadas.</p><h1 id="enumprocesses">EnumProcesses</h1><p>A <a href="https://learn.microsoft.com/en-us/windows/win32/api/psapi/nf-psapi-enumprocesses">EnumProcesses</a> é uma função da <a href="https://learn.microsoft.com/en-us/windows/win32/api/_psapi/">PSAPI</a> (que por sinal, é cheia de excelentes funções) que visa trazer um <em>array</em> com <strong>todos</strong> os PIDs de processos em execução no sistema. Sua sintaxe é bem simples:</p><div lang="cpp" class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="n">BOOL</span> <span class="nf">EnumProcesses</span><span class="p">(</span>
  <span class="p">[</span><span class="n">out</span><span class="p">]</span> <span class="n">DWORD</span>   <span class="o">*</span><span class="n">lpidProcess</span><span class="p">,</span>
  <span class="p">[</span><span class="n">in</span><span class="p">]</span>  <span class="n">DWORD</span>   <span class="n">cb</span><span class="p">,</span>
  <span class="p">[</span><span class="n">out</span><span class="p">]</span> <span class="n">LPDWORD</span> <span class="n">lpcbNeeded</span>
<span class="p">);</span>
</pre></table></code></div></div><p>Onde:</p><ul><li><code class="language-plaintext highlighter-rouge">[out] lpidProcess</code> é um ponteiro para uma <em>array</em> que receberá os PIDs;<li><code class="language-plaintext highlighter-rouge">[in] cb</code> é o tamanho da <em>array</em> em <em>bytes</em>;<li><code class="language-plaintext highlighter-rouge">[out] lpcbNeeded</code> o ponteiro para a variável que receberá a quantidade em <em>bytes</em> da resposta obtida.</ul><p>Tecnicamente é uma função simples, com uma resposta simples, porém, como já vimos durante este artigo, saber o PID de um processo é essencial no <em>process listing</em>, pois, uma vez que temos este valor, podemos utilizar várias outras funções de API para trazer informações relevantes.</p><p>Por exemplo, podemos extrair a <em>array</em> com todos os PIDs, e, durante a iteração com a lista, podemos usar a função <code class="language-plaintext highlighter-rouge">OpenProcess</code> para criar um <em>handle</em> para cada processo, e a partir daí usar a função <a href="https://learn.microsoft.com/en-us/windows/win32/api/psapi/nf-psapi-getprocessimagefilenamea">GetProcessImageFileName</a> para obter o <em>path</em> de cada processo.</p><p>Porém, assim como a API <code class="language-plaintext highlighter-rouge">WTSEnumerateProcessesEx</code>, ela exige o privilégio <code class="language-plaintext highlighter-rouge">SeDebugPrivilege</code> para enumerar processos de privilégio elevado.</p><p>Uma simples implementação seria:</p><div lang="cpp" class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;Windows.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;strsafe.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;Psapi.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;tchar.h&gt;</span><span class="cp">
</span>
<span class="cp">#define MAX_PIDS			4000
#define MAX_FILENAME_LEN	2000
</span>
<span class="kt">void</span> <span class="nf">PrintError</span><span class="p">(</span><span class="n">LPCTSTR</span> <span class="n">lpszFunction</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">exitProcess</span><span class="p">)</span>
<span class="p">{</span>
	<span class="c1">// Retrieve the system error message for the last-error code</span>

	<span class="n">LPVOID</span> <span class="n">lpMsgBuf</span><span class="p">;</span>
	<span class="n">LPVOID</span> <span class="n">lpDisplayBuf</span><span class="p">;</span>
	<span class="n">DWORD</span> <span class="n">dw</span> <span class="o">=</span> <span class="n">GetLastError</span><span class="p">();</span>

	<span class="n">FormatMessage</span><span class="p">(</span>
		<span class="n">FORMAT_MESSAGE_ALLOCATE_BUFFER</span> <span class="o">|</span>
		<span class="n">FORMAT_MESSAGE_FROM_SYSTEM</span> <span class="o">|</span>
		<span class="n">FORMAT_MESSAGE_IGNORE_INSERTS</span><span class="p">,</span>
		<span class="nb">NULL</span><span class="p">,</span>
		<span class="n">dw</span><span class="p">,</span>
		<span class="n">MAKELANGID</span><span class="p">(</span><span class="n">LANG_NEUTRAL</span><span class="p">,</span> <span class="n">SUBLANG_DEFAULT</span><span class="p">),</span>
		<span class="p">(</span><span class="n">LPTSTR</span><span class="p">)</span><span class="o">&amp;</span><span class="n">lpMsgBuf</span><span class="p">,</span>
		<span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="c1">// Display the error message and exit the process</span>

	<span class="n">lpDisplayBuf</span> <span class="o">=</span> <span class="p">(</span><span class="n">LPVOID</span><span class="p">)</span><span class="n">LocalAlloc</span><span class="p">(</span><span class="n">LMEM_ZEROINIT</span><span class="p">,</span>
		<span class="p">(</span><span class="n">lstrlen</span><span class="p">((</span><span class="n">LPCTSTR</span><span class="p">)</span><span class="n">lpMsgBuf</span><span class="p">)</span> <span class="o">+</span> <span class="n">lstrlen</span><span class="p">((</span><span class="n">LPCTSTR</span><span class="p">)</span><span class="n">lpszFunction</span><span class="p">)</span> <span class="o">+</span> <span class="mi">40</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">TCHAR</span><span class="p">));</span>
	<span class="n">StringCchPrintf</span><span class="p">((</span><span class="n">LPTSTR</span><span class="p">)</span><span class="n">lpDisplayBuf</span><span class="p">,</span>
		<span class="n">LocalSize</span><span class="p">(</span><span class="n">lpDisplayBuf</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">TCHAR</span><span class="p">),</span>
		<span class="n">TEXT</span><span class="p">(</span><span class="s">"%s failed with error %d: %s"</span><span class="p">),</span>
		<span class="n">lpszFunction</span><span class="p">,</span> <span class="n">dw</span><span class="p">,</span> <span class="n">lpMsgBuf</span><span class="p">);</span>
	<span class="c1">//MessageBox(NULL, (LPCTSTR)lpDisplayBuf, TEXT("Error"), MB_OK);</span>
	<span class="n">_tprintf</span><span class="p">(</span><span class="n">TEXT</span><span class="p">(</span><span class="s">"Erro: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">),</span> <span class="p">(</span><span class="n">LPTSTR</span><span class="p">)</span><span class="n">lpDisplayBuf</span><span class="p">);</span>

	<span class="n">LocalFree</span><span class="p">(</span><span class="n">lpMsgBuf</span><span class="p">);</span>
	<span class="n">LocalFree</span><span class="p">(</span><span class="n">lpDisplayBuf</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">exitProcess</span><span class="p">)</span> <span class="n">ExitProcess</span><span class="p">(</span><span class="n">dw</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// função para habilitar SeDebugPrivilege</span>
<span class="n">BOOL</span> <span class="nf">EnableSeDebug</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>

	<span class="n">LUID</span> <span class="n">privilegeLuid</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">LookupPrivilegeValue</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">_T</span><span class="p">(</span><span class="s">"SeDebugPrivilege"</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">privilegeLuid</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">PrintError</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"LookupPrivilegeValue()"</span><span class="p">),</span> <span class="nb">true</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="c1">// criando a estrutura do token</span>
	<span class="n">TOKEN_PRIVILEGES</span> <span class="n">tkPrivs</span><span class="p">;</span>

	<span class="n">tkPrivs</span><span class="p">.</span><span class="n">PrivilegeCount</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// quantidade de privilégios a serem configurados</span>
	<span class="n">tkPrivs</span><span class="p">.</span><span class="n">Privileges</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">Luid</span> <span class="o">=</span> <span class="n">privilegeLuid</span><span class="p">;</span> <span class="c1">// LUID do primeiro e único privilégio (SeDebugPrivilege)</span>
	<span class="n">tkPrivs</span><span class="p">.</span><span class="n">Privileges</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">Attributes</span> <span class="o">=</span> <span class="n">SE_PRIVILEGE_ENABLED</span><span class="p">;</span> <span class="c1">// atributo que o privilégio receberá</span>

	<span class="n">HANDLE</span> <span class="n">currentProcessHandle</span> <span class="o">=</span> <span class="n">GetCurrentProcess</span><span class="p">();</span>
	<span class="n">HANDLE</span> <span class="n">processToken</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">OpenProcessToken</span><span class="p">(</span><span class="n">currentProcessHandle</span><span class="p">,</span> <span class="n">TOKEN_ADJUST_PRIVILEGES</span> <span class="o">|</span> <span class="n">TOKEN_QUERY</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">processToken</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">PrintError</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"OpenProcessToken()"</span><span class="p">),</span> <span class="nb">true</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="c1">// coletando o tamanho da estrutura</span>
	<span class="n">DWORD</span> <span class="n">firstStructSize</span><span class="p">;</span>
	<span class="n">GetTokenInformation</span><span class="p">(</span><span class="n">processToken</span><span class="p">,</span> <span class="n">TokenPrivileges</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">firstStructSize</span><span class="p">);</span>

	<span class="c1">// invocando GetTokenInformation() com todos os parâmetros</span>
	<span class="n">DWORD</span> <span class="n">secondStructSize</span><span class="p">;</span> <span class="c1">// variável que receberá o tamanho da resposta na segunda execução</span>
	<span class="n">PTOKEN_PRIVILEGES</span> <span class="n">processTokenPriv</span><span class="p">;</span> <span class="c1">// ponteiro para estrutura TOKEN_PRIVILEGES que receberá a resposta</span>

	<span class="n">processTokenPriv</span> <span class="o">=</span> <span class="p">(</span><span class="n">PTOKEN_PRIVILEGES</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">firstStructSize</span><span class="p">);</span> <span class="c1">// alocando o buffer</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">GetTokenInformation</span><span class="p">(</span><span class="n">processToken</span><span class="p">,</span> <span class="n">TokenPrivileges</span><span class="p">,</span> <span class="n">processTokenPriv</span><span class="p">,</span> <span class="n">firstStructSize</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">secondStructSize</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">PrintError</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"GetTokenInformation()"</span><span class="p">),</span> <span class="nb">true</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="c1">// iterando sobre a estrutura TOKEN_PRIVILEGES</span>
	<span class="n">PLUID_AND_ATTRIBUTES</span> <span class="n">luidStruct</span><span class="p">;</span> <span class="c1">// ponteiro para estrutura que receberá cada membro do array na iteração</span>
	<span class="kt">bool</span> <span class="n">seDebug</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span> <span class="c1">// variável de controle caso o privilégio exista</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">DWORD</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">processTokenPriv</span><span class="o">-&gt;</span><span class="n">PrivilegeCount</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">luidStruct</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">processTokenPriv</span><span class="o">-&gt;</span><span class="n">Privileges</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">luidStruct</span><span class="o">-&gt;</span><span class="n">Luid</span><span class="p">.</span><span class="n">LowPart</span> <span class="o">==</span> <span class="n">privilegeLuid</span><span class="p">.</span><span class="n">LowPart</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">luidStruct</span><span class="o">-&gt;</span><span class="n">Luid</span><span class="p">.</span><span class="n">HighPart</span> <span class="o">==</span> <span class="n">privilegeLuid</span><span class="p">.</span><span class="n">HighPart</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"[+] SeDebugPrivilege encontrada para habilitar!</span><span class="se">\n\n</span><span class="s">"</span><span class="p">));</span>
			<span class="n">seDebug</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// caso não encontre o SeDebugPrivilege</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">seDebug</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"[-] SeDebugPrivilege nao encontrado</span><span class="se">\n</span><span class="s">Execute com privilegios administrativos para enumerar todos os processos!</span><span class="se">\n\n</span><span class="s">"</span><span class="p">));</span>
		<span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">AdjustTokenPrivileges</span><span class="p">(</span><span class="n">processToken</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tkPrivs</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">PrintError</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"AdjustTokenPrivileges()"</span><span class="p">),</span> <span class="nb">true</span><span class="p">);</span>
	<span class="p">}</span>



	<span class="k">return</span> <span class="n">TRUE</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>

	<span class="n">DWORD</span>	<span class="n">pids</span><span class="p">[</span><span class="n">MAX_PIDS</span><span class="p">];</span>
	<span class="n">DWORD</span>	<span class="n">cbNeeded</span><span class="p">;</span>
	<span class="n">DWORD</span>	<span class="n">numberProc</span><span class="p">;</span>
	<span class="n">HANDLE</span>	<span class="n">processHandle</span><span class="p">;</span>
	<span class="n">TCHAR</span>	<span class="n">fileName</span><span class="p">[</span><span class="n">MAX_FILENAME_LEN</span><span class="p">];</span>

	<span class="c1">// habilitando SeDebugPrivileges</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">EnableSeDebug</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"[-] Nao foi possivel habilitar privilegio de debug!</span><span class="se">\n</span><span class="s">[-] Alguns processos nao serao enumerados!</span><span class="se">\n\n</span><span class="s">"</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"[+] Adicionando privilegio de debug!</span><span class="se">\n\n</span><span class="s">"</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="c1">// Obtendo os PIDs</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">EnumProcesses</span><span class="p">(</span><span class="n">pids</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">pids</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">cbNeeded</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">PrintError</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"EnumProcesses()"</span><span class="p">),</span> <span class="nb">true</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">numberProc</span> <span class="o">=</span> <span class="n">cbNeeded</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">DWORD</span><span class="p">);</span>

	<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"#</span><span class="se">\t</span><span class="s">PID</span><span class="se">\t</span><span class="s">Process Image</span><span class="se">\n\n</span><span class="s">"</span><span class="p">));</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">DWORD</span> <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">counter</span> <span class="o">&lt;</span> <span class="n">numberProc</span><span class="p">;</span> <span class="n">counter</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

		<span class="c1">// pulando PID 0</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pids</span><span class="p">[</span><span class="n">counter</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>

		<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"%d</span><span class="se">\t</span><span class="s">%d</span><span class="se">\t</span><span class="s">"</span><span class="p">),</span> <span class="n">counter</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">pids</span><span class="p">[</span><span class="n">counter</span><span class="p">]);</span>

		<span class="c1">// obtendo o handle do processo</span>
		<span class="n">processHandle</span> <span class="o">=</span> <span class="n">OpenProcess</span><span class="p">(</span><span class="n">PROCESS_QUERY_LIMITED_INFORMATION</span><span class="p">,</span> <span class="n">FALSE</span><span class="p">,</span> <span class="n">pids</span><span class="p">[</span><span class="n">counter</span><span class="p">]);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">processHandle</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">PrintError</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"OpenProcess()"</span><span class="p">),</span> <span class="nb">false</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">else</span> <span class="p">{</span>

			<span class="c1">// obtendo o nome do processo</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">GetProcessImageFileName</span><span class="p">(</span><span class="n">processHandle</span><span class="p">,</span> <span class="n">fileName</span><span class="p">,</span> <span class="n">MAX_FILENAME_LEN</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>

				<span class="n">PrintError</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"GetProcessImageFileName()"</span><span class="p">),</span> <span class="nb">false</span><span class="p">);</span>
				<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"-</span><span class="se">\n</span><span class="s">"</span><span class="p">));</span>
			<span class="p">}</span>
			<span class="k">else</span> <span class="p">{</span>

				<span class="c1">// pulando PID 0</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">pids</span><span class="p">[</span><span class="n">counter</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>

					<span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"%s</span><span class="se">\n</span><span class="s">"</span><span class="p">),</span> <span class="n">fileName</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">getchar</span><span class="p">();</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Quando executamos o programa como usuário comum, vemos que não foi possível habilitar o <code class="language-plaintext highlighter-rouge">SeDebugPrivilege</code> e houve erro na enumeração de processos elevados.</p><p><img data-proofer-ignore data-src="/img/posts/Pasted%20image%2020240815211153.png" alt="" /></p><p>Já quando executamos como administrador, o <code class="language-plaintext highlighter-rouge">SeDebugPrivilege</code> é habilitado e quase todos os processos retornam o <em>Process Image</em>.</p><p><img data-proofer-ignore data-src="/img/posts/Pasted%20image%2020240815211358.png" alt="" /></p><p>O fato do erro ter acontecido ao tentar enumerar o <em>Process Image</em> neste processo, não é necessariamente um erro. Se analisarmos o <strong>PID 4</strong> com o <em>Process Explorer</em> veremos que o processo é o <em>System</em>.</p><p><img data-proofer-ignore data-src="/img/posts/Pasted%20image%2020240815211632.png" alt="" /></p><p>Quando expandimos as propriedades deste processo, vemos que ele não tem um <em>path</em>.</p><p><img data-proofer-ignore data-src="/img/posts/Pasted%20image%2020240815211721.png" alt="" /></p><p>Logo, o erro retornado, não é um erro de código de fato, ela não conseguiu trazer o <em>path</em>, pois ele realmente não existe. nada que não possa ser tratado para melhorar a resposta do programa.</p><h1 id="conclusão">Conclusão</h1><p>Neste artigo, exploramos diversas técnicas para listagem de processos e <em>token dumping</em> utilizando APIs do Windows, destacando a flexibilidade e o poder dessas abordagens no contexto de exploração e análise de sistemas. Através do uso de funções como <code class="language-plaintext highlighter-rouge">WTSEnumerateProcessesEx</code> e outros métodos abordados, vimos como é possível obter informações detalhadas sobre os processos em execução em um ambiente Windows, identificando não apenas o contexto em que eles operam, mas também as permissões associadas e os tokens de segurança em uso.</p><p>Essas técnicas, quando aplicadas de forma estratégica, podem ser combinadas para criar ferramentas mais robustas e eficientes, capazes de superar restrições impostas pelo ambiente alvo. A compreensão detalhada do funcionamento dessas APIs não só amplia o leque de possibilidades durante um exercício de pentesting ou análise forense, mas também destaca a importância de uma abordagem criativa e adaptável ao enfrentarmos diferentes cenários.</p><p>Além disso, ao utilizar diferentes abordagens para realizar tarefas aparentemente simples, como a listagem de processos, garantimos uma maior resiliência das ferramentas desenvolvidas, uma vez que a diversidade de métodos torna mais difícil para mecanismos de defesa automatizados preverem ou bloquearem tais ações. Esta capacidade de adaptação é crucial em um cenário de segurança cibernética onde as técnicas e contramedidas estão em constante evolução.</p><p>O domínio das APIs discutidas não apenas facilita a execução de tarefas essenciais para reconhecimento e exploração, mas também abre caminho para a criação de soluções customizadas e inovadoras que podem fazer a diferença em situações críticas. A exploração contínua dessas e outras funções oferecidas pelo Windows é essencial para qualquer profissional que busca aprofundar seus conhecimentos e habilidades em cibersegurança.</p><h1 id="referências">Referências</h1><ul><li><a href="https://learn.microsoft.com/en-us/windows/win32/toolhelp/tool-help-library">https://learn.microsoft.com/en-us/windows/win32/toolhelp/tool-help-library</a><li><a href="https://learn.microsoft.com/en-us/windows/win32/api/wtsapi32/nf-wtsapi32-wtsenumerateprocessesexa">https://learn.microsoft.com/en-us/windows/win32/api/wtsapi32/nf-wtsapi32-wtsenumerateprocessesexa</a><li><a href="https://learn.microsoft.com/en-us/windows/win32/api/wtsapi32/nf-wtsapi32-wtsopenservera">https://learn.microsoft.com/en-us/windows/win32/api/wtsapi32/nf-wtsapi32-wtsopenservera</a><li><a href="https://learn.microsoft.com/en-us/windows/win32/api/wtsapi32/ns-wtsapi32-wts_process_infoa">https://learn.microsoft.com/en-us/windows/win32/api/wtsapi32/ns-wtsapi32-wts_process_infoa</a><li><a href="https://learn.microsoft.com/en-us/windows/win32/api/wtsapi32/ns-wtsapi32-wts_process_info_exa">https://learn.microsoft.com/en-us/windows/win32/api/wtsapi32/ns-wtsapi32-wts_process_info_exa</a><li><a href="https://learn.microsoft.com/en-us/windows/win32/api/wtsapi32/nf-wtsapi32-wtsfreememoryexa">https://learn.microsoft.com/en-us/windows/win32/api/wtsapi32/nf-wtsapi32-wtsfreememoryexa</a><li><a href="https://learn.microsoft.com/en-us/sysinternals/">https://learn.microsoft.com/en-us/sysinternals/</a><li><a href="https://learn.microsoft.com/en-us/windows/win32/api/sddl/nf-sddl-convertsidtostringsida">https://learn.microsoft.com/en-us/windows/win32/api/sddl/nf-sddl-convertsidtostringsida</a><li><a href="https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-localfree">https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-localfree</a><li><a href="https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-lookupaccountsida">https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-lookupaccountsida</a><li><a href="https://learn.microsoft.com/en-us/windows/win32/api/winnt/ne-winnt-sid_name_use">https://learn.microsoft.com/en-us/windows/win32/api/winnt/ne-winnt-sid_name_use</a><li><a href="https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-openprocesstoken">https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-openprocesstoken</a><li><a href="https://learn.microsoft.com/en-us/windows/win32/api/securitybaseapi/nf-securitybaseapi-gettokeninformation">https://learn.microsoft.com/en-us/windows/win32/api/securitybaseapi/nf-securitybaseapi-gettokeninformation</a><li><a href="https://learn.microsoft.com/en-us/windows/win32/api/securitybaseapi/nf-securitybaseapi-settokeninformation">https://learn.microsoft.com/en-us/windows/win32/api/securitybaseapi/nf-securitybaseapi-settokeninformation</a><li><a href="https://learn.microsoft.com/en-us/windows/win32/api/securitybaseapi/nf-securitybaseapi-adjusttokenprivileges">https://learn.microsoft.com/en-us/windows/win32/api/securitybaseapi/nf-securitybaseapi-adjusttokenprivileges</a><li><a href="https://learn.microsoft.com/en-us/windows/win32/api/securitybaseapi/nf-securitybaseapi-duplicatetokenex">https://learn.microsoft.com/en-us/windows/win32/api/securitybaseapi/nf-securitybaseapi-duplicatetokenex</a><li><a href="https://learn.microsoft.com/en-us/windows/win32/api/securitybaseapi/nf-securitybaseapi-impersonateloggedonuser">https://learn.microsoft.com/en-us/windows/win32/api/securitybaseapi/nf-securitybaseapi-impersonateloggedonuser</a><li><a href="https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-lookupprivilegevaluea">https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-lookupprivilegevaluea</a><li><a href="https://learn.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-token_privileges">https://learn.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-token_privileges</a><li><a href="https://learn.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-luid_and_attributes">https://learn.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-luid_and_attributes</a><li><a href="https://learn.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-privilege_set">https://learn.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-privilege_set</a><li><a href="https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-openprocesstoken">https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-openprocesstoken</a><li><a href="https://learn.microsoft.com/en-us/windows/win32/api/securitybaseapi/nf-securitybaseapi-adjusttokenprivileges">https://learn.microsoft.com/en-us/windows/win32/api/securitybaseapi/nf-securitybaseapi-adjusttokenprivileges</a><li><a href="https://learn.microsoft.com/en-us/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">https://learn.microsoft.com/en-us/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror</a><li><a href="https://learn.microsoft.com/en-us/windows/win32/api/securitybaseapi/nf-securitybaseapi-gettokeninformation">https://learn.microsoft.com/en-us/windows/win32/api/securitybaseapi/nf-securitybaseapi-gettokeninformation</a><li><a href="https://learn.microsoft.com/en-us/windows/win32/api/winnt/ne-winnt-token_information_class">https://learn.microsoft.com/en-us/windows/win32/api/winnt/ne-winnt-token_information_class</a><li><a href="https://learn.microsoft.com/en-us/windows/win32/api/shellapi/nf-shellapi-shellexecuteexa">https://learn.microsoft.com/en-us/windows/win32/api/shellapi/nf-shellapi-shellexecuteexa</a><li><a href="https://learn.microsoft.com/en-us/windows/win32/api/shellapi/ns-shellapi-shellexecuteinfoa">https://learn.microsoft.com/en-us/windows/win32/api/shellapi/ns-shellapi-shellexecuteinfoa</a><li><a href="https://learn.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-getmodulefilenamea">https://learn.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-getmodulefilenamea</a><li><a href="https://learn.microsoft.com/en-us/windows/win32/procthread/process-security-and-access-rights">https://learn.microsoft.com/en-us/windows/win32/procthread/process-security-and-access-rights</a><li><a href="https://learn.microsoft.com/en-us/windows/win32/api/tlhelp32/nf-tlhelp32-createtoolhelp32snapshot">https://learn.microsoft.com/en-us/windows/win32/api/tlhelp32/nf-tlhelp32-createtoolhelp32snapshot</a><li><a href="https://ioactive.com/pdfs/ZeusSpyEyeBankingTrojanAnalysis.pdf">https://ioactive.com/pdfs/ZeusSpyEyeBankingTrojanAnalysis.pdf</a><li><a href="https://documents.trendmicro.com/assets/wp/wp-pos-ram-scraper-malware.pdf">https://documents.trendmicro.com/assets/wp/wp-pos-ram-scraper-malware.pdf</a><li><a href="https://learn.microsoft.com/en-us/windows/win32/api/psapi/nf-psapi-enumprocesses">https://learn.microsoft.com/en-us/windows/win32/api/psapi/nf-psapi-enumprocesses</a><li><a href="https://learn.microsoft.com/en-us/windows/win32/api/_psapi/">https://learn.microsoft.com/en-us/windows/win32/api/_psapi/</a><li><a href="https://learn.microsoft.com/en-us/windows/win32/api/psapi/nf-psapi-getprocessimagefilenamea">https://learn.microsoft.com/en-us/windows/win32/api/psapi/nf-psapi-getprocessimagefilenamea</a></ul></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/estudos/'>Estudos</a>, <a href='/categories/winapi/'>WinAPI</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/shellcoding/" class="post-tag no-text-decoration" >Shellcoding</a> <a href="/tags/shellcode/" class="post-tag no-text-decoration" >Shellcode</a> <a href="/tags/windows-api/" class="post-tag no-text-decoration" >Windows API</a> <a href="/tags/kernel/" class="post-tag no-text-decoration" >Kernel</a> <a href="/tags/winapi/" class="post-tag no-text-decoration" >WinAPI</a> <a href="/tags/process-listing/" class="post-tag no-text-decoration" >Process Listing</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Process Listing e Token Dumping com WinAPI - H41stur&url=https://h41stur.github.io/posts/process-listing/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Process Listing e Token Dumping com WinAPI - H41stur&u=https://h41stur.github.io/posts/process-listing/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Process Listing e Token Dumping com WinAPI - H41stur&url=https://h41stur.github.io/posts/process-listing/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://www.linkedin.com/sharing/share-offsite/?url=https://h41stur.github.io/posts/process-listing/" data-toggle="tooltip" data-placement="top" title="Linkedin" target="_blank" rel="noopener" aria-label="Linkedin"> <i class="fa-fw fab fa-linkedin"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink('', 'Link copied successfully!')" data-toggle="tooltip" data-placement="top" title="Copy link"> </i> </span></div></div></div></div><div> <script src="https://utteranc.es/client.js" repo="h41stur/h41stur.github.io" issue-term="url" theme="photon-dark" crossorigin="anonymous" async> </script></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/process-injection/">Process Injection 101</a><li><a href="/posts/evasao-av/">Evasão de Antivírus - Princípios Gerais e Abordagens Específicas</a><li><a href="/posts/paper-heap/">Heap Exploitation P.1</a><li><a href="/posts/shellcoding101/">Shellcoding 101</a><li><a href="/posts/replay-sinal-rf/">Uma Jornada no Hardware Hacking: Criando um Clonador de Sinais RF</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/linux/">Linux</a> <a class="post-tag" href="/tags/windows/">Windows</a> <a class="post-tag" href="/tags/assembly/">Assembly</a> <a class="post-tag" href="/tags/binary-exploitation/">Binary Exploitation</a> <a class="post-tag" href="/tags/buffer-overflow/">Buffer Overflow</a> <a class="post-tag" href="/tags/web/">Web</a> <a class="post-tag" href="/tags/htb/">HTB</a> <a class="post-tag" href="/tags/vulnserver/">Vulnserver</a> <a class="post-tag" href="/tags/android/">Android</a> <a class="post-tag" href="/tags/kernel/">Kernel</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/get-process/"><div class="card-body"> <span class="timeago small" >Aug 6, 2024<i class="unloaded">2024-08-06T01:00:00-03:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Enumerando Processos pelo Nome</h3><div class="text-muted small"><p> TL;DR Neste artigo, exploramos como utilizar as APIs do Windows para enumerar processos em execução, focando nas funções CreateToolhelp32Snapshot, Process32First e Process32Next. Discutimos a im...</p></div></div></a></div><div class="card"> <a href="/posts/process-injection/"><div class="card-body"> <span class="timeago small" >Aug 7, 2024<i class="unloaded">2024-08-07T01:00:00-03:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Process Injection 101</h3><div class="text-muted small"><p> TL;DR Neste artigo, exploramos a técnica de Process Injection, uma abordagem avançada que permite a injeção de código em processos legítimos em execução. Amplamente utilizada em cenários de segu...</p></div></div></a></div><div class="card"> <a href="/posts/shellcoding101/"><div class="card-body"> <span class="timeago small" >Jul 18, 2024<i class="unloaded">2024-07-18T01:00:00-03:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Shellcoding 101</h3><div class="text-muted small"><p> TL;DR Neste artigo, exploramos os fundamentos do desenvolvimento de shellcodes, focando principalmente no ambiente Windows e na manipulação de endereços dinâmicos. O shellcoding envolve escrever...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/process-injection/" class="btn btn-outline-primary" prompt="Older"><p>Process Injection 101</p></a> <span class="btn btn-outline-primary disabled" prompt="Newer"><p>-</p></span></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://github.com/h41stur">H41stur</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/linux/">Linux</a> <a class="post-tag" href="/tags/windows/">Windows</a> <a class="post-tag" href="/tags/assembly/">Assembly</a> <a class="post-tag" href="/tags/binary-exploitation/">Binary Exploitation</a> <a class="post-tag" href="/tags/buffer-overflow/">Buffer Overflow</a> <a class="post-tag" href="/tags/web/">Web</a> <a class="post-tag" href="/tags/htb/">HTB</a> <a class="post-tag" href="/tags/vulnserver/">Vulnserver</a> <a class="post-tag" href="/tags/android/">Android</a> <a class="post-tag" href="/tags/kernel/">Kernel</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://h41stur.github.io{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.16.1,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id="></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', ''); }); </script>
