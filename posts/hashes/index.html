<!DOCTYPE html><html lang="en" mode="dark" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="day-prompt" content="days ago"><meta name="hour-prompt" content="hours ago"><meta name="minute-prompt" content="minutes ago"><meta name="justnow-prompt" content="just now"><meta name="generator" content="Jekyll v4.3.4" /><meta property="og:title" content="Integridade e Autenticidade: Como Algoritmos de Hash Moldam a Segurança Digital" /><meta name="author" content="H41stur" /><meta property="og:locale" content="en" /><meta name="description" content="“Strange is the night where black stars rise, and strange moons circle through the skies, but stranger still is lost Carcosa.”" /><meta property="og:description" content="“Strange is the night where black stars rise, and strange moons circle through the skies, but stranger still is lost Carcosa.”" /><link rel="canonical" href="https://h41stur.github.io/posts/hashes/" /><meta property="og:url" content="https://h41stur.github.io/posts/hashes/" /><meta property="og:site_name" content="H41stur" /><meta property="og:image" content="https://h41stur.github.io/img/posts/hash.png" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2024-04-19T01:00:00-03:00" /><meta name="twitter:card" content="summary_large_image" /><meta property="twitter:image" content="https://h41stur.github.io/img/posts/hash.png" /><meta property="twitter:title" content="Integridade e Autenticidade: Como Algoritmos de Hash Moldam a Segurança Digital" /><meta name="twitter:site" content="@twitter_username" /><meta name="twitter:creator" content="@H41stur" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"H41stur"},"dateModified":"2024-04-19T14:08:46-03:00","datePublished":"2024-04-19T01:00:00-03:00","description":"“Strange is the night where black stars rise, and strange moons circle through the skies, but stranger still is lost Carcosa.”","headline":"Integridade e Autenticidade: Como Algoritmos de Hash Moldam a Segurança Digital","image":"https://h41stur.github.io/img/posts/hash.png","mainEntityOfPage":{"@type":"WebPage","@id":"https://h41stur.github.io/posts/hashes/"},"url":"https://h41stur.github.io/posts/hashes/"}</script><title>Integridade e Autenticidade: Como Algoritmos de Hash Moldam a Segurança Digital | H41stur</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="H41stur"><meta name="application-name" content="H41stur"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end" lang="en"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="https://h41stur.github.io/img/h41stur.jpeg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">H41stur</a></div><div class="site-subtitle font-italic">Strange is the night where black stars rise, and strange moons circle through the skies, but stranger still is lost Carcosa.</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIAS</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARQUIVO</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>SOBRE</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/h41stur" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['leonardor.toledo','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="https://www.linkedin.com/in/leo-toledo/" aria-label="linkedin" target="_blank" rel="noopener"> <i class="fab fa-linkedin"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>Integridade e Autenticidade: Como Algoritmos de Hash Moldam a Segurança Digital</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Integridade e Autenticidade: Como Algoritmos de Hash Moldam a Segurança Digital</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> H41stur </span> on <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Fri, Apr 19, 2024, 1:00 AM -0300" >Apr 19, 2024<i class="unloaded">2024-04-19T01:00:00-03:00</i> </span></div><div> <span> Updated <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Fri, Apr 19, 2024, 2:08 PM -0300" >Apr 19, 2024<i class="unloaded">2024-04-19T14:08:46-03:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="6241 words">34 min read</span></div></div><div class="post-content"><p><img data-proofer-ignore data-src="/img/posts/hash.png" alt="Como Algoritmos de Hash Moldam a Segurança Digital" /></p><h1 id="tldr">TL;DR</h1><p>Este artigo explora os fundamentos e aplicações práticas dos algoritmos de hash na cibersegurança, abrangendo:</p><ul><li><strong>Definição e Funcionamento</strong>: Uma visão geral de como os hashes transformam dados de qualquer tamanho em uma pequena impressão digital única.<li><strong>Algoritmos Comuns</strong>: Discussão detalhada sobre MD5, SHA-1, SHA-256, SHA-3, e bcrypt, incluindo suas vantagens, vulnerabilidades e usos ideais.<li><strong>Árvores de Merkle</strong>: Explicação sobre como essas estruturas funcionam e seu papel essencial em tecnologias como blockchain.<li><strong>Implementações Práticas</strong>: Dicas sobre como implementar e utilizar hashes de forma segura em sistemas e aplicações, incluindo como verificar a integridade dos dados e proteger informações sensíveis.</ul><p>O objetivo é fornecer uma compreensão abrangente que possa orientar escolhas informadas e seguras no uso de algoritmos de hash em projetos de TI e segurança de dados.</p><h1 id="introdução">Introdução</h1><p>Os <em>hashes</em> no dia-a-dia de cibersegurança é um assunto que, na maioria das vezes, é trivial, se limitando rasamente a senhas armazenadas e validação de arquivos. Porém, o entendimento de seu mecanismo (não necessariamente o domínio de seus modelos matemáticos complexos) leva a compreensão de seu uso e exploração de suas implementações (ou má implementações) que vão muito além do habitual discutido, passando até mesmo pela parte fundamental da cadeia <em>blockchain</em>. Este artigo foi escrito com o intuito de compartilhar meu centavo de conhecimento sobre o assunto de forma a contribuir um pouco mais com o entendimento dos principais algoritmos encontrados <em>in the wild</em>.</p><p>Algoritmos de <em>hash</em> são uma classe fundamental de funções usadas amplamente em computação e sistemas de segurança cibernética. Essencialmente, um algoritmo de <em>hash</em> é uma função que mapeia dados de tamanho arbitrário (“<em>inputs</em>”) para um conjunto de dados de tamanho fixo, conhecidos como “<em>hash</em>”. O resultado deste mapeamento, ou o valor de <em>hash</em>, é uma representação digital compacta do dado original.</p><p>O principal propósito dos algoritmos de <em>hash</em> é garantir a integridade dos dados, permitindo a verificação rápida de que o conteúdo não foi alterado desde a criação do <em>hash</em>. Isso é crucial em diversas aplicações, como na verificação de integridade de software durante downloads, na autenticação de usuários mediante a comparação de senhas <em>hashadas</em>, e na implementação de estruturas de dados eficientes como tabelas <em>hash</em> e <strong>árvores Merkle</strong>.</p><p>O uso adequado de algoritmos de <em>hash</em> contribui significativamente para a robustez dos sistemas de segurança, servindo como a primeira linha de defesa contra muitas formas de ataque cibernético que visam comprometer a integridade dos dados.</p><h1 id="árvores-de-merkle">Árvores de Merkle</h1><p>As árvores de Merkle, também conhecidas como árvores <em>hash</em> ou árvores de Merkle-Damgård, são uma estrutura de dados fundamental na criptografia e ciência da computação, usadas amplamente em sistemas de gerenciamento de dados distribuídos, como <em>blockchain</em> e sistemas de controle de versão.</p><p>Uma árvore de Merkle é uma árvore binária que permite a representação eficiente e segura de grandes conjuntos de dados, onde cada folha da árvore é um <em>hash</em> de blocos de dados e cada nó interno é um <em>hash</em> das concatenações dos <em>hashes</em> de seus nós filhos. A raiz da árvore, chamada de “raiz de Merkle”, atua como um resumo digital de todos os dados abaixo dela.</p><h2 id="funcionamento">Funcionamento</h2><p>O funcionamento das árvores de Merkle pode ser descrito nas seguintes etapas:</p><ol><li><p><strong><em>Hashing</em> dos Dados:</strong> Inicialmente, pequenos blocos de dados são <em>hashados</em> individualmente. Estes <em>hashes</em> formam as folhas da árvore.</p><li><p><strong>Construção da Árvore:</strong> A partir das folhas, a árvore é construída de baixo para cima. Cada nó na árvore é o <em>hash</em> da concatenação dos <em>hashes</em> de seus dois nós filhos. Esse processo continua até que apenas um nó (a raiz de Merkle) represente todos os dados.</p><li><p><strong>Atualizações e Validações:</strong> Quando os dados são atualizados, apenas o caminho do dado alterado até a raiz precisa ser recalculado, economizando tempo e recursos computacionais. Para validar um conjunto de dados, basta verificar se o <em>hash</em> na raiz ainda representa corretamente todos os dados abaixo dela.</p></ol><p>Esta lógica pode ser facilmente implementada em programação, em <strong>qualquer</strong> linguagem, podemos utilizar a biblioteca <code class="language-plaintext highlighter-rouge">hashlib</code> do Python para implementá-la:</p><div lang="python" class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
</pre><td class="rouge-code"><pre><span class="kn">import</span> <span class="n">hashlib</span>

<span class="k">def</span> <span class="nf">hash_dados</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="sh">"""</span><span class="s">Hash uma string usando SHA-256 e retorna o digesto hexadecimal.</span><span class="sh">"""</span>
    <span class="n">hasher</span> <span class="o">=</span> <span class="n">hashlib</span><span class="p">.</span><span class="nf">sha256</span><span class="p">()</span>
    <span class="n">hasher</span><span class="p">.</span><span class="nf">update</span><span class="p">(</span><span class="n">data</span><span class="p">.</span><span class="nf">encode</span><span class="p">(</span><span class="sh">'</span><span class="s">utf-8</span><span class="sh">'</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">hasher</span><span class="p">.</span><span class="nf">hexdigest</span><span class="p">()</span>

<span class="k">class</span> <span class="nc">ArvoreMerkle</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">folhas</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">self</span><span class="p">.</span><span class="n">niveis</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">adiciona_folha</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sh">"""</span><span class="s">Adiciona um bloco de dados à árvore criando uma nova folha.</span><span class="sh">"""</span>
        <span class="n">dado_hash</span> <span class="o">=</span> <span class="nf">hash_dados</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">folhas</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">dado_hash</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="nf">constroi_arvore</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">constroi_arvore</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="sh">"""</span><span class="s">Método privado para construir a árvore a partir das folhas atuais.</span><span class="sh">"""</span>
        <span class="n">niveis</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">folhas</span><span class="p">]</span>
        <span class="k">while</span> <span class="nf">len</span><span class="p">(</span><span class="n">niveis</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">novo_nivel</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="c1"># Emparelhar e criar o hash dos pais
</span>            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nf">len</span><span class="p">(</span><span class="n">niveis</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="mi">2</span><span class="p">):</span>
                <span class="n">esquerda</span> <span class="o">=</span> <span class="n">niveis</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
                <span class="n">direita</span> <span class="o">=</span> <span class="n">niveis</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="nf">len</span><span class="p">(</span><span class="n">niveis</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="k">else</span> <span class="n">esquerda</span>  <span class="c1"># Duplica o último se número ímpar de folhas
</span>                <span class="n">novo_nivel</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="nf">hash_dados</span><span class="p">(</span><span class="n">esquerda</span> <span class="o">+</span> <span class="n">direita</span><span class="p">))</span>
            <span class="n">niveis</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">novo_nivel</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">niveis</span> <span class="o">=</span> <span class="n">niveis</span>

    <span class="k">def</span> <span class="nf">get_raiz</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="sh">"""</span><span class="s">Retorna a raiz da árvore de Merkle.</span><span class="sh">"""</span>
        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">niveis</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">niveis</span> <span class="k">else</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">verifica_folha</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">indice_folha</span><span class="p">):</span>
        <span class="sh">"""</span><span class="s">Verifica uma folha e seus dados recalculando até a raiz.</span><span class="sh">"""</span>
        <span class="k">if</span> <span class="n">indice_folha</span> <span class="o">&gt;=</span> <span class="nf">len</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">folhas</span><span class="p">)</span> <span class="ow">or</span> <span class="n">indice_folha</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="n">hash_atual</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">folhas</span><span class="p">[</span><span class="n">indice_folha</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">niveis</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="c1"># Determinar o índice do irmão
</span>            <span class="n">indice_irmao</span> <span class="o">=</span> <span class="n">indice_folha</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">indice_folha</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">indice_folha</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">indice_irmao</span> <span class="o">&gt;=</span> <span class="nf">len</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">niveis</span><span class="p">[</span><span class="n">i</span><span class="p">]):</span>
                <span class="n">indice_irmao</span> <span class="o">=</span> <span class="n">indice_folha</span>  <span class="c1"># Se fora de limite, usar o próprio hash
</span>            <span class="n">hash_irmao</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">niveis</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">indice_irmao</span><span class="p">]</span>
            <span class="c1"># Calcular o hash do pai
</span>            <span class="k">if</span> <span class="n">indice_folha</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">hash_atual</span> <span class="o">=</span> <span class="nf">hash_dados</span><span class="p">(</span><span class="n">hash_atual</span> <span class="o">+</span> <span class="n">hash_irmao</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">hash_atual</span> <span class="o">=</span> <span class="nf">hash_dados</span><span class="p">(</span><span class="n">hash_irmao</span> <span class="o">+</span> <span class="n">hash_atual</span><span class="p">)</span>
            <span class="n">indice_folha</span> <span class="o">//=</span> <span class="mi">2</span>
        <span class="k">return</span> <span class="n">hash_atual</span> <span class="o">==</span> <span class="n">self</span><span class="p">.</span><span class="nf">get_raiz</span><span class="p">()</span>

<span class="c1"># Exemplo de uso
</span><span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="sh">"</span><span class="s">__main__</span><span class="sh">"</span><span class="p">:</span>
    <span class="n">arvore</span> <span class="o">=</span> <span class="nc">ArvoreMerkle</span><span class="p">()</span>
    <span class="n">blocos_de_dados</span> <span class="o">=</span> <span class="p">[</span><span class="sh">"</span><span class="s">bloco1</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">bloco2</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">bloco3</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">bloco4</span><span class="sh">"</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">bloco</span> <span class="ow">in</span> <span class="n">blocos_de_dados</span><span class="p">:</span>
        <span class="n">arvore</span><span class="p">.</span><span class="nf">adiciona_folha</span><span class="p">(</span><span class="n">bloco</span><span class="p">)</span>

    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">Raiz da Merkle:</span><span class="sh">"</span><span class="p">,</span> <span class="n">arvore</span><span class="p">.</span><span class="nf">get_raiz</span><span class="p">())</span>
    <span class="c1"># Verificando o terceiro bloco ('bloco3')
</span>    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">Verificação do bloco3:</span><span class="sh">"</span><span class="p">,</span> <span class="n">arvore</span><span class="p">.</span><span class="nf">verifica_folha</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>

</pre></table></code></div></div><p>Onde:</p><ul><li><strong>hash_dados</strong>: Esta função recebe uma <em>string</em> como entrada e aplica uma função de hash SHA-256, retornando o resultado em hexadecimal.<li><strong>ArvoreMerkle</strong>: É a classe que representa a árvore de Merkle. Ela mantém uma lista de <em>hashes</em> das folhas e uma lista de níveis que representam os diferentes níveis da árvore até a raiz.<li><strong>adiciona_folha</strong>: Adiciona uma nova folha à árvore. Cada folha é um <em>hash</em> dos dados fornecidos.<li><strong>constroi_arvore</strong>: Constrói a árvore combinando os <em>hashes</em> das folhas e formando novos níveis até que apenas um <em>hash</em>, a raiz, reste.<li><strong>get_raiz</strong>: Retorna o <em>hash</em> na raiz da árvore, que é o <em>hash</em> que representa todos os dados.<li><strong>verifica_folha</strong>: Verifica se os dados de uma folha específica são consistentes com a raiz da árvore, efetuando o recalculo a partir da folha até a raiz.</ul><h3 id="integração-da-árvore-de-merkle-em-blockchain">Integração da Árvore de Merkle em <em>Blockchain</em></h3><ol><li><p><strong>Organização dos Blocos</strong>:</p><ul><li>Em um <em>blockchain</em>, cada bloco contém um conjunto de transações. Para cada bloco, uma árvore de Merkle é construída usando as transações como folhas. Isto é, cada transação é primeiro <em>hashada</em>, e esses <em>hashes</em> são usados como folhas na árvore de Merkle.</ul><li><p><strong>Criação da Raiz de Merkle</strong>:</p><ul><li>Os <em>hashes</em> das transações (folhas) são então combinados e <em>hashados</em> repetidamente em pares, formando a estrutura de árvore até que um único <em>hash</em>, a “raiz de Merkle”, seja formado. Esta raiz é um resumo de todas as transações no bloco e é armazenada no cabeçalho do bloco junto com outros elementos, como o <em>hash</em> do bloco anterior, <em>timestamp</em>, e <em>nonce</em>.</ul><li><p><strong>Verificação de Transações</strong>:</p><ul><li>Quando um nó na rede <em>blockchain</em> precisa verificar a existência e integridade de uma transação específica, ele pode fazer isso sem baixar todas as transações de um bloco. Em vez disso, o nó pode simplesmente obter o caminho necessário dos <em>hashes</em> que levam da transação (folha) até a raiz de Merkle. Este caminho é conhecido como “prova de Merkle”.</ul><li><p><strong>Prova de Merkle</strong>:</p><ul><li>Para verificar uma transação, o nó só precisa da transação em questão, da raiz de Merkle do bloco (que é publicamente conhecida e armazenada no cabeçalho do bloco) e da sequência de <em>hashes</em> do caminho de Merkle. Se, ao recombinar os <em>hashes</em> no caminho com o <em>hash</em> da transação original, o nó chegar à raiz de Merkle que corresponde à raiz armazenada no cabeçalho do bloco, a transação é confirmada como válida e não alterada.</ul></ol><h3 id="exemplo-prático-de-uso-em-blockchain">Exemplo Prático de Uso em <em>Blockchain</em></h3><p>Suponhamos que queremos verificar a transação “bloco3” no <em>blockchain</em>:</p><ul><li>A transação é <em>hashada</em>, e junto com os <em>hashes</em> necessários dos irmãos no caminho para a raiz, é reconstruída a árvore até o topo.<li>Se a reconstrução chegar à mesma raiz de Merkle que está no cabeçalho do bloco, a transação é considerada válida e integra. Isso é feito sem a necessidade de processar ou mesmo conhecer todas as outras transações no bloco.</ul><h3 id="benefícios-no-blockchain">Benefícios no Blockchain</h3><ul><li><strong>Eficiência</strong>: A verificação de transações pode ser realizada rapidamente e com um mínimo de dados necessários, ideal para redes descentralizadas onde a largura de banda e o armazenamento podem ser limitados.<li><strong>Segurança</strong>: A raiz de Merkle fornece um resumo criptográfico seguro de todas as transações, garantindo que qualquer alteração nas transações em um bloco seja facilmente detectada.<li><strong>Descentralização</strong>: Permite que cada nó verifique a integridade dos dados independentemente, sem depender de uma autoridade central.<li><strong>Escalabilidade:</strong> As árvores de Merkle são excepcionalmente adequadas para sistemas com grandes volumes de dados devido à sua capacidade de realizar verificações de integridade de maneira eficaz e eficiente.</ul><h2 id="aplicações-práticas">Aplicações Práticas</h2><ol><li><p><strong><em>Blockchain</em> e Criptomoedas:</strong> Conforme vimos acima, as árvores de Merkle são uma peça essencial na estrutura do <em>blockchain</em>. Elas permitem a rápida e eficiente verificação da existência e integridade dos dados sem necessidade de baixar todo o <em>blockchain</em>. Isso é crucial para os nós de “<em>light client</em>” em redes como <strong>Bitcoin</strong> e <strong>Ethereum</strong>.</p><li><p><strong>Sistemas de Controle de Versão:</strong> Em sistemas de controle de versão, como o Git, as árvores de Merkle são utilizadas para gerenciar as versões dos arquivos. Cada commit é representado como uma árvore de Merkle, permitindo que alterações sejam rastreadas de maneira eficiente e segura.</p><li><p><strong>Sistemas de Arquivos Distribuídos:</strong> Em sistemas de arquivos distribuídos, como o IPFS (<em>InterPlanetary File System</em>), as árvores de Merkle facilitam a verificação rápida de que os dados recebidos de outros nós são completos e não corrompidos.</p><li><p><strong>Deduplicação de Dados:</strong> As árvores de Merkle ajudam a identificar dados duplicados em diferentes blocos de um sistema, permitindo a reutilização de <em>hashes</em> armazenados para otimizar o armazenamento.</p></ol><h1 id="aplicações-práticas-dos-algoritmos-de-hash">Aplicações Práticas dos Algoritmos de <em>Hash</em></h1><p>Os algoritmos de <em>hash</em> são uma ferramenta fundamental na segurança da informação, fornecendo uma maneira de criar uma assinatura digital única para dados de qualquer tamanho. Esta assinatura, ou valor de <em>hash</em>, desempenha um papel crucial em diversas aplicações, desde o armazenamento seguro de senhas até a verificação da integridade de software e a implementação de sistemas de assinatura digital.</p><p>Uma das aplicações mais críticas dos algoritmos de <em>hash</em> é no armazenamento seguro de senhas. Ao armazenar senhas, é imperativo que elas não sejam guardadas em texto claro para proteger contra a exposição direta em caso de uma violação de dados. Os algoritmos de <em>hash</em> transformam senhas em um conjunto indecifrável de caracteres.</p><p><em>Hashes</em> também são amplamente utilizados para verificar a integridade de dados e software, assegurando que os arquivos não foram alterados desde sua criação. Este processo é essencial em ambientes onde os dados precisam ser transferidos via redes potencialmente inseguras.</p><p>De modo geral, seguindo o seguinte fluxo:</p><ul><li><strong><em>Hashing</em> de Arquivos:</strong> Um <em>hash</em> é calculado para o arquivo original e armazenado ou transmitido juntamente com o arquivo.<li><strong>Verificação:</strong> Quando o arquivo é recebido, ou antes de ser executado, um novo <em>hash</em> é gerado e comparado com o original. Se os <em>hashes</em> coincidirem, o arquivo não foi alterado; se diferirem, indica uma possível corrupção ou manipulação.</ul><p>Os <em>hashes</em> também são fundamentais na implementação de assinaturas digitais e certificados, usados para verificar a autenticidade de documentos digitais e a identidade dos comunicadores.</p><ul><li><strong>Criação de Assinaturas:</strong> Um <em>hash</em> do conteúdo a ser assinado é primeiro gerado. Esse <em>hash</em> é então criptografado com a chave privada do remetente, formando a assinatura digital.<li><strong>Verificação da Assinatura:</strong> Para verificar a assinatura, o receptor recalcula o <em>hash</em> do conteúdo e o compara com o <em>hash</em> descriptografado usando a chave pública do remetente. Se os <em>hashes</em> coincidirem, a assinatura é considerada válida.</ul><h1 id="funcionamento-geral-de-um-algoritmo-de-hash">Funcionamento Geral de um Algoritmo de <em>Hash</em></h1><p>Um algoritmo de <em>hash</em> recebe como entrada uma quantidade de dados de tamanho variável e produz uma saída de tamanho fixo, conhecida como valor de <em>hash</em> ou simplesmente <em>hash</em>. O processo é realizado por uma função, que executa cálculos específicos para transformar a entrada em uma <em>string</em> de bits de tamanho fixo. A natureza desses cálculos depende do algoritmo específico, mas geralmente envolve operações como permutações, substituições e combinações projetadas para serem rápidas de executar e capazes de dispersar uniformemente os valores de entrada ao longo do espaço de saída do <em>hash</em>.</p><p><strong>Exemplo</strong>: Considere uma função de <em>hash</em> simples projetada para <em>strings</em>. Uma abordagem rudimentar pode envolver a conversão de cada caractere em seu código ASCII correspondente, somando esses valores e então aplicando um módulo com um número primo para garantir um valor de saída fixo. Claro, essa é uma simplificação e não seria segura para aplicações reais, mas ilustra o conceito de transformar uma entrada variável em uma saída de tamanho fixo.</p><h1 id="propriedades-desejáveis-de-um-bom-algoritmo-de-hash">Propriedades Desejáveis de um Bom Algoritmo de <em>Hash</em></h1><p>Para ser considerado seguro e eficiente, um algoritmo de <em>hash</em> deve exibir várias propriedades críticas:</p><ol><li><p><strong>Determinismo</strong>: A mesma entrada sempre deve produzir a mesma saída. Isso é essencial para verificar a integridade dos dados, pois qualquer alteração na entrada resultaria em um <em>hash</em> completamente diferente.</p><li><p><strong>Eficiência</strong>: O algoritmo deve poder processar grandes quantidades de dados rapidamente, retornando o <em>hash</em> sem atrasos significativos. Isso é vital para aplicações que requerem processamento em tempo real ou que lidam com grandes volumes de dados.</p><li><p><strong>Irreversibilidade (Resistência a pré-imagem)</strong>: Deve ser computacionalmente inviável determinar a entrada original a partir de seu <em>hash</em>. Isso protege contra tentativas de reconstruir os dados apenas pelo conhecimento de seu <em>hash</em>, um aspecto crítico na proteção de informações sensíveis como senhas.</p><li><p><strong>Resistência a colisões</strong>: Idealmente, deve ser impossível ou extremamente difícil encontrar duas entradas diferentes que resultem no mesmo <em>hash</em>. Isso impede ataques onde um invasor poderia substituir um item legítimo por outro malicioso que resulte no mesmo valor de <em>hash</em>.</p><li><p><strong>Sensibilidade a pequenas mudanças na entrada</strong>: Um bom algoritmo de hash deve ter o que é frequentemente chamado de “efeito avalanche”, onde uma pequena mudança na entrada (como alterar um único bit) causa uma mudança significativa e imprevisível no <em>hash</em> resultante. Isso aumenta a segurança ao tornar as tentativas de adivinhar a entrada original mediante pequenas modificações impraticáveis.</p></ol><p>Essas propriedades garantem que os <em>hashes</em> possam ser usados em contextos onde a segurança é crítica, como na assinatura digital de contratos eletrônicos ou na proteção contra a manipulação de registros digitais.</p><p>Os algoritmos de <em>hash</em> podem ser classificados em duas categorias principais: <strong><em>hashes</em> criptográficos</strong> e <strong>não criptográficos</strong>. Ambos são projetados para transformar dados de entrada em uma <em>string</em> de saída de tamanho fixo, mas diferem significativamente em termos de finalidade, complexidade e segurança.</p><h2 id="hashes-não-criptográficos"><em>Hashes</em> Não Criptográficos</h2><p><em>Hashes</em> não criptográficos são utilizados principalmente para fins de verificação rápida de dados e para a implementação eficiente de estruturas de dados como tabelas <em>hash</em>, usadas em algoritmos de pesquisa e armazenamento de dados. Eles são projetados para serem extremamente rápidos e minimizar colisões. No entanto, não são adequados para armazenar informações sensíveis, pois não são projetados para serem resistentes a ataques que tentam recuperar a entrada original ou encontrar colisões.</p><h3 id="exemplos-de-hashes-não-criptográficos">Exemplos de <em>Hashes</em> Não Criptográficos:</h3><ul><li><strong>FNV (<em>Fowler-Noll-Vo</em>)</strong>: Popular para <em>hash</em> de <em>strings</em> em bases de dados e tabelas <em>hash</em> devido à sua simplicidade e velocidade.<li><strong>MurmurHash</strong>: Amplamente usado em sistemas distribuídos para particionamento de dados devido à sua eficiência e distribuição uniforme.</ul><p>Esses algoritmos são ideais para aplicações onde a velocidade é mais crítica do que a segurança, como <em>caches</em>, sistemas de detecção de duplicatas, e certas aplicações de rede.</p><h2 id="hashes-criptográficos"><em>Hashes</em> Criptográficos</h2><p><em>Hashes</em> criptográficos, por outro lado, são projetados para oferecer segurança. Eles são uma peça fundamental da infraestrutura de segurança sendo usados em funções como a verificação de integridade de dados, autenticação e assinaturas digitais. Estes algoritmos possuem propriedades específicas, como resistência a colisões e irreversibilidade, que os tornam resistentes a tentativas de reversão ou de encontrar duas entradas que produzam o mesmo hash.</p><h3 id="exemplos-de-hashes-criptográficos">Exemplos de <em>Hashes</em> Criptográficos:</h3><ul><li><strong>MD5</strong>: Embora agora seja considerado inseguro e suscetível a ataques de colisão, foi amplamente usado no passado.<li><strong>SHA-1</strong>: Similar ao MD5 em termos de uso, mas também comprometido por vulnerabilidades de segurança conhecidas.<li><strong>SHA-256</strong>: Parte da família SHA-2, esses algoritmos são atualmente recomendados para novos sistemas devido à sua robustez contra as vulnerabilidades encontradas em precursores como SHA-1 e MD5.<li><strong>Bcrypt</strong>: Projetado especificamente para <em>hashing</em> de senhas, inclui mecanismos como <em>salting</em> e <em>key stretching</em> para proteger contra ataques de força bruta e <em>rainbow tables</em>.</ul><p>Os algoritmos de <em>hash</em> criptográficos são essenciais para garantir a confidencialidade e integridade dos dados em muitas aplicações de segurança. Eles são projetados para serem lentos propositalmente (como no caso do <strong>Bcrypt</strong>) ou computacionalmente intensivos para tornar inviável a execução de ataques de força bruta.</p><h1 id="aspectos-técnicos-dos-algoritmos">Aspectos Técnicos dos Algoritmos</h1><h2 id="construção-de-merkledamgård">Construção de Merkle–Damgård</h2><p>A construção de Merkle–Damgård é uma técnica utilizada para construir funções de <em>hash</em> criptográfico a partir de uma função de compressão. Essa construção garante que mesmo pequenas funções de compressão possam ser usadas para processar mensagens de tamanho arbitrário, mantendo propriedades desejáveis como a resistência a colisões e a pré-imagem.</p><p><strong>Funcionamento:</strong></p><ul><li><strong><em>Padding</em> da Mensagem:</strong> Primeiramente, a mensagem original é estendida (<em>padding</em>) para garantir que seu tamanho seja um múltiplo do tamanho do bloco da função de compressão. Normalmente, isso inclui adicionar um bit ‘1’ seguido por uma série de ‘0’s e o comprimento da mensagem original.<li><strong>Inicialização:</strong> Um valor inicial (IV) é definido. Este valor é fixo para um dado algoritmo de <em>hash</em>.<li><strong>Processamento em Blocos:</strong> A mensagem padronizada é processada em blocos sequenciais utilizando a função de compressão. Cada bloco é combinado com o estado resultante do bloco anterior (ou o IV, para o primeiro bloco) para produzir um novo estado.<li><strong>Finalização:</strong> O estado final após o processamento do último bloco é o <em>hash</em> da mensagem completa.</ul><p>Essa construção é usada em muitos algoritmos populares de <em>hash</em>, como MD5, SHA-1 e SHA-2, mas tem vulnerabilidades conhecidas, especialmente em relação a extensões de mensagens e colisões.</p><h2 id="estrutura-de-esponja">Estrutura de Esponja</h2><p>A estrutura de esponja é uma abordagem alternativa à construção de Merkle–Damgård, usada para construir funções de <em>hash</em>, PRNGs, e cifras de fluxo. SHA-3 (Keccak) utiliza essa construção.</p><p><strong>Funcionamento:</strong></p><ul><li><strong>Configuração do Estado:</strong> A esponja começa com um “estado” inicial que é uma matriz de bits maior do que o <em>hash</em> de saída desejado.<li><strong>Fase de Absorção:</strong> Durante a absorção, a entrada é processada em blocos que são <code class="language-plaintext highlighter-rouge">XORed</code> em uma parte do estado, seguida de uma função de permutação aplicada a todo o estado.<li><strong>Fase de Espremedura:</strong> Após toda a entrada ser absorvida, a saída (<em>hash</em>) é “espremida” do estado. A função de permutação é aplicada entre as leituras dos blocos de saída até que o comprimento desejado do <em>hash</em> seja alcançado.</ul><p>Essa construção é projetada para ser resistente a uma ampla gama de ataques, inclusive aqueles que exploram vulnerabilidades em construções baseadas em Merkle–Damgård.</p><h2 id="salting"><em>Salting</em></h2><p><strong><em>Salting</em></strong> é uma técnica usada para melhorar a segurança de <em>hashes</em> armazenados, especialmente senhas. Um “<em>salt</em>” é uma sequência aleatória de bits criada para cada entrada (senha) antes de aplicar a função de <em>hash</em>.</p><p><strong>Importância:</strong></p><ul><li><strong>Prevenção de Ataques de <em>Rainbow Table</em>:</strong> Sem <em>salting</em>, <em>hashes</em> idênticos podem ser pré-computados e armazenados em tabelas (<em>rainbow tables</em>) para reversão rápida. O <em>salting</em> adiciona um elemento único a cada <em>hash</em>, tornando esses ataques inviáveis.<li><strong>Dificuldade de Adivinhação:</strong> Mesmo se duas entradas forem idênticas, seus <em>hashes</em> serão diferentes devido aos diferentes <em>salts</em>, complicando tentativas de adivinhação.</ul><p><strong>Implementação:</strong></p><ul><li>Gerar um salt aleatório para cada nova senha a ser <em>hashada</em>.<li>Combinar o salt com a senha antes da aplicação do <em>hash</em>.<li>Armazenar o salt com o <em>hash</em> na base de dados para o mesmo poder ser usado na verificação da senha.</ul><h2 id="strengthening"><em>Strengthening</em></h2><p><strong>Key stretching</strong> é uma técnica usada para fortalecer <em>hashes</em> fracos (potencialmente derivados de senhas fracas) ao tornar o processo de <em>hashing</em> intencionalmente mais lento.</p><p><strong>Técnicas Comuns:</strong></p><ul><li><strong>PBKDF2 (<em>Password-Based Key Derivation Function</em> 2):</strong> Aplica uma função de <em>hash</em> múltiplas vezes para aumentar o custo computacional de geração de cada <em>hash</em>.<li><strong>Bcrypt:</strong> Utiliza um custo de trabalho configurável e uma função baseada em Blowfish, iterando sobre uma função de compressão múltiplas vezes.<li><strong>Scrypt:</strong> Aumenta a complexidade ao exigir não apenas tempo de CPU, mas também uma quantidade significativa de memória.</ul><p><strong>Vantagens:</strong></p><ul><li>Protege contra ataques de força bruta, aumentando significativamente o tempo necessário para testar cada senha possível.<li>Permite que sistemas e protocolos ajustem o custo computacional à medida que o hardware evolui.</ul><p>Essas técnicas são cruciais para a segurança de sistemas que dependem de senhas e outras formas de autenticação baseada em segredos que podem ser vulneráveis a ataques se não forem adequadamente protegidas.</p><h1 id="algoritmos-de-hash-criptográficos-mais-comuns">Algoritmos de <em>Hash</em> Criptográficos Mais Comuns</h1><h2 id="md5-message-digest-algorithm-5">MD5 (<em>Message Digest Algorithm</em> 5)</h2><p><strong>MD5</strong> é um algoritmo de <em>hash</em> criptográfico que gera um <em>hash</em> de 128 bits (16 <em>bytes</em>). Desenvolvido por Ronald Rivest em 1991, era amplamente utilizado para garantir a integridade dos dados. Embora comprometido em termos de segurança, sua estrutura é uma excelente introdução ao <em>design</em> de funções de <em>hash</em> criptográficas.</p><p><strong>Funcionamento</strong>:</p><p>Conforme a <a href="https://www.ietf.org/rfc/rfc1321.txt">RFC1321</a>, o MD5 é calculado da seguinte forma:</p><ol><li><p><strong><em>Padding</em></strong>: A mensagem é estendida para que seu comprimento seja congruente a 448, modulo 512. Isso significa que a mensagem original é seguida por um bit ‘1’, depois por vários bits ‘0’, e finalmente pelo comprimento original da mensagem em 64 bits.</p><li><p><strong>Inicialização de <em>Buffers</em></strong>: Quatro variáveis de estado (buffers) são inicializadas. Estas são tratadas como registros de 32 bits:</p><ul><li>A = 0x67452301<li>B = 0xefcdab89<li>C = 0x98badcfe<li>D = 0x10325476</ul><li><p><strong>Processamento em Blocos</strong>: A mensagem padronizada é então processada em blocos de 512 bits. Cada bloco de 512 bits é dividido em 16 blocos de 32 bits. A transformação do MD5 usa uma função auxiliar principal que tem quatro funções auxiliares (F, G, H e I).</p></ol><ul><li><p><strong>Funções Auxiliares</strong>:</p><ul><li><code class="language-plaintext highlighter-rouge">F(X,Y,Z) = (X ∧ Y) ∨ (¬X ∧ Z)</code><li><code class="language-plaintext highlighter-rouge">G(X,Y,Z) = (X ∧ Z) ∨ (Y¬∧Z)</code><li><code class="language-plaintext highlighter-rouge">H(X,Y,Z) = X ⊕ Y ⊕Z</code><li><code class="language-plaintext highlighter-rouge">I(X,Y,Z) = Y ⊕ (X ∨ ¬Z)</code></ul></ul><p>Cada rodada (total de 4 rodadas) utiliza uma função diferente e opera em todos os blocos de 32 bits. A cada passo, uma das funções auxiliares é aplicada e o resultado é somado com um dos blocos de entrada, uma constante específica da rodada, e uma parte do <em>buffer</em>. Depois, o resultado é rotacionado por um número específico de bits e somado ao <em>buffer</em>.</p><ul><li><p><strong>Constantes de Rodada</strong>: Cada rodada utiliza uma constante diferente, sendo valores fixos derivados dos senos de ângulos. Isso garante a aleatoriedade na transformação.</p><li><p><strong>Rotações de Bits</strong>: As rotações são especificadas para cada operação nas rodadas. Por exemplo, na primeira rodada, você pode rotacionar o resultado em 7 bits, então em 12 bits no próximo passo, e assim por diante.</p></ul><ol><li><strong>Saída do Hash</strong>: Após todas as rodadas serem processadas, os quatro <em>buffers</em> (A, B, C, D) contêm o <em>hash</em> final. Eles são concatenados para formar um <em>hash</em> de 128 bits, sendo o <strong>MD5</strong>.</ol><h2 id="sha-1-secure-hash-algorithm-1">SHA-1 (<em>Secure Hash Algorithm</em> 1)</h2><p><strong>SHA-1</strong> produz um <em>hash</em> de 160 bits e é estruturalmente similar ao MD5, porém com uma ênfase maior na segurança, apesar de também ter sido comprometido por vulnerabilidades.</p><p><strong>Funcionamento</strong>:</p><p>Conforme a <a href="https://datatracker.ietf.org/doc/html/rfc3174">RFC3174</a>, o MD5 é calculado da seguinte forma:</p><ol><li><p><strong>Padding da Mensagem</strong>: Primeiramente, a mensagem original é preparada para garantir que seu tamanho seja congruente a 448 mod 512. Isso é feito adicionando um bit ‘1’ seguido por zeros e, finalmente, o tamanho da mensagem original em bits é anexado ao final (64 bits). Esse passo garante que o tamanho total da mensagem seja um múltiplo de 512 bits.</p><li><p><strong>Inicialização das Variáveis</strong>: No SHA-1, utilizamos cinco variáveis de 32 bits inicializadas com os seguintes valores hexadecimais:</p></ol><ul><li>A = 0x67452301<li>B = 0xEFCDAB89<li>C = 0x98BADCFE<li>D = 0x10325476<li>E = 0xC3D2E1F0</ul><p>Estes valores são constantes iniciais definidas pela especificação SHA-1.</p><ol><li><strong>Processamento dos Blocos</strong>: Cada bloco de 512 bits da mensagem padronizada é processado em uma série de etapas. Primeiro, o bloco é dividido em 16 palavras de 32 bits. Essas palavras são então expandidas para 80 palavras por meio de uma operação de <strong>XOR</strong> (<em>exclusive or</em>) dos quatro valores anteriores:</ol><ul><li>Para i de 16 até 79:<ul><li><code class="language-plaintext highlighter-rouge">W[i]=(W[i−3]⊕W[i−8]⊕W[i−14]⊕W[i−16])&lt;&lt;&lt;1</code></ul></ul><p>Onde <code class="language-plaintext highlighter-rouge">&lt;&lt;&lt;</code> denota uma rotação à esquerda.</p><ol><li><strong>Rodadas de <em>Hashing</em></strong>: SHA-1 processa essas 80 palavras em cinco rodadas de 16 operações cada. Cada rodada usa uma função diferente:</ol><ul><li>Funções para cada rodada:<ul><li><code class="language-plaintext highlighter-rouge">f(t,B,C,D)=(B∧C)∨(¬B∧D) (0 ≤ t ≤ 19)</code><li><code class="language-plaintext highlighter-rouge">f(t,B,C,D)=B⊕C⊕D (20 ≤ t ≤ 39)</code><li><code class="language-plaintext highlighter-rouge">f(t,B,C,D)=(B∧C)∨(B∧D)∨(C∧D) (40 ≤ t ≤ 59)</code><li><code class="language-plaintext highlighter-rouge">f(t,B,C,D)=B⊕C⊕D (60 ≤ t ≤ 79)</code></ul></ul><p>E uma constante K diferente é usada em cada rodada:</p><ul><li>K = 0x5A827999 (0 ≤ t ≤ 19)<li>K = 0x6ED9EBA1 (20 ≤ t ≤ 39)<li>K = 0x8F1BBCDC (40 ≤ t ≤ 59)<li>K = 0xCA62C1D6 (60 ≤ t ≤ 79)</ul><p>Para cada palavra <code class="language-plaintext highlighter-rouge">W[i]</code>:</p><ul><li><code class="language-plaintext highlighter-rouge">Temp = (A &lt;&lt;&lt; 5) + f(t, B, C, D) + E + W[i] + K</code><li><code class="language-plaintext highlighter-rouge">E = D</code><li><code class="language-plaintext highlighter-rouge">D = C</code><li><code class="language-plaintext highlighter-rouge">C = B &lt;&lt;&lt; 30</code><li><code class="language-plaintext highlighter-rouge">B = A</code><li><code class="language-plaintext highlighter-rouge">A = Temp</code></ul><ol><li><p><strong>Atualização das Variáveis</strong>: Após o processamento de cada bloco de 512 bits, os valores de A, B, C, D e E são adicionados aos valores acumulados das variáveis correspondentes.</p><li><p><strong>Output do Hash</strong>: Após todos os blocos serem processados, o resultado é concatenado das variáveis A, B, C, D e E para formar o <em>digest</em> SHA-1 de 160 bits.</p></ol><h2 id="sha-2-secure-hash-algorithm-2">SHA-2 (<em>Secure Hash Algorithm</em> 2)</h2><p><strong>SHA-2</strong> inclui várias funções: SHA-224, SHA-256, SHA-384 e SHA-512. Os métodos são semelhantes, mas diferem principalmente no tamanho dos blocos e dos hashes.</p><p><strong>Funcionamento</strong>:</p><p>Conforme a <a href="https://datatracker.ietf.org/doc/html/rfc6234">RFC6234</a> que resume as RFCs da familia <strong>SHA-2</strong>, o SHA-256 é calculado da seguinte forma:</p><ol><li><p><strong>Preparação da Mensagem</strong>: Primeiro, a mensagem original é preparada para garantir que seu comprimento seja um múltiplo de 512 bits. Isso é feito adicionando um bit ‘1’ seguido de ‘0’s suficientes e finalmente o tamanho da mensagem original em bits é anexado no final (64 bits). O objetivo é fazer com que o comprimento total seja congruente a 448 mod 512.</p><li><p><strong>Inicialização das Variáveis</strong>: O SHA-256 utiliza oito variáveis de estado inicializadas com valores específicos derivados das raízes quadradas dos primeiros oito números primos:</p></ol><ul><li>A = 0x6a09e667<li>B = 0xbb67ae85<li>C = 0x3c6ef372<li>D = 0xa54ff53a<li>E = 0x510e527f<li>F = 0x9b05688c<li>G = 0x1f83d9ab<li>H = 0x5be0cd19</ul><ol><li><strong>Processamento dos Blocos</strong>: Cada bloco de 512 bits da mensagem processada é dividido em 16 palavras iniciais de 32 bits. Estas 16 palavras são expandidas para 64 palavras usando a seguinte fórmula:</ol><ul><li>Para i de 16 até 63:<ul><li><code class="language-plaintext highlighter-rouge">W[i]=σ1​(W[i−2])+W[i−7]+σ0​(W[i−15])+W[i−16]</code></ul></ul><p>Onde:</p><ul><li><code class="language-plaintext highlighter-rouge">σ0​(x)=(x⋙7)⊕(x⋙18)⊕(x≫3)</code><li><code class="language-plaintext highlighter-rouge">σ1​(x)=(x⋙17)⊕(x⋙19)⊕(x≫10)</code></ul><ol><li><strong>Rodadas de Compressão</strong>: O SHA-256 usa 64 rodadas de compressão. Em cada rodada, as seguintes fórmulas são aplicadas:</ol><ul><li><code class="language-plaintext highlighter-rouge">T1=H+Σ1​(E)+Ch(E,F,G)+K[i]+W[i]</code><li><code class="language-plaintext highlighter-rouge">T2=Σ0​(A)+Maj(A,B,C)</code><li>Depois, as variáveis são atualizadas:<ul><li><code class="language-plaintext highlighter-rouge">H=G</code><li><code class="language-plaintext highlighter-rouge">G=F</code><li><code class="language-plaintext highlighter-rouge">F=E</code><li><code class="language-plaintext highlighter-rouge">E=D+T1</code><li><code class="language-plaintext highlighter-rouge">D=C</code><li><code class="language-plaintext highlighter-rouge">C=B</code><li><code class="language-plaintext highlighter-rouge">B=A</code><li><code class="language-plaintext highlighter-rouge">A=T1+T2</code></ul></ul><p>Onde:</p><ul><li><code class="language-plaintext highlighter-rouge">Σ0​(x)=(x⋙2)⊕(x⋙13)⊕(x⋙22)</code><li><code class="language-plaintext highlighter-rouge">Σ1​(x)=(x⋙6)⊕(x⋙11)⊕(x⋙25)</code><li><code class="language-plaintext highlighter-rouge">Ch(x,y,z)=(x∧y)⊕(¬x∧z)</code><li><code class="language-plaintext highlighter-rouge">Maj(x,y,z)=(x∧y)⊕(x∧z)⊕(y∧z)</code><li><code class="language-plaintext highlighter-rouge">K[i]</code> é uma constante específica da rodada.</ul><ol><li><strong>Output do <em>Hash</em></strong>: Após todas as rodadas, as variáveis A, B, C, D, E, F, G e H são somadas aos seus respectivos valores antes do início do bloco. O resultado do <em>hash</em> será a concatenação dessas oito variáveis após o processamento de todos os blocos.</ol><h2 id="sha-3-secure-hash-algorithm-3">SHA-3 (<em>Secure Hash Algorithm</em> 3)</h2><p><strong>SHA-3</strong>, também conhecido como Keccak, é a adição mais recente, utilizando uma abordagem completamente diferente conhecida como “<em>sponge construction</em>”.</p><p><strong>Funcionamento</strong>:</p><p>SHA-3 opera usando uma estrutura de dados chamada “estado”, que é uma matriz de 5x5 palavras de 64 bits cada (totalizando 1600 bits no estado). A entrada é processada em blocos de tamanho específico, e a saída é produzida “espremendo” o estado. De forma simplificada, abaixo, seguem as etapas de como o SHA-3-256 é calculado:</p><ol><li><p><strong>Inicialização</strong>: O estado inicial é configurado com todos os bits zerados.</p><li><p><strong>Absorção</strong>: A entrada é dividida em blocos de tamanho <code class="language-plaintext highlighter-rouge">r</code> (taxa de bits), que para o SHA-3-256 é 1088 bits. Cada bloco é <code class="language-plaintext highlighter-rouge">XORed</code> em uma parte do estado, seguido por uma permutação do estado completo.</p><li><p><strong>Permutação</strong>: A permutação é a parte central do SHA-3, envolvendo várias operações detalhadas:</p></ol><ul><li><strong>Theta (Θ)</strong>: Cada bit no estado é atualizado com base em dois cálculos que envolvem suas colunas.<li><strong>Rho (ρ) e Pi (π)</strong>: Bits são rotacionados e reposicionados em todo o estado para proporcionar difusão.<li><strong>Chi (χ)</strong>: Uma função não-linear que atualiza cada bit com base em uma função de três bits na mesma linha.<li><strong>Iota (ι)</strong>: Uma constante é <code class="language-plaintext highlighter-rouge">XORed</code> no estado para evitar simetrias.</ul><ol><li><strong>Espremedura</strong>: Após a fase de absorção, a saída (<em>hash</em>) é produzida lendo blocos de bits do estado e continuando com a permutação até que a quantidade de bits desejada seja alcançada.</ol><h3 id="fórmulas-das-operações-de-permutação">Fórmulas das Operações de Permutação</h3><p>Aqui estão algumas das fórmulas mais relevantes para entender o SHA-3:</p><ul><li><strong>Theta (Θ)</strong>:</ul><div lang="plaintext" class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>C[x]=estado[x,0]⊕estado[x,1]⊕estado[x,2]⊕estado[x,3]⊕estado[x,4]

D[x]=C[x−1]⊕rotl(C[x+1],1)

estado[x,y]←estado[x,y]⊕D[x]
</pre></table></code></div></div><ul><li><p><strong>Rho (ρ) e Pi (π)</strong>: A rotação é específica para cada bit e segue um padrão predeterminado. Pi rearranja os bits com base numa fórmula que troca as coordenadas dos bits.</p><li><p><strong>Chi (χ)</strong>:</p><p><code class="language-plaintext highlighter-rouge">estado[x,y]←estado[x,y]⊕((¬estado[x+1,y])∧estado[x+2,y])</code></p><li><p><strong>Iota (ι)</strong>: Uma constante de rodada é <code class="language-plaintext highlighter-rouge">XORed</code> no bit <code class="language-plaintext highlighter-rouge">[0,0]</code> do estado para cada rodada da permutação.</p></ul><h1 id="algoritmos-de-hash-específicos-para-senhas">Algoritmos de Hash Específicos para Senhas</h1><p>Os algoritmos de <em>hash</em> específicos para senhas como <strong>bcrypt</strong>, <strong>scrypt</strong> e <strong>Argon2</strong> são projetados para proteger senhas armazenadas contra ataques de força bruta e outros tipos de ataques. Eles são essenciais na segurança de dados, especialmente em sistemas onde senhas precisam ser armazenadas de forma segura.</p><h2 id="bcrypt">Bcrypt</h2><p><strong>Funcionamento:</strong></p><p>Bcrypt é uma função de <em>hash</em> adaptativa criada por Niels Provos e David Mazières baseada no algoritmo Blowfish. Ele incorpora um custo de trabalho (também conhecido como fator de carga), que permite ajustar o custo computacional necessário para gerar o <em>hash</em>. Bcrypt executa as seguintes etapas:</p><ul><li>Gera um <em>salt</em> (sequência aleatória) para cada senha, evitando assim ataques de <em>rainbow table</em>.<li>Usa o salt e a senha para produzir um <em>hash</em> através de uma série de transformações criptográficas baseadas em Blowfish.<li>O número de rodadas de <em>hash</em> é ajustável, aumentando exponencialmente a dificuldade de ataque à medida que a capacidade computacional dos atacantes aumenta.</ul><p><strong>Vantagens:</strong></p><ul><li>Resistente a ataques de <em>rainbow table</em> devido ao <em>salting</em>.<li>Adapta-se ao aumento da capacidade de processamento ao permitir ajustar o número de rodadas.<li>Amplamente suportado e testado em muitos sistemas e <em>frameworks</em>.</ul><p><strong>Quando Utilizar:</strong></p><p>Bcrypt é ideal para sistemas que necessitam de um equilíbrio entre segurança e desempenho. É adequado para a maioria das aplicações web onde as senhas precisam ser armazenadas de forma segura.</p><h2 id="scrypt">Scrypt</h2><p><strong>Funcionamento:</strong></p><p>Desenvolvido por Colin Percival, scrypt é uma função de <em>hash</em> que, além de ser computacionalmente intensiva, também é intensiva em termos de uso de memória. O algoritmo realiza o <em>hash</em> da senha usando um salt e realiza muitas iterações de uma função derivada de senha, projetada para usar uma grande quantidade de memória, além de CPU.</p><p><strong>Vantagens:</strong></p><ul><li>Resistente a ataques tanto de força bruta como de hardware especializado, como ASICs e FPGAs, devido ao seu alto requisito de memória.<li>Configurável para exigir quantidades significativas tanto de memória quanto de tempo, aumentando assim a segurança contra vários tipos de ataques.</ul><p><strong>Quando Utilizar:</strong></p><p>Scrypt pode ser usado em ambientes onde há uma preocupação particular com ataques que utilizam hardware especializado para quebrar senhas. É ideal para sistemas onde a segurança extra justifica o uso adicional de recursos.</p><h2 id="argon2">Argon2</h2><p><strong>Funcionamento:</strong></p><p>Argon2, vencedor da <em>Password Hashing Competition</em> em 2015, foi projetado para ser o estado da arte em <em>hashing</em> de senhas. Ele vem em duas variantes principais: <strong>Argon2d</strong> e <strong>Argon2i</strong>.</p><p>Argon2d oferece maior resistência contra ataques de GPU e é otimizado para aplicações onde a ameaça é principalmente de atacantes que podem fazer muitas tentativas offline.</p><p>Argon2i é otimizado para aplicações que requerem resistência contra ataques de <em>tradeoff</em> de tempo-memória e é mais adequado para senhas e chaves criptográficas.</p><ul><li>Usa memória, CPU e paralelismo para complicar os ataques.<li>Incorpora um salt e um parâmetro de paralelismo para permitir o uso de múltiplos núcleos de processamento.</ul><p><strong>Vantagens:</strong></p><ul><li>Oferece proteção contra uma ampla gama de ataques potenciais, incluindo ataques que usam GPUs e ASICs.<li>Permite ajuste fino do uso de memória, do custo computacional e do paralelismo.</ul><p><strong>Quando Utilizar:</strong></p><p>Argon2 é recomendado para novos sistemas que necessitam do mais alto nível de proteção para senhas. Sua capacidade de ajuste e resistência a vários tipos de ataques o torna adequado para sistemas que priorizam a segurança.</p><h1 id="ataques-comuns-contra-algoritmos-de-hash">Ataques Comuns Contra Algoritmos de Hash</h1><p>Os algoritmos de hash são fundamentais para a segurança de dados em muitas aplicações, como autenticação, integridade de arquivos, e assinatura digital. No entanto, eles podem ser vulneráveis a diversos tipos de ataques.</p><h2 id="ataques-de-colisão">Ataques de Colisão</h2><p>Um ataque de colisão ocorre quando dois dados diferentes produzem o mesmo <em>hash</em>. Este é um problema significativo, especialmente para funções de <em>hash</em> criptográfico, ao comprometer a integridade dos dados e a segurança das comunicações digitais.</p><p>Os atacantes utilizam métodos matemáticos ou de força bruta para encontrar dois <em>inputs</em> distintos que resultem no mesmo <em>hash</em>. Isso pode ser feito através de ajustes sistemáticos nos dados de entrada até que uma colisão seja encontrada.</p><h3 id="exemplo-real-vulnerabilidade-no-md5-caso-flame">Exemplo Real: Vulnerabilidade no MD5 (Caso Flame)</h3><p>O <em>malware Flame</em> usou um <a href="https://msrc.microsoft.com/blog/2012/06/flame-malware-collision-attack-explained/">ataque de colisão para falsificar um certificado da <strong>Microsoft</strong></a>, permitindo que o <em>malware</em> se disfarçasse como uma atualização de software legítima da Microsoft.</p><p>Utilizando uma vulnerabilidade no algoritmo MD5, os atacantes conseguiram criar um certificado digital falso que parecia ser emitido pela Microsoft. A colisão permitiu que o certificado falso passasse as verificações de autenticidade, enganando sistemas e softwares de segurança.</p><h2 id="ataques-de-pré-imagem-e-segunda-pré-imagem">Ataques de Pré-imagem e Segunda Pré-imagem</h2><p><strong>Ataque de Pré-imagem:</strong></p><p>Tentativa de encontrar uma entrada que corresponda a um <em>hash</em> específico. O objetivo é reverter a <em>hash</em> para a entrada original, comprometendo a irreversibilidade da função de hash.</p><p><strong>Ataque de Segunda Pré-imagem:</strong></p><p>Similar ao ataque de pré-imagem, mas em vez de tentar reverter o <em>hash</em> para qualquer entrada, o atacante tenta encontrar uma nova entrada que não seja a original mas que produza o mesmo <em>hash</em>.</p><p>Esses ataques exigem capacidade computacional significativa, pois o atacante precisa calcular o <em>hash</em> de muitas entradas potenciais até encontrar uma que coincida com o <em>hash</em> alvo.</p><h3 id="exemplo-real-vulnerabilidade-sha-1-shattered">Exemplo Real: Vulnerabilidade SHA-1 (SHAttered)</h3><p>Em 2017, pesquisadores do Google e do CWI Amsterdam demonstraram o primeiro <a href="https://shattered.io/">ataque prático de colisão contra o algoritmo SHA-1</a>, conhecido como SHAttered.</p><p>Embora tecnicamente um ataque de colisão, o caso SHAttered é relevante aqui devido à sua proximidade com conceitos de pré-imagem, pois mostrou como duas entradas diferentes poderiam ser criadas para gerar o mesmo hash SHA-1, comprometendo assim a integridade de documentos que dependiam desta função para segurança.</p><h2 id="rainbow-tables-e-salting"><em>Rainbow Tables</em> e <em>Salting</em></h2><p><em>Rainbow tables</em> são grandes pré-computações de pares de <em>hashes</em> e suas entradas correspondentes. Elas são usadas para reverter <em>hashes</em> de maneira eficiente, especialmente para senhas, reduzindo significativamente o tempo necessário para quebrar um <em>hash</em> comum.</p><p>Ao usar uma <em>rainbow table</em>, um atacante pode simplesmente procurar o <em>hash</em> na tabela para encontrar a entrada correspondente rapidamente, sem a necessidade de calcular o <em>hash</em> durante o ataque.</p><h3 id="mitigação-com-salting">Mitigação com Salting</h3><p>Ao adicionar um <em>salt</em> à senha antes de <em>hashá-la</em>, cada <em>hash</em> se torna único mesmo para senhas idênticas entre diferentes usuários. Isso torna ineficaz o uso de <em>rainbow tables</em>, pois o atacante teria que gerar uma nova <em>rainbow table</em> para cada salt diferente, o que é impraticável devido ao enorme espaço e tempo de computação necessários.</p><h3 id="exemplo-real-ataque-à-rede-linkedin-em-2012">Exemplo Real: Ataque à rede LinkedIn em 2012</h3><p>Em 2012, a LinkedIn sofreu uma violação de dados em que cerca de <a href="https://en.wikipedia.org/wiki/2012_LinkedIn_hack">6,5 milhões de <em>hashes</em> de senha SHA-1, sem <em>salting</em>, foram roubados</a> e mais tarde vazados.</p><p>Os atacantes usaram <em>rainbow tables</em> para decifrar rapidamente as senhas, uma vez que a ausência de <em>salting</em> tornou as <em>hashes</em> vulneráveis a esse tipo de ataque. A facilidade de acesso às <em>rainbow tables</em> e a falta de <em>salting</em> resultaram em um grande número de senhas sendo rapidamente comprometidas.</p><h1 id="comparativo-dos-principais-algoritmos-de-hash">Comparativo dos Principais Algoritmos de Hash</h1><p>A escolha de um algoritmo de <em>hash</em> depende da necessidade específica de segurança, performance e uso de recursos. Enquanto MD5 e SHA-1 são mais rápidos, eles são recomendados apenas para aplicações não seguras devido às suas vulnerabilidades conhecidas. SHA-256 e SHA-3 oferecem um excelente equilíbrio entre segurança e eficiência, sendo ideais para aplicações críticas. Já o bcrypt, embora lento, é a escolha ideal para o armazenamento seguro de senhas devido à sua resistência a ataques de força bruta.</p><p><strong>Tabela Comparativa</strong></p><div class="table-wrapper"><table><thead><tr><th>Algoritmo<th>Tamanho do Hash<th>Resistência a Colisões<th>Resistência a Pré-Imagem<th>Uso de Recursos<th>Performance<tbody><tr><td>MD5<td>128 bits<td>Baixa<td>Baixa<td>Baixo<td>Muito Alta<tr><td>SHA-1<td>160 bits<td>Baixa<td>Moderada<td>Moderado<td>Alta<tr><td>SHA-256<td>256 bits<td>Alta<td>Alta<td>Moderado<td>Moderada<tr><td>SHA-3<td>256 bits<td>Muito Alta<td>Muito Alta<td>Alto<td>Moderada<tr><td>Bcrypt<td>184 bits<td>Alta<td>Alta<td>Alto<td>Baixa</table></div><h1 id="conclusão">Conclusão</h1><p>Este artigo, proporcionou uma exploração não tão superficial sobre o papel vital que os algoritmos de <em>hash</em> desempenham no campo da cibersegurança, abrangendo desde o armazenamento seguro de senhas até a integridade de software e sistemas de assinaturas digitais. Os <em>hashes</em>, frequentemente percebidos como ferramentas simples para a validação de dados, revelam uma complexidade e uma aplicabilidade muito maiores quando examinados mais de perto.</p><p>Além disso, a discussão sobre as árvores de Merkle ressalta como os hashes podem ser estrategicamente utilizados para otimizar a verificação e o armazenamento de grandes volumes de dados, uma técnica que tem sido indispensável no desenvolvimento de tecnologias de blockchain e outros sistemas distribuídos.</p><p>Portanto, a compreensão aprofundada sobre os <em>hashes</em> enriquece nosso conhecimento técnico.</p><h1 id="referências">Referências</h1><ul><li><a href="https://www.ietf.org/rfc/rfc1321.txt">RFC1321</a><li><a href="https://datatracker.ietf.org/doc/html/rfc3174">RFC3174</a><li><a href="https://datatracker.ietf.org/doc/html/rfc6234">RFC6234</a><li><a href="https://msrc.microsoft.com/blog/2012/06/flame-malware-collision-attack-explained/">https://msrc.microsoft.com/blog/2012/06/flame-malware-collision-attack-explained/</a><li><a href="https://shattered.io/">https://shattered.io/</a><li><a href="https://en.wikipedia.org/wiki/2012_LinkedIn_hack">https://en.wikipedia.org/wiki/2012_LinkedIn_hack</a></ul></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/estudos/'>Estudos</a>, <a href='/categories/hashes/'>Hashes</a>, <a href='/categories/criptografia/'>Criptografia</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/md5/" class="post-tag no-text-decoration" >MD5</a> <a href="/tags/sha/" class="post-tag no-text-decoration" >SHA</a> <a href="/tags/hash/" class="post-tag no-text-decoration" >Hash</a> <a href="/tags/blockchain/" class="post-tag no-text-decoration" >Blockchain</a> <a href="/tags/merkle/" class="post-tag no-text-decoration" >Merkle</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Integridade e Autenticidade: Como Algoritmos de Hash Moldam a Segurança Digital - H41stur&url=https://h41stur.github.io/posts/hashes/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Integridade e Autenticidade: Como Algoritmos de Hash Moldam a Segurança Digital - H41stur&u=https://h41stur.github.io/posts/hashes/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Integridade e Autenticidade: Como Algoritmos de Hash Moldam a Segurança Digital - H41stur&url=https://h41stur.github.io/posts/hashes/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://www.linkedin.com/sharing/share-offsite/?url=https://h41stur.github.io/posts/hashes/" data-toggle="tooltip" data-placement="top" title="Linkedin" target="_blank" rel="noopener" aria-label="Linkedin"> <i class="fa-fw fab fa-linkedin"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink('', 'Link copied successfully!')" data-toggle="tooltip" data-placement="top" title="Copy link"> </i> </span></div></div></div></div><div> <script src="https://utteranc.es/client.js" repo="h41stur/h41stur.github.io" issue-term="url" theme="photon-dark" crossorigin="anonymous" async> </script></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/process-injection/">Process Injection 101</a><li><a href="/posts/evasao-av/">Evasão de Antivírus - Princípios Gerais e Abordagens Específicas</a><li><a href="/posts/paper-heap/">Heap Exploitation P.1</a><li><a href="/posts/shellcoding101/">Shellcoding 101</a><li><a href="/posts/replay-sinal-rf/">Uma Jornada no Hardware Hacking: Criando um Clonador de Sinais RF</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/linux/">Linux</a> <a class="post-tag" href="/tags/windows/">Windows</a> <a class="post-tag" href="/tags/assembly/">Assembly</a> <a class="post-tag" href="/tags/binary-exploitation/">Binary Exploitation</a> <a class="post-tag" href="/tags/buffer-overflow/">Buffer Overflow</a> <a class="post-tag" href="/tags/web/">Web</a> <a class="post-tag" href="/tags/htb/">HTB</a> <a class="post-tag" href="/tags/vulnserver/">Vulnserver</a> <a class="post-tag" href="/tags/android/">Android</a> <a class="post-tag" href="/tags/kernel/">Kernel</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/bypass-net-amsi/"><div class="card-body"> <span class="timeago small" >Mar 6, 2023<i class="unloaded">2023-03-06T01:00:00-03:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Bypass de processos específicos de AMSI</h3><div class="text-muted small"><p> Introdução Bypass de AMSI no Powershell Diferença entre Bypass do AMSI do PowerShell e Processos Específicos do AMSI Introdução AMSI (Antimalware Scan Interface) é uma interface de prog...</p></div></div></a></div><div class="card"> <a href="/posts/beyond-the-alert/"><div class="card-body"> <span class="timeago small" >Jun 24, 2023<i class="unloaded">2023-06-24T01:00:00-03:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Beyond the alert()</h3><div class="text-muted small"><p> Introdução Objetivo Obtendo o Projeto Resolução das Tasks Task 1 - Modify HTML Elements Task 2 - Manipulating Forms Task 3 - Intercept Form Submit Task 4 - S...</p></div></div></a></div><div class="card"> <a href="/posts/bypass-flutter-ssl/"><div class="card-body"> <span class="timeago small" >Jan 16, 2024<i class="unloaded">2024-01-16T01:00:00-03:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Flutter SSL Pinning Bypass</h3><div class="text-muted small"><p> TL-DR Os apps criados utilizando o framework Flutter processam as conexões seguras e obedecem às definições de proxy de forma distinta se comparados aos apps programados em DEX. Uma biblioteca d...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/bypass-flutter-ssl/" class="btn btn-outline-primary" prompt="Older"><p>Flutter SSL Pinning Bypass</p></a> <a href="/posts/replay-sinal-rf/" class="btn btn-outline-primary" prompt="Newer"><p>Uma Jornada no Hardware Hacking: Criando um Clonador de Sinais RF</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://github.com/h41stur">H41stur</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/linux/">Linux</a> <a class="post-tag" href="/tags/windows/">Windows</a> <a class="post-tag" href="/tags/assembly/">Assembly</a> <a class="post-tag" href="/tags/binary-exploitation/">Binary Exploitation</a> <a class="post-tag" href="/tags/buffer-overflow/">Buffer Overflow</a> <a class="post-tag" href="/tags/web/">Web</a> <a class="post-tag" href="/tags/htb/">HTB</a> <a class="post-tag" href="/tags/vulnserver/">Vulnserver</a> <a class="post-tag" href="/tags/android/">Android</a> <a class="post-tag" href="/tags/kernel/">Kernel</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://h41stur.github.io{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.16.1,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id="></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', ''); }); </script>
